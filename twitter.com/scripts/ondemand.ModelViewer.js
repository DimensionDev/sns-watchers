;(window.webpackJsonp = window.webpackJsonp || []).push([
  [223],
  {
    'e+MU': function (t, e, i) {
      'use strict'
      i.r(e),
        i.d(e, 'ModelViewerElement', function () {
          return mv
        })
      /**
       * @license
       * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
       * This code may only be used under the BSD style license found at
       * http://polymer.github.io/LICENSE.txt
       * The complete set of authors may be found at
       * http://polymer.github.io/AUTHORS.txt
       * The complete set of contributors may be found at
       * http://polymer.github.io/CONTRIBUTORS.txt
       * Code distributed by Google as part of the polymer project is also
       * subject to an additional IP rights grant found at
       * http://polymer.github.io/PATENTS.txt
       */
      const n =
          'undefined' != typeof window &&
          null != window.customElements &&
          void 0 !== window.customElements.polyfillWrapFlushCallback,
        s = (t, e, i = null) => {
          for (; e !== i; ) {
            const i = e.nextSibling
            t.removeChild(e), (e = i)
          }
        },
        r = `{{lit-${String(Math.random()).slice(2)}}}`,
        a = `\x3c!--${r}--\x3e`,
        o = new RegExp(`${r}|${a}`)
      class l {
        constructor(t, e) {
          ;(this.parts = []), (this.element = e)
          const i = [],
            n = [],
            s = document.createTreeWalker(e.content, 133, null, !1)
          let a = 0,
            l = -1,
            h = 0
          const {
            strings: p,
            values: { length: A },
          } = t
          for (; h < A; ) {
            const t = s.nextNode()
            if (null !== t) {
              if ((l++, 1 === t.nodeType)) {
                if (t.hasAttributes()) {
                  const e = t.attributes,
                    { length: i } = e
                  let n = 0
                  for (let t = 0; t < i; t++) c(e[t].name, '$lit$') && n++
                  for (; n-- > 0; ) {
                    const e = p[h],
                      i = d.exec(e)[2],
                      n = i.toLowerCase() + '$lit$',
                      s = t.getAttribute(n)
                    t.removeAttribute(n)
                    const r = s.split(o)
                    this.parts.push({ type: 'attribute', index: l, name: i, strings: r }), (h += r.length - 1)
                  }
                }
                'TEMPLATE' === t.tagName && (n.push(t), (s.currentNode = t.content))
              } else if (3 === t.nodeType) {
                const e = t.data
                if (e.indexOf(r) >= 0) {
                  const n = t.parentNode,
                    s = e.split(o),
                    r = s.length - 1
                  for (let e = 0; e < r; e++) {
                    let i,
                      r = s[e]
                    if ('' === r) i = u()
                    else {
                      const t = d.exec(r)
                      null !== t &&
                        c(t[2], '$lit$') &&
                        (r = r.slice(0, t.index) + t[1] + t[2].slice(0, -'$lit$'.length) + t[3]),
                        (i = document.createTextNode(r))
                    }
                    n.insertBefore(i, t), this.parts.push({ type: 'node', index: ++l })
                  }
                  '' === s[r] ? (n.insertBefore(u(), t), i.push(t)) : (t.data = s[r]), (h += r)
                }
              } else if (8 === t.nodeType)
                if (t.data === r) {
                  const e = t.parentNode
                  ;(null !== t.previousSibling && l !== a) || (l++, e.insertBefore(u(), t)),
                    (a = l),
                    this.parts.push({ type: 'node', index: l }),
                    null === t.nextSibling ? (t.data = '') : (i.push(t), l--),
                    h++
                } else {
                  let e = -1
                  for (; -1 !== (e = t.data.indexOf(r, e + 1)); ) this.parts.push({ type: 'node', index: -1 }), h++
                }
            } else s.currentNode = n.pop()
          }
          for (const r of i) r.parentNode.removeChild(r)
        }
      }
      const c = (t, e) => {
          const i = t.length - e.length
          return i >= 0 && t.slice(i) === e
        },
        h = (t) => -1 !== t.index,
        u = () => document.createComment(''),
        d =
          /([ \x09\x0a\x0c\x0d])([^\0-\x1F\x7F-\x9F "'>=/]+)([ \x09\x0a\x0c\x0d]*=[ \x09\x0a\x0c\x0d]*(?:[^ \x09\x0a\x0c\x0d"'`<>=]*|"[^"]*|'[^']*))$/
      function p(t, e) {
        const {
            element: { content: i },
            parts: n,
          } = t,
          s = document.createTreeWalker(i, 133, null, !1)
        let r = g(n),
          a = n[r],
          o = -1,
          l = 0
        const c = []
        let h = null
        for (; s.nextNode(); ) {
          o++
          const t = s.currentNode
          for (
            t.previousSibling === h && (h = null), e.has(t) && (c.push(t), null === h && (h = t)), null !== h && l++;
            void 0 !== a && a.index === o;

          )
            (a.index = null !== h ? -1 : a.index - l), (r = g(n, r)), (a = n[r])
        }
        c.forEach((t) => t.parentNode.removeChild(t))
      }
      const A = (t) => {
          let e = 11 === t.nodeType ? 0 : 1
          const i = document.createTreeWalker(t, 133, null, !1)
          for (; i.nextNode(); ) e++
          return e
        },
        g = (t, e = -1) => {
          for (let i = e + 1; i < t.length; i++) {
            const e = t[i]
            if (h(e)) return i
          }
          return -1
        },
        m = new WeakMap(),
        f = (t) => 'function' == typeof t && m.has(t),
        v = {},
        y = {}
      /**
       * @license
       * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
       * This code may only be used under the BSD style license found at
       * http://polymer.github.io/LICENSE.txt
       * The complete set of authors may be found at
       * http://polymer.github.io/AUTHORS.txt
       * The complete set of contributors may be found at
       * http://polymer.github.io/CONTRIBUTORS.txt
       * Code distributed by Google as part of the polymer project is also
       * subject to an additional IP rights grant found at
       * http://polymer.github.io/PATENTS.txt
       */
      /**
       * @license
       * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
       * This code may only be used under the BSD style license found at
       * http://polymer.github.io/LICENSE.txt
       * The complete set of authors may be found at
       * http://polymer.github.io/AUTHORS.txt
       * The complete set of contributors may be found at
       * http://polymer.github.io/CONTRIBUTORS.txt
       * Code distributed by Google as part of the polymer project is also
       * subject to an additional IP rights grant found at
       * http://polymer.github.io/PATENTS.txt
       */
      class x {
        constructor(t, e, i) {
          ;(this.__parts = []), (this.template = t), (this.processor = e), (this.options = i)
        }
        update(t) {
          let e = 0
          for (const i of this.__parts) void 0 !== i && i.setValue(t[e]), e++
          for (const i of this.__parts) void 0 !== i && i.commit()
        }
        _clone() {
          const t = n
              ? this.template.element.content.cloneNode(!0)
              : document.importNode(this.template.element.content, !0),
            e = [],
            i = this.template.parts,
            s = document.createTreeWalker(t, 133, null, !1)
          let r,
            a = 0,
            o = 0,
            l = s.nextNode()
          for (; a < i.length; )
            if (((r = i[a]), h(r))) {
              for (; o < r.index; )
                o++,
                  'TEMPLATE' === l.nodeName && (e.push(l), (s.currentNode = l.content)),
                  null === (l = s.nextNode()) && ((s.currentNode = e.pop()), (l = s.nextNode()))
              if ('node' === r.type) {
                const t = this.processor.handleTextExpression(this.options)
                t.insertAfterNode(l.previousSibling), this.__parts.push(t)
              } else this.__parts.push(...this.processor.handleAttributeExpressions(l, r.name, r.strings, this.options))
              a++
            } else this.__parts.push(void 0), a++
          return n && (document.adoptNode(t), customElements.upgrade(t)), t
          /**
           * @license
           * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
           * This code may only be used under the BSD style license found at
           * http://polymer.github.io/LICENSE.txt
           * The complete set of authors may be found at
           * http://polymer.github.io/AUTHORS.txt
           * The complete set of contributors may be found at
           * http://polymer.github.io/CONTRIBUTORS.txt
           * Code distributed by Google as part of the polymer project is also
           * subject to an additional IP rights grant found at
           * http://polymer.github.io/PATENTS.txt
           */
        }
      }
      const w = window.trustedTypes && trustedTypes.createPolicy('lit-html', { createHTML: (t) => t }),
        _ = ` ${r} `
      class I {
        constructor(t) {
          ;(this.value = void 0), (this.__pendingValue = void 0), (this.options = t)
        }
        appendInto(t) {
          ;(this.startNode = t.appendChild(u())), (this.endNode = t.appendChild(u()))
        }
        insertAfterNode(t) {
          ;(this.startNode = t), (this.endNode = t.nextSibling)
        }
        appendIntoPart(t) {
          t.__insert((this.startNode = u())), t.__insert((this.endNode = u()))
        }
        insertAfterPart(t) {
          t.__insert((this.startNode = u())), (this.endNode = t.endNode), (t.endNode = this.startNode)
        }
        setValue(t) {
          this.__pendingValue = t
        }
        commit() {
          if (null === this.startNode.parentNode) return
          for (; f(this.__pendingValue); ) {
            const t = this.__pendingValue
            ;(this.__pendingValue = v), t(this)
          }
          const t = this.__pendingValue
          t !== v &&
            (((t) => null === t || !('object' == typeof t || 'function' == typeof t))(t)
              ? t !== this.value && this.__commitText(t)
              : t instanceof
                class {
                  constructor(t, e, i, n) {
                    ;(this.strings = t), (this.values = e), (this.type = i), (this.processor = n)
                  }
                  getHTML() {
                    const t = this.strings.length - 1
                    let e = '',
                      i = !1
                    for (let n = 0; n < t; n++) {
                      const t = this.strings[n],
                        s = t.lastIndexOf('\x3c!--')
                      i = (s > -1 || i) && -1 === t.indexOf('--\x3e', s + 1)
                      const o = d.exec(t)
                      e += null === o ? t + (i ? _ : a) : t.substr(0, o.index) + o[1] + o[2] + '$lit$' + o[3] + r
                    }
                    return (e += this.strings[t]), e
                  }
                  getTemplateElement() {
                    const t = document.createElement('template')
                    let e = this.getHTML()
                    return void 0 !== w && (e = w.createHTML(e)), (t.innerHTML = e), t
                    /**
                     * @license
                     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
                     * This code may only be used under the BSD style license found at
                     * http://polymer.github.io/LICENSE.txt
                     * The complete set of authors may be found at
                     * http://polymer.github.io/AUTHORS.txt
                     * The complete set of contributors may be found at
                     * http://polymer.github.io/CONTRIBUTORS.txt
                     * Code distributed by Google as part of the polymer project is also
                     * subject to an additional IP rights grant found at
                     * http://polymer.github.io/PATENTS.txt
                     */
                  }
                }
              ? this.__commitTemplateResult(t)
              : t instanceof Node
              ? this.__commitNode(t)
              : ((t) => Array.isArray(t) || !(!t || !t[Symbol.iterator]))(t)
              ? this.__commitIterable(t)
              : t === y
              ? ((this.value = y), this.clear())
              : this.__commitText(t))
        }
        __insert(t) {
          this.endNode.parentNode.insertBefore(t, this.endNode)
        }
        __commitNode(t) {
          this.value !== t && (this.clear(), this.__insert(t), (this.value = t))
        }
        __commitText(t) {
          const e = this.startNode.nextSibling,
            i = 'string' == typeof (t = null == t ? '' : t) ? t : String(t)
          e === this.endNode.previousSibling && 3 === e.nodeType
            ? (e.data = i)
            : this.__commitNode(document.createTextNode(i)),
            (this.value = t)
        }
        __commitTemplateResult(t) {
          const e = this.options.templateFactory(t)
          if (this.value instanceof x && this.value.template === e) this.value.update(t.values)
          else {
            const i = new x(e, t.processor, this.options),
              n = i._clone()
            i.update(t.values), this.__commitNode(n), (this.value = i)
          }
        }
        __commitIterable(t) {
          Array.isArray(this.value) || ((this.value = []), this.clear())
          const e = this.value
          let i,
            n = 0
          for (const s of t)
            (i = e[n]),
              void 0 === i &&
                ((i = new I(this.options)), e.push(i), 0 === n ? i.appendIntoPart(this) : i.insertAfterPart(e[n - 1])),
              i.setValue(s),
              i.commit(),
              n++
          n < e.length && ((e.length = n), this.clear(i && i.endNode))
        }
        clear(t = this.startNode) {
          s(this.startNode.parentNode, t.nextSibling, this.endNode)
        }
      }
      let C = !1
      /**
       * @license
       * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
       * This code may only be used under the BSD style license found at
       * http://polymer.github.io/LICENSE.txt
       * The complete set of authors may be found at
       * http://polymer.github.io/AUTHORS.txt
       * The complete set of contributors may be found at
       * http://polymer.github.io/CONTRIBUTORS.txt
       * Code distributed by Google as part of the polymer project is also
       * subject to an additional IP rights grant found at
       * http://polymer.github.io/PATENTS.txt
       */ function M(t) {
        let e = E.get(t.type)
        void 0 === e && ((e = { stringsArray: new WeakMap(), keyString: new Map() }), E.set(t.type, e))
        let i = e.stringsArray.get(t.strings)
        if (void 0 !== i) return i
        const n = t.strings.join(r)
        return (
          (i = e.keyString.get(n)),
          void 0 === i && ((i = new l(t, t.getTemplateElement())), e.keyString.set(n, i)),
          e.stringsArray.set(t.strings, i),
          i
        )
      }
      ;(() => {
        try {
          const t = {
            get capture() {
              return (C = !0), !1
            },
          }
          window.addEventListener('test', t, t), window.removeEventListener('test', t, t)
        } catch (n) {}
      })()
      const E = new Map(),
        b = new WeakMap()
      /**
       * @license
       * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
       * This code may only be used under the BSD style license found at
       * http://polymer.github.io/LICENSE.txt
       * The complete set of authors may be found at
       * http://polymer.github.io/AUTHORS.txt
       * The complete set of contributors may be found at
       * http://polymer.github.io/CONTRIBUTORS.txt
       * Code distributed by Google as part of the polymer project is also
       * subject to an additional IP rights grant found at
       * http://polymer.github.io/PATENTS.txt
       */
      /**
       * @license
       * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
       * This code may only be used under the BSD style license found at
       * http://polymer.github.io/LICENSE.txt
       * The complete set of authors may be found at
       * http://polymer.github.io/AUTHORS.txt
       * The complete set of contributors may be found at
       * http://polymer.github.io/CONTRIBUTORS.txt
       * Code distributed by Google as part of the polymer project is also
       * subject to an additional IP rights grant found at
       * http://polymer.github.io/PATENTS.txt
       */ 'undefined' != typeof window && (window.litHtmlVersions || (window.litHtmlVersions = [])).push('1.4.1')
      /**
       * @license
       * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
       * This code may only be used under the BSD style license found at
       * http://polymer.github.io/LICENSE.txt
       * The complete set of authors may be found at
       * http://polymer.github.io/AUTHORS.txt
       * The complete set of contributors may be found at
       * http://polymer.github.io/CONTRIBUTORS.txt
       * Code distributed by Google as part of the polymer project is also
       * subject to an additional IP rights grant found at
       * http://polymer.github.io/PATENTS.txt
       */
      const S = (t, e) => `${t}--${e}`
      let B = !0
      ;(void 0 === window.ShadyCSS || void 0 === window.ShadyCSS.prepareTemplateDom) && (B = !1)
      const T = (t) => (e) => {
          const i = S(e.type, t)
          let n = E.get(i)
          void 0 === n && ((n = { stringsArray: new WeakMap(), keyString: new Map() }), E.set(i, n))
          let s = n.stringsArray.get(e.strings)
          if (void 0 !== s) return s
          const a = e.strings.join(r)
          if (((s = n.keyString.get(a)), void 0 === s)) {
            const i = e.getTemplateElement()
            B && window.ShadyCSS.prepareTemplateDom(i, t), (s = new l(e, i)), n.keyString.set(a, s)
          }
          return n.stringsArray.set(e.strings, s), s
        },
        L = ['html', 'svg'],
        D = new Set()
      window.JSCompiler_renameProperty = (t, e) => t
      const Q = {
          toAttribute(t, e) {
            switch (e) {
              case Boolean:
                return t ? '' : null
              case Object:
              case Array:
                return null == t ? t : JSON.stringify(t)
            }
            return t
          },
          fromAttribute(t, e) {
            switch (e) {
              case Boolean:
                return null !== t
              case Number:
                return null === t ? null : Number(t)
              case Object:
              case Array:
                return JSON.parse(t)
            }
            return t
          },
        },
        R = (t, e) => e !== t && (e == e || t == t),
        P = { attribute: !0, type: String, converter: Q, reflect: !1, hasChanged: R }
      class N extends HTMLElement {
        constructor() {
          super(), this.initialize()
        }
        static get observedAttributes() {
          this.finalize()
          const t = []
          return (
            this._classProperties.forEach((e, i) => {
              const n = this._attributeNameForProperty(i, e)
              void 0 !== n && (this._attributeToPropertyMap.set(n, i), t.push(n))
            }),
            t
          )
        }
        static _ensureClassProperties() {
          if (!this.hasOwnProperty(JSCompiler_renameProperty('_classProperties', this))) {
            this._classProperties = new Map()
            const t = Object.getPrototypeOf(this)._classProperties
            void 0 !== t && t.forEach((t, e) => this._classProperties.set(e, t))
          }
        }
        static createProperty(t, e = P) {
          if (
            (this._ensureClassProperties(),
            this._classProperties.set(t, e),
            e.noAccessor || this.prototype.hasOwnProperty(t))
          )
            return
          const i = 'symbol' == typeof t ? Symbol() : `__${t}`,
            n = this.getPropertyDescriptor(t, i, e)
          void 0 !== n && Object.defineProperty(this.prototype, t, n)
        }
        static getPropertyDescriptor(t, e, i) {
          return {
            get() {
              return this[e]
            },
            set(n) {
              const s = this[t]
              ;(this[e] = n), this.requestUpdateInternal(t, s, i)
            },
            configurable: !0,
            enumerable: !0,
          }
        }
        static getPropertyOptions(t) {
          return (this._classProperties && this._classProperties.get(t)) || P
        }
        static finalize() {
          const t = Object.getPrototypeOf(this)
          if (
            (t.hasOwnProperty('finalized') || t.finalize(),
            (this.finalized = !0),
            this._ensureClassProperties(),
            (this._attributeToPropertyMap = new Map()),
            this.hasOwnProperty(JSCompiler_renameProperty('properties', this)))
          ) {
            const t = this.properties,
              e = [
                ...Object.getOwnPropertyNames(t),
                ...('function' == typeof Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(t) : []),
              ]
            for (const i of e) this.createProperty(i, t[i])
          }
        }
        static _attributeNameForProperty(t, e) {
          const i = e.attribute
          return !1 === i ? void 0 : 'string' == typeof i ? i : 'string' == typeof t ? t.toLowerCase() : void 0
        }
        static _valueHasChanged(t, e, i = R) {
          return i(t, e)
        }
        static _propertyValueFromAttribute(t, e) {
          const i = e.type,
            n = e.converter || Q,
            s = 'function' == typeof n ? n : n.fromAttribute
          return s ? s(t, i) : t
        }
        static _propertyValueToAttribute(t, e) {
          if (void 0 === e.reflect) return
          const i = e.type,
            n = e.converter
          return ((n && n.toAttribute) || Q.toAttribute)(t, i)
        }
        initialize() {
          ;(this._updateState = 0),
            (this._updatePromise = new Promise((t) => (this._enableUpdatingResolver = t))),
            (this._changedProperties = new Map()),
            this._saveInstanceProperties(),
            this.requestUpdateInternal()
        }
        _saveInstanceProperties() {
          this.constructor._classProperties.forEach((t, e) => {
            if (this.hasOwnProperty(e)) {
              const t = this[e]
              delete this[e],
                this._instanceProperties || (this._instanceProperties = new Map()),
                this._instanceProperties.set(e, t)
            }
          })
        }
        _applyInstanceProperties() {
          this._instanceProperties.forEach((t, e) => (this[e] = t)), (this._instanceProperties = void 0)
        }
        connectedCallback() {
          this.enableUpdating()
        }
        enableUpdating() {
          void 0 !== this._enableUpdatingResolver &&
            (this._enableUpdatingResolver(), (this._enableUpdatingResolver = void 0))
        }
        disconnectedCallback() {}
        attributeChangedCallback(t, e, i) {
          e !== i && this._attributeToProperty(t, i)
        }
        _propertyToAttribute(t, e, i = P) {
          const n = this.constructor,
            s = n._attributeNameForProperty(t, i)
          if (void 0 !== s) {
            const t = n._propertyValueToAttribute(e, i)
            if (void 0 === t) return
            ;(this._updateState = 8 | this._updateState),
              null == t ? this.removeAttribute(s) : this.setAttribute(s, t),
              (this._updateState = -9 & this._updateState)
          }
        }
        _attributeToProperty(t, e) {
          if (8 & this._updateState) return
          const i = this.constructor,
            n = i._attributeToPropertyMap.get(t)
          if (void 0 !== n) {
            const t = i.getPropertyOptions(n)
            ;(this._updateState = 16 | this._updateState),
              (this[n] = i._propertyValueFromAttribute(e, t)),
              (this._updateState = -17 & this._updateState)
          }
        }
        requestUpdateInternal(t, e, i) {
          let n = !0
          if (void 0 !== t) {
            const s = this.constructor
            ;(i = i || s.getPropertyOptions(t)),
              s._valueHasChanged(this[t], e, i.hasChanged)
                ? (this._changedProperties.has(t) || this._changedProperties.set(t, e),
                  !0 !== i.reflect ||
                    16 & this._updateState ||
                    (void 0 === this._reflectingProperties && (this._reflectingProperties = new Map()),
                    this._reflectingProperties.set(t, i)))
                : (n = !1)
          }
          !this._hasRequestedUpdate && n && (this._updatePromise = this._enqueueUpdate())
        }
        requestUpdate(t, e) {
          return this.requestUpdateInternal(t, e), this.updateComplete
        }
        async _enqueueUpdate() {
          this._updateState = 4 | this._updateState
          try {
            await this._updatePromise
          } catch (t) {}
          const t = this.performUpdate()
          return null != t && (await t), !this._hasRequestedUpdate
        }
        get _hasRequestedUpdate() {
          return 4 & this._updateState
        }
        get hasUpdated() {
          return 1 & this._updateState
        }
        performUpdate() {
          if (!this._hasRequestedUpdate) return
          this._instanceProperties && this._applyInstanceProperties()
          let t = !1
          const e = this._changedProperties
          try {
            ;(t = this.shouldUpdate(e)), t ? this.update(e) : this._markUpdated()
          } catch (e) {
            throw ((t = !1), this._markUpdated(), e)
          }
          t &&
            (1 & this._updateState || ((this._updateState = 1 | this._updateState), this.firstUpdated(e)),
            this.updated(e))
        }
        _markUpdated() {
          ;(this._changedProperties = new Map()), (this._updateState = -5 & this._updateState)
        }
        get updateComplete() {
          return this._getUpdateComplete()
        }
        _getUpdateComplete() {
          return this.getUpdateComplete()
        }
        getUpdateComplete() {
          return this._updatePromise
        }
        shouldUpdate(t) {
          return !0
        }
        update(t) {
          void 0 !== this._reflectingProperties &&
            this._reflectingProperties.size > 0 &&
            (this._reflectingProperties.forEach((t, e) => this._propertyToAttribute(e, this[e], t)),
            (this._reflectingProperties = void 0)),
            this._markUpdated()
        }
        updated(t) {}
        firstUpdated(t) {}
      }
      N.finalized = !0
      /**
       * @license
       * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
       * This code may only be used under the BSD style license found at
       * http://polymer.github.io/LICENSE.txt
       * The complete set of authors may be found at
       * http://polymer.github.io/AUTHORS.txt
       * The complete set of contributors may be found at
       * http://polymer.github.io/CONTRIBUTORS.txt
       * Code distributed by Google as part of the polymer project is also
       * subject to an additional IP rights grant found at
       * http://polymer.github.io/PATENTS.txt
       */
      const F = (t, e) =>
        'method' === e.kind && e.descriptor && !('value' in e.descriptor)
          ? Object.assign(Object.assign({}, e), {
              finisher(i) {
                i.createProperty(e.key, t)
              },
            })
          : {
              kind: 'field',
              key: Symbol(),
              placement: 'own',
              descriptor: {},
              initializer() {
                'function' == typeof e.initializer && (this[e.key] = e.initializer.call(this))
              },
              finisher(i) {
                i.createProperty(e.key, t)
              },
            }
      function U(t) {
        return (e, i) =>
          void 0 !== i
            ? ((t, e, i) => {
                e.constructor.createProperty(i, t)
              })(t, e, i)
            : F(t, e)
        /**
@license
Copyright (c) 2019 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/
      }
      const k =
          window.ShadowRoot &&
          (void 0 === window.ShadyCSS || window.ShadyCSS.nativeShadow) &&
          'adoptedStyleSheets' in Document.prototype &&
          'replace' in CSSStyleSheet.prototype,
        O = Symbol()
      class G {
        constructor(t, e) {
          if (e !== O) throw new Error('CSSResult is not constructable. Use `unsafeCSS` or `css` instead.')
          this.cssText = t
        }
        get styleSheet() {
          return (
            void 0 === this._styleSheet &&
              (k
                ? ((this._styleSheet = new CSSStyleSheet()), this._styleSheet.replaceSync(this.cssText))
                : (this._styleSheet = null)),
            this._styleSheet
          )
        }
        toString() {
          return this.cssText
        }
      }
      /**
       * @license
       * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
       * This code may only be used under the BSD style license found at
       * http://polymer.github.io/LICENSE.txt
       * The complete set of authors may be found at
       * http://polymer.github.io/AUTHORS.txt
       * The complete set of contributors may be found at
       * http://polymer.github.io/CONTRIBUTORS.txt
       * Code distributed by Google as part of the polymer project is also
       * subject to an additional IP rights grant found at
       * http://polymer.github.io/PATENTS.txt
       */ ;(window.litElementVersions || (window.litElementVersions = [])).push('2.5.1')
      const z = {}
      class V extends N {
        static getStyles() {
          return this.styles
        }
        static _getUniqueStyles() {
          if (this.hasOwnProperty(JSCompiler_renameProperty('_styles', this))) return
          const t = this.getStyles()
          if (Array.isArray(t)) {
            const e = (t, i) => t.reduceRight((t, i) => (Array.isArray(i) ? e(i, t) : (t.add(i), t)), i),
              i = e(t, new Set()),
              n = []
            i.forEach((t) => n.unshift(t)), (this._styles = n)
          } else this._styles = void 0 === t ? [] : [t]
          this._styles = this._styles.map((t) => {
            if (t instanceof CSSStyleSheet && !k) {
              const e = Array.prototype.slice.call(t.cssRules).reduce((t, e) => t + e.cssText, '')
              return new G(String(e), O)
            }
            return t
          })
        }
        initialize() {
          super.initialize(),
            this.constructor._getUniqueStyles(),
            (this.renderRoot = this.createRenderRoot()),
            window.ShadowRoot && this.renderRoot instanceof window.ShadowRoot && this.adoptStyles()
        }
        createRenderRoot() {
          return this.attachShadow(this.constructor.shadowRootOptions)
        }
        adoptStyles() {
          const t = this.constructor._styles
          0 !== t.length &&
            (void 0 === window.ShadyCSS || window.ShadyCSS.nativeShadow
              ? k
                ? (this.renderRoot.adoptedStyleSheets = t.map((t) => (t instanceof CSSStyleSheet ? t : t.styleSheet)))
                : (this._needsShimAdoptedStyleSheets = !0)
              : window.ShadyCSS.ScopingShim.prepareAdoptedCssText(
                  t.map((t) => t.cssText),
                  this.localName,
                ))
        }
        connectedCallback() {
          super.connectedCallback(), this.hasUpdated && void 0 !== window.ShadyCSS && window.ShadyCSS.styleElement(this)
        }
        update(t) {
          const e = this.render()
          super.update(t),
            e !== z && this.constructor.render(e, this.renderRoot, { scopeName: this.localName, eventContext: this }),
            this._needsShimAdoptedStyleSheets &&
              ((this._needsShimAdoptedStyleSheets = !1),
              this.constructor._styles.forEach((t) => {
                const e = document.createElement('style')
                ;(e.textContent = t.cssText), this.renderRoot.appendChild(e)
              }))
        }
        render() {
          return z
        }
      }
      ;(V.finalized = !0),
        (V.render = (t, e, i) => {
          if (!i || 'object' != typeof i || !i.scopeName) throw new Error('The `scopeName` option is required.')
          const n = i.scopeName,
            r = b.has(e),
            a = B && 11 === e.nodeType && !!e.host,
            o = a && !D.has(n),
            l = o ? document.createDocumentFragment() : e
          if (
            (((t, e, i) => {
              let n = b.get(e)
              void 0 === n &&
                (s(e, e.firstChild), b.set(e, (n = new I(Object.assign({ templateFactory: M }, i)))), n.appendInto(e)),
                n.setValue(t),
                n.commit()
            })(t, l, Object.assign({ templateFactory: T(n) }, i)),
            o)
          ) {
            const t = b.get(l)
            b.delete(l)
            ;((t, e, i) => {
              D.add(t)
              const n = i ? i.element : document.createElement('template'),
                s = e.querySelectorAll('style'),
                { length: r } = s
              if (0 === r) return void window.ShadyCSS.prepareTemplateStyles(n, t)
              const a = document.createElement('style')
              for (let c = 0; c < r; c++) {
                const t = s[c]
                t.parentNode.removeChild(t), (a.textContent += t.textContent)
              }
              ;((t) => {
                L.forEach((e) => {
                  const i = E.get(S(e, t))
                  void 0 !== i &&
                    i.keyString.forEach((t) => {
                      const {
                          element: { content: e },
                        } = t,
                        i = new Set()
                      Array.from(e.querySelectorAll('style')).forEach((t) => {
                        i.add(t)
                      }),
                        p(t, i)
                    })
                })
              })(t)
              const o = n.content
              i
                ? (function (t, e, i = null) {
                    const {
                      element: { content: n },
                      parts: s,
                    } = t
                    if (null == i) return void n.appendChild(e)
                    const r = document.createTreeWalker(n, 133, null, !1)
                    let a = g(s),
                      o = 0,
                      l = -1
                    for (; r.nextNode(); )
                      for (
                        l++, r.currentNode === i && ((o = A(e)), i.parentNode.insertBefore(e, i));
                        -1 !== a && s[a].index === l;

                      ) {
                        if (o > 0) {
                          for (; -1 !== a; ) (s[a].index += o), (a = g(s, a))
                          return
                        }
                        a = g(s, a)
                      }
                  })(i, a, o.firstChild)
                : o.insertBefore(a, o.firstChild),
                window.ShadyCSS.prepareTemplateStyles(n, t)
              const l = o.querySelector('style')
              if (window.ShadyCSS.nativeShadow && null !== l) e.insertBefore(l.cloneNode(!0), e.firstChild)
              else if (i) {
                o.insertBefore(a, o.firstChild)
                const t = new Set()
                t.add(a), p(i, t)
              }
            })(n, l, t.value instanceof x ? t.value.template : void 0),
              s(e, e.firstChild),
              e.appendChild(l),
              b.set(e, t)
          }
          !r && a && window.ShadyCSS.styleElement(e.host)
        }),
        (V.shadowRootOptions = { mode: 'open' })
      /* @license
       * Copyright 2019 Google LLC. All Rights Reserved.
       * Licensed under the Apache License, Version 2.0 (the 'License');
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *     http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an 'AS IS' BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */
      const H = null != navigator.xr && null != self.XRSession && null != navigator.xr.isSessionSupported,
        W = H && self.XRSession.prototype.requestHitTestSource,
        q = null != self.ResizeObserver,
        j = null != self.IntersectionObserver,
        Y = W
      ;(() => {
        const t = navigator.userAgent || navigator.vendor || self.opera
        let e = !1
        ;/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(
          t,
        ) ||
          /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(
            t.substr(0, 4),
          )
      })(),
        /\bCrOS\b/.test(navigator.userAgent)
      const J = /android/i.test(navigator.userAgent),
        X =
          (/iPad|iPhone|iPod/.test(navigator.userAgent) && !self.MSStream) ||
          ('MacIntel' === navigator.platform && navigator.maxTouchPoints > 1),
        K = (() => {
          const t = document.createElement('a')
          return Boolean(t.relList && t.relList.supports && t.relList.supports('ar'))
        })()
      ;/Safari\//.test(navigator.userAgent)
      const Z = /firefox/i.test(navigator.userAgent),
        $ = /OculusBrowser/.test(navigator.userAgent)
      X && /CriOS\//.test(navigator.userAgent)
      const tt = J && !Z && !$,
        et = document.createElement('template')
      /* @license
       * Copyright 2019 Google LLC. All Rights Reserved.
       * Licensed under the Apache License, Version 2.0 (the 'License');
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *     http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an 'AS IS' BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */
      /* @license
       * Copyright 2019 Google LLC. All Rights Reserved.
       * Licensed under the Apache License, Version 2.0 (the 'License');
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *     http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an 'AS IS' BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ et.innerHTML =
        '\n<style>\n:host {\n  display: block;\n  position: relative;\n  contain: strict;\n  width: 300px;\n  height: 150px;\n}\n\n/* NOTE: This ruleset is our integration surface area with the\n * :focus-visible polyfill.\n *\n * @see https://github.com/WICG/focus-visible/pull/196 */\n:host([data-js-focus-visible]:focus:not(.focus-visible)),\n:host([data-js-focus-visible]) :focus:not(.focus-visible) {\n  outline: none;\n}\n\n.container {\n  position: relative;\n}\n\n.userInput {\n  width: 100%;\n  height: 100%;\n  display: block;\n  position: relative;\n  overflow: hidden;\n}\n\ncanvas {\n  position: absolute;\n  display: none;\n  pointer-events: none;\n  /* NOTE(cdata): Chrome 76 and below apparently have a bug\n   * that causes our canvas not to display pixels unless it is\n   * on its own render layer\n   * @see https://github.com/google/model-viewer/pull/755#issuecomment-536597893\n   */\n  transform: translateZ(0);\n}\n\ncanvas.show {\n  display: block;\n}\n\n/* Adapted from HTML5 Boilerplate\n *\n * @see https://github.com/h5bp/html5-boilerplate/blob/ceb4620c78fc82e13534fc44202a3f168754873f/dist/css/main.css#L122-L133 */\n.screen-reader-only {\n  border: 0;\n  clip: rect(0, 0, 0, 0);\n  height: 1px;\n  margin: -1px;\n  overflow: hidden;\n  padding: 0;\n  position: absolute;\n  white-space: nowrap;\n  width: 1px;\n}\n\n.slot {\n  position: absolute;\n  pointer-events: none;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n}\n\n.slot > * {\n  pointer-events: initial;\n}\n\n.annotation-wrapper ::slotted(*) {\n  opacity: var(--max-hotspot-opacity, 1);\n  transition: opacity 0.3s;\n}\n\n.pointer-tumbling .annotation-wrapper ::slotted(*) {\n  pointer-events: none;\n}\n\n.annotation-wrapper ::slotted(*) {\n  pointer-events: initial;\n}\n\n.annotation-wrapper.hide ::slotted(*) {\n  opacity: var(--min-hotspot-opacity, 0.25);\n}\n\n.slot.poster {\n  opacity: 0;\n  transition: opacity 0.3s 0.3s;\n  background-color: inherit;\n}\n\n.slot.poster.show {\n  opacity: 1;\n  transition: none;\n}\n\n.slot.poster > * {\n  pointer-events: initial;\n}\n\n.slot.poster:not(.show) > * {\n  pointer-events: none;\n}\n\n#default-poster {\n  width: 100%;\n  height: 100%;\n  /* The default poster is a <button> so we need to set display\n   * to prevent it from being affected by text-align: */\n  display: block;\n  position: absolute;\n  border: none;\n  padding: 0;\n  background-size: contain;\n  background-repeat: no-repeat;\n  background-position: center;\n  background-color: var(--poster-color, #fff);\n  background-image: var(--poster-image, none);\n}\n\n#default-progress-bar {\n  display: block;\n  position: relative;\n  width: 100%;\n  height: 100%;\n  pointer-events: none;\n  overflow: hidden;\n}\n\n#default-progress-bar > .mask {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  background: var(--progress-mask, #fff);\n  transition: opacity 0.3s;\n  opacity: 0.2;\n}\n\n#default-progress-bar > .bar {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: var(--progress-bar-height, 5px);\n  background-color: var(--progress-bar-color, rgba(0, 0, 0, 0.4));\n  transition: transform 0.09s;\n  transform-origin: top left;\n  transform: scaleX(0);\n  overflow: hidden;\n}\n\n#default-progress-bar > .bar.hide {\n  transition: opacity 0.3s 1s;\n  opacity: 0;\n}\n\n.slot.interaction-prompt {\n  display: var(--interaction-prompt-display, flex);\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  pointer-events: none;\n  align-items: center;\n  justify-content: center;\n\n  opacity: 0;\n  will-change: opacity;\n  overflow: hidden;\n  transition: opacity 0.3s;\n}\n\n.slot.interaction-prompt.visible {\n  opacity: 1;\n}\n\n.slot.interaction-prompt > .animated-container {\n  will-change: transform, opacity;\n}\n\n.slot.interaction-prompt > * {\n  pointer-events: none;\n}\n\n.slot.ar-button {\n  -moz-user-select: none;\n  -webkit-tap-highlight-color: transparent;\n  user-select: none;\n\n  display: var(--ar-button-display, block);\n}\n\n.slot.ar-button:not(.enabled) {\n  display: none;\n}\n\n.fab {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  box-sizing: border-box;\n  width: 40px;\n  height: 40px;\n  cursor: pointer;\n  background-color: #fff;\n  box-shadow: 0px 0px 4px rgba(0, 0, 0, 0.15);\n  border-radius: 100px;\n}\n\n.fab > * {\n  opacity: 0.87;\n}\n\n#default-ar-button {\n  position: absolute;\n  bottom: 16px;\n  right: 16px;\n  transform: scale(var(--ar-button-scale, 1));\n  transform-origin: bottom right;\n}\n\n.slot.default {\n  pointer-events: none;\n}\n\n.slot.progress-bar {\n  pointer-events: none;\n}\n\n.slot.exit-webxr-ar-button {\n  pointer-events: none;\n}\n\n.slot.exit-webxr-ar-button:not(.enabled) {\n  display: none;\n}\n\n#default-exit-webxr-ar-button {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  position: absolute;\n  top: 16px;\n  right: 16px;\n  width: 40px;\n  height: 40px;\n  box-sizing: border-box;\n}\n\n#default-exit-webxr-ar-button > svg {\n  fill: #fff;\n}\n</style>\n<div class="container">\n  <div class="userInput" tabindex="0" role="img"\n      aria-label="A depiction of a 3D model"\n      aria-live="polite">\n      <div class="slot canvas">\n        <slot name="canvas">\n          <canvas></canvas>\n        </slot>\n      </div>\n  </div>\n\n  \x3c!-- NOTE(cdata): We need to wrap slots because browsers without ShadowDOM\n        will have their <slot> elements removed by ShadyCSS --\x3e\n  <div class="slot poster">\n    <slot name="poster">\n      <button type="button" id="default-poster" aria-hidden="true" aria-label="Activate to view in 3D!"></button>\n    </slot>\n  </div>\n\n  <div class="slot ar-button">\n    <slot name="ar-button">\n      <a id="default-ar-button" part="default-ar-button" class="fab"\n          tabindex="2"\n          aria-label="View this 3D model up close">\n        \n<svg version="1.1" id="view_x5F_in_x5F_AR_x5F_icon"\n\t xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="24px" height="24px"\n\t viewBox="0 0 24 24" enable-background="new 0 0 24 24" xml:space="preserve">\n<rect id="Bounding_Box" x="0" y="0" fill="none" width="24" height="24"/>\n<g id="Art_layer">\n\t<path d="M3,4c0-0.55,0.45-1,1-1h2V1H4C2.35,1,1,2.35,1,4v2h2V4z"/>\n\t<path d="M20,3c0.55,0,1,0.45,1,1v2h2V4c0-1.65-1.35-3-3-3h-2v2H20z"/>\n\t<path d="M4,21c-0.55,0-1-0.45-1-1v-2H1v2c0,1.65,1.35,3,3,3h2v-2H4z"/>\n\t<path d="M20,21c0.55,0,1-0.45,1-1v-2h2v2c0,1.65-1.35,3-3,3h-2v-2H20z"/>\n\t<g>\n\t\t<path d="M18.25,7.6l-5.5-3.18c-0.46-0.27-1.04-0.27-1.5,0L5.75,7.6C5.29,7.87,5,8.36,5,8.9v6.35c0,0.54,0.29,1.03,0.75,1.3\n\t\t\tl5.5,3.18c0.46,0.27,1.04,0.27,1.5,0l5.5-3.18c0.46-0.27,0.75-0.76,0.75-1.3V8.9C19,8.36,18.71,7.87,18.25,7.6z M7,14.96v-4.62\n\t\t\tl4,2.32v4.61L7,14.96z M12,10.93L8,8.61l4-2.31l4,2.31L12,10.93z M13,17.27v-4.61l4-2.32v4.62L13,17.27z"/>\n\t</g>\n</g>\n</svg>\n      </a>\n    </slot>\n  </div>\n\n  <div class="slot interaction-prompt">\n    <div class="animated-container">\n      <slot name="interaction-prompt" aria-hidden="true">\n        \n<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="25" height="36">\n    <defs>\n        <path id="A" d="M.001.232h24.997V36H.001z" />\n    </defs>\n    <g transform="translate(-11 -4)" fill="none" fill-rule="evenodd">\n        <path fill-opacity="0" fill="#fff" d="M0 0h44v44H0z" />\n        <g transform="translate(11 3)">\n            <path d="M8.733 11.165c.04-1.108.766-2.027 1.743-2.307a2.54 2.54 0 0 1 .628-.089c.16 0 .314.017.463.044 1.088.2 1.9 1.092 1.9 2.16v8.88h1.26c2.943-1.39 5-4.45 5-8.025a9.01 9.01 0 0 0-1.9-5.56l-.43-.5c-.765-.838-1.683-1.522-2.712-2-1.057-.49-2.226-.77-3.46-.77s-2.4.278-3.46.77c-1.03.478-1.947 1.162-2.71 2l-.43.5a9.01 9.01 0 0 0-1.9 5.56 9.04 9.04 0 0 0 .094 1.305c.03.21.088.41.13.617l.136.624c.083.286.196.56.305.832l.124.333a8.78 8.78 0 0 0 .509.953l.065.122a8.69 8.69 0 0 0 3.521 3.191l1.11.537v-9.178z" fill-opacity=".5" fill="#e4e4e4" />\n            <path d="M22.94 26.218l-2.76 7.74c-.172.485-.676.8-1.253.8H12.24c-1.606 0-3.092-.68-3.98-1.82-1.592-2.048-3.647-3.822-6.11-5.27-.095-.055-.15-.137-.152-.23-.004-.1.046-.196.193-.297.56-.393 1.234-.6 1.926-.6a3.43 3.43 0 0 1 .691.069l4.922.994V10.972c0-.663.615-1.203 1.37-1.203s1.373.54 1.373 1.203v9.882h2.953c.273 0 .533.073.757.21l6.257 3.874c.027.017.045.042.07.06.41.296.586.77.426 1.22M4.1 16.614c-.024-.04-.042-.083-.065-.122a8.69 8.69 0 0 1-.509-.953c-.048-.107-.08-.223-.124-.333l-.305-.832c-.058-.202-.09-.416-.136-.624l-.13-.617a9.03 9.03 0 0 1-.094-1.305c0-2.107.714-4.04 1.9-5.56l.43-.5c.764-.84 1.682-1.523 2.71-2 1.058-.49 2.226-.77 3.46-.77s2.402.28 3.46.77c1.03.477 1.947 1.16 2.712 2l.428.5a9 9 0 0 1 1.901 5.559c0 3.577-2.056 6.636-5 8.026h-1.26v-8.882c0-1.067-.822-1.96-1.9-2.16-.15-.028-.304-.044-.463-.044-.22 0-.427.037-.628.09-.977.28-1.703 1.198-1.743 2.306v9.178l-1.11-.537C6.18 19.098 4.96 18 4.1 16.614M22.97 24.09l-6.256-3.874c-.102-.063-.218-.098-.33-.144 2.683-1.8 4.354-4.855 4.354-8.243 0-.486-.037-.964-.104-1.43a9.97 9.97 0 0 0-1.57-4.128l-.295-.408-.066-.092a10.05 10.05 0 0 0-.949-1.078c-.342-.334-.708-.643-1.094-.922-1.155-.834-2.492-1.412-3.94-1.65l-.732-.088-.748-.03a9.29 9.29 0 0 0-1.482.119c-1.447.238-2.786.816-3.94 1.65a9.33 9.33 0 0 0-.813.686 9.59 9.59 0 0 0-.845.877l-.385.437-.36.5-.288.468-.418.778-.04.09c-.593 1.28-.93 2.71-.93 4.222 0 3.832 2.182 7.342 5.56 8.938l1.437.68v4.946L5 25.64a4.44 4.44 0 0 0-.888-.086c-.017 0-.034.003-.05.003-.252.004-.503.033-.75.08a5.08 5.08 0 0 0-.237.056c-.193.046-.382.107-.568.18-.075.03-.15.057-.225.1-.25.114-.494.244-.723.405a1.31 1.31 0 0 0-.566 1.122 1.28 1.28 0 0 0 .645 1.051C4 29.925 5.96 31.614 7.473 33.563a5.06 5.06 0 0 0 .434.491c1.086 1.082 2.656 1.713 4.326 1.715h6.697c.748-.001 1.43-.333 1.858-.872.142-.18.256-.38.336-.602l2.757-7.74c.094-.26.13-.53.112-.794s-.088-.52-.203-.76a2.19 2.19 0 0 0-.821-.91" fill-opacity=".6" fill="#000" />\n            <path d="M22.444 24.94l-6.257-3.874a1.45 1.45 0 0 0-.757-.211h-2.953v-9.88c0-.663-.616-1.203-1.373-1.203s-1.37.54-1.37 1.203v16.643l-4.922-.994a3.44 3.44 0 0 0-.692-.069 3.35 3.35 0 0 0-1.925.598c-.147.102-.198.198-.194.298.004.094.058.176.153.23 2.462 1.448 4.517 3.22 6.11 5.27.887 1.14 2.373 1.82 3.98 1.82h6.686c.577 0 1.08-.326 1.253-.8l2.76-7.74c.16-.448-.017-.923-.426-1.22-.025-.02-.043-.043-.07-.06z" fill="#fff" />\n            <g transform="translate(0 .769)">\n                <mask id="B" fill="#fff">\n                    <use xlink:href="#A" />\n                </mask>\n                <path d="M23.993 24.992a1.96 1.96 0 0 1-.111.794l-2.758 7.74c-.08.22-.194.423-.336.602-.427.54-1.11.87-1.857.872h-6.698c-1.67-.002-3.24-.633-4.326-1.715-.154-.154-.3-.318-.434-.49C5.96 30.846 4 29.157 1.646 27.773c-.385-.225-.626-.618-.645-1.05a1.31 1.31 0 0 1 .566-1.122 4.56 4.56 0 0 1 .723-.405l.225-.1a4.3 4.3 0 0 1 .568-.18l.237-.056c.248-.046.5-.075.75-.08.018 0 .034-.003.05-.003.303-.001.597.027.89.086l3.722.752V20.68l-1.436-.68c-3.377-1.596-5.56-5.106-5.56-8.938 0-1.51.336-2.94.93-4.222.015-.03.025-.06.04-.09.127-.267.268-.525.418-.778.093-.16.186-.316.288-.468.063-.095.133-.186.2-.277L3.773 5c.118-.155.26-.29.385-.437.266-.3.544-.604.845-.877a9.33 9.33 0 0 1 .813-.686C6.97 2.167 8.31 1.59 9.757 1.35a9.27 9.27 0 0 1 1.481-.119 8.82 8.82 0 0 1 .748.031c.247.02.49.05.733.088 1.448.238 2.786.816 3.94 1.65.387.28.752.588 1.094.922a9.94 9.94 0 0 1 .949 1.078l.066.092c.102.133.203.268.295.408a9.97 9.97 0 0 1 1.571 4.128c.066.467.103.945.103 1.43 0 3.388-1.67 6.453-4.353 8.243.11.046.227.08.33.144l6.256 3.874c.37.23.645.55.82.9.115.24.185.498.203.76m.697-1.195c-.265-.55-.677-1.007-1.194-1.326l-5.323-3.297c2.255-2.037 3.564-4.97 3.564-8.114 0-2.19-.637-4.304-1.84-6.114-.126-.188-.26-.37-.4-.552-.645-.848-1.402-1.6-2.252-2.204C15.472.91 13.393.232 11.238.232A10.21 10.21 0 0 0 5.23 2.19c-.848.614-1.606 1.356-2.253 2.205-.136.18-.272.363-.398.55C1.374 6.756.737 8.87.737 11.06c0 4.218 2.407 8.08 6.133 9.842l.863.41v3.092l-2.525-.51c-.356-.07-.717-.106-1.076-.106a5.45 5.45 0 0 0-3.14.996c-.653.46-1.022 1.202-.99 1.983a2.28 2.28 0 0 0 1.138 1.872c2.24 1.318 4.106 2.923 5.543 4.772 1.26 1.62 3.333 2.59 5.55 2.592h6.698c1.42-.001 2.68-.86 3.134-2.138l2.76-7.74c.272-.757.224-1.584-.134-2.325" fill-opacity=".05" fill="#000" mask="url(#B)" />\n            </g>\n        </g>\n    </g>\n</svg>\n      </slot>\n    </div>\n  </div>\n\n  <div class="slot default">\n    <slot></slot>\n\n    <div class="slot progress-bar">\n      <slot name="progress-bar">\n        <div id="default-progress-bar" aria-hidden="true">\n          <div class="mask" part="default-progress-mask"></div>\n          <div class="bar" part="default-progress-bar"></div>\n        </div>\n      </slot>\n    </div>\n    \n    <div class="slot exit-webxr-ar-button">\n      <slot name="exit-webxr-ar-button">\n        <a id="default-exit-webxr-ar-button" part="default-exit-webxr-ar-button"\n            tabindex="3"\n            aria-label="Exit AR"\n            aria-hidden="true">\n          \n<svg xmlns="http://www.w3.org/2000/svg" width="24px" height="24px" viewBox="0 0 24 24" fill="#000000">\n    \x3c!-- NOTE(cdata): This SVG filter is a stop-gap until we can implement\n         support for dynamic re-coloring of UI components --\x3e\n    <defs>\n      <filter id="drop-shadow" x="-100%" y="-100%" width="300%" height="300%">\n        <feGaussianBlur in="SourceAlpha" stdDeviation="1"/>\n        <feOffset dx="0" dy="0" result="offsetblur"/>\n        <feFlood flood-color="#000000"/>\n        <feComposite in2="offsetblur" operator="in"/>\n        <feMerge>\n          <feMergeNode/>\n          <feMergeNode in="SourceGraphic"/>\n        </feMerge>\n      </filter>\n    </defs>\n    <path filter="url(#drop-shadow)" d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>\n    <path d="M0 0h24v24H0z" fill="none"/>\n</svg>\n        </a>\n      </slot>\n    </div>\n  </div>\n</div>'
      class it {
        addEventListener(t, e) {
          void 0 === this._listeners && (this._listeners = {})
          const i = this._listeners
          void 0 === i[t] && (i[t] = []), -1 === i[t].indexOf(e) && i[t].push(e)
        }
        hasEventListener(t, e) {
          if (void 0 === this._listeners) return !1
          const i = this._listeners
          return void 0 !== i[t] && -1 !== i[t].indexOf(e)
        }
        removeEventListener(t, e) {
          if (void 0 === this._listeners) return
          const i = this._listeners[t]
          if (void 0 !== i) {
            const t = i.indexOf(e)
            ;-1 !== t && i.splice(t, 1)
          }
        }
        dispatchEvent(t) {
          if (void 0 === this._listeners) return
          const e = this._listeners[t.type]
          if (void 0 !== e) {
            t.target = this
            const i = e.slice(0)
            for (let e = 0, n = i.length; e < n; e++) i[e].call(this, t)
            t.target = null
          }
        }
      }
      const nt = []
      for (let fv = 0; fv < 256; fv++) nt[fv] = (fv < 16 ? '0' : '') + fv.toString(16)
      let st = 1234567
      const rt = Math.PI / 180,
        at = 180 / Math.PI
      function ot() {
        const t = (4294967295 * Math.random()) | 0,
          e = (4294967295 * Math.random()) | 0,
          i = (4294967295 * Math.random()) | 0,
          n = (4294967295 * Math.random()) | 0
        return (
          nt[255 & t] +
          nt[(t >> 8) & 255] +
          nt[(t >> 16) & 255] +
          nt[(t >> 24) & 255] +
          '-' +
          nt[255 & e] +
          nt[(e >> 8) & 255] +
          '-' +
          nt[((e >> 16) & 15) | 64] +
          nt[(e >> 24) & 255] +
          '-' +
          nt[(63 & i) | 128] +
          nt[(i >> 8) & 255] +
          '-' +
          nt[(i >> 16) & 255] +
          nt[(i >> 24) & 255] +
          nt[255 & n] +
          nt[(n >> 8) & 255] +
          nt[(n >> 16) & 255] +
          nt[(n >> 24) & 255]
        ).toUpperCase()
      }
      function lt(t, e, i) {
        return Math.max(e, Math.min(i, t))
      }
      function ct(t, e) {
        return ((t % e) + e) % e
      }
      function ht(t, e, i) {
        return (1 - i) * t + i * e
      }
      function ut(t) {
        return 0 == (t & (t - 1)) && 0 !== t
      }
      function dt(t) {
        return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2))
      }
      function pt(t) {
        return Math.pow(2, Math.floor(Math.log(t) / Math.LN2))
      }
      var At = Object.freeze({
        __proto__: null,
        DEG2RAD: rt,
        RAD2DEG: at,
        generateUUID: ot,
        clamp: lt,
        euclideanModulo: ct,
        mapLinear: function (t, e, i, n, s) {
          return n + ((t - e) * (s - n)) / (i - e)
        },
        inverseLerp: function (t, e, i) {
          return t !== e ? (i - t) / (e - t) : 0
        },
        lerp: ht,
        damp: function (t, e, i, n) {
          return ht(t, e, 1 - Math.exp(-i * n))
        },
        pingpong: function (t, e = 1) {
          return e - Math.abs(ct(t, 2 * e) - e)
        },
        smoothstep: function (t, e, i) {
          return t <= e ? 0 : t >= i ? 1 : (t = (t - e) / (i - e)) * t * (3 - 2 * t)
        },
        smootherstep: function (t, e, i) {
          return t <= e ? 0 : t >= i ? 1 : (t = (t - e) / (i - e)) * t * t * (t * (6 * t - 15) + 10)
        },
        randInt: function (t, e) {
          return t + Math.floor(Math.random() * (e - t + 1))
        },
        randFloat: function (t, e) {
          return t + Math.random() * (e - t)
        },
        randFloatSpread: function (t) {
          return t * (0.5 - Math.random())
        },
        seededRandom: function (t) {
          return void 0 !== t && (st = t % 2147483647), (st = (16807 * st) % 2147483647), (st - 1) / 2147483646
        },
        degToRad: function (t) {
          return t * rt
        },
        radToDeg: function (t) {
          return t * at
        },
        isPowerOfTwo: ut,
        ceilPowerOfTwo: dt,
        floorPowerOfTwo: pt,
        setQuaternionFromProperEuler: function (t, e, i, n, s) {
          const r = Math.cos,
            a = Math.sin,
            o = r(i / 2),
            l = a(i / 2),
            c = r((e + n) / 2),
            h = a((e + n) / 2),
            u = r((e - n) / 2),
            d = a((e - n) / 2),
            p = r((n - e) / 2),
            A = a((n - e) / 2)
          switch (s) {
            case 'XYX':
              t.set(o * h, l * u, l * d, o * c)
              break
            case 'YZY':
              t.set(l * d, o * h, l * u, o * c)
              break
            case 'ZXZ':
              t.set(l * u, l * d, o * h, o * c)
              break
            case 'XZX':
              t.set(o * h, l * A, l * p, o * c)
              break
            case 'YXY':
              t.set(l * p, o * h, l * A, o * c)
              break
            case 'ZYZ':
              t.set(l * A, l * p, o * h, o * c)
          }
        },
      })
      class gt {
        constructor(t = 0, e = 0) {
          ;(this.x = t), (this.y = e)
        }
        get width() {
          return this.x
        }
        set width(t) {
          this.x = t
        }
        get height() {
          return this.y
        }
        set height(t) {
          this.y = t
        }
        set(t, e) {
          return (this.x = t), (this.y = e), this
        }
        setScalar(t) {
          return (this.x = t), (this.y = t), this
        }
        setX(t) {
          return (this.x = t), this
        }
        setY(t) {
          return (this.y = t), this
        }
        setComponent(t, e) {
          switch (t) {
            case 0:
              this.x = e
              break
            case 1:
              this.y = e
              break
            default:
              throw new Error('index is out of range: ' + t)
          }
          return this
        }
        getComponent(t) {
          switch (t) {
            case 0:
              return this.x
            case 1:
              return this.y
            default:
              throw new Error('index is out of range: ' + t)
          }
        }
        clone() {
          return new this.constructor(this.x, this.y)
        }
        copy(t) {
          return (this.x = t.x), (this.y = t.y), this
        }
        add(t, e) {
          return void 0 !== e ? this.addVectors(t, e) : ((this.x += t.x), (this.y += t.y), this)
        }
        addScalar(t) {
          return (this.x += t), (this.y += t), this
        }
        addVectors(t, e) {
          return (this.x = t.x + e.x), (this.y = t.y + e.y), this
        }
        addScaledVector(t, e) {
          return (this.x += t.x * e), (this.y += t.y * e), this
        }
        sub(t, e) {
          return void 0 !== e ? this.subVectors(t, e) : ((this.x -= t.x), (this.y -= t.y), this)
        }
        subScalar(t) {
          return (this.x -= t), (this.y -= t), this
        }
        subVectors(t, e) {
          return (this.x = t.x - e.x), (this.y = t.y - e.y), this
        }
        multiply(t) {
          return (this.x *= t.x), (this.y *= t.y), this
        }
        multiplyScalar(t) {
          return (this.x *= t), (this.y *= t), this
        }
        divide(t) {
          return (this.x /= t.x), (this.y /= t.y), this
        }
        divideScalar(t) {
          return this.multiplyScalar(1 / t)
        }
        applyMatrix3(t) {
          const e = this.x,
            i = this.y,
            n = t.elements
          return (this.x = n[0] * e + n[3] * i + n[6]), (this.y = n[1] * e + n[4] * i + n[7]), this
        }
        min(t) {
          return (this.x = Math.min(this.x, t.x)), (this.y = Math.min(this.y, t.y)), this
        }
        max(t) {
          return (this.x = Math.max(this.x, t.x)), (this.y = Math.max(this.y, t.y)), this
        }
        clamp(t, e) {
          return (this.x = Math.max(t.x, Math.min(e.x, this.x))), (this.y = Math.max(t.y, Math.min(e.y, this.y))), this
        }
        clampScalar(t, e) {
          return (this.x = Math.max(t, Math.min(e, this.x))), (this.y = Math.max(t, Math.min(e, this.y))), this
        }
        clampLength(t, e) {
          const i = this.length()
          return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)))
        }
        floor() {
          return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this
        }
        ceil() {
          return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this
        }
        round() {
          return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this
        }
        roundToZero() {
          return (
            (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
            (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
            this
          )
        }
        negate() {
          return (this.x = -this.x), (this.y = -this.y), this
        }
        dot(t) {
          return this.x * t.x + this.y * t.y
        }
        cross(t) {
          return this.x * t.y - this.y * t.x
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y)
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y)
        }
        normalize() {
          return this.divideScalar(this.length() || 1)
        }
        angle() {
          return Math.atan2(-this.y, -this.x) + Math.PI
        }
        distanceTo(t) {
          return Math.sqrt(this.distanceToSquared(t))
        }
        distanceToSquared(t) {
          const e = this.x - t.x,
            i = this.y - t.y
          return e * e + i * i
        }
        manhattanDistanceTo(t) {
          return Math.abs(this.x - t.x) + Math.abs(this.y - t.y)
        }
        setLength(t) {
          return this.normalize().multiplyScalar(t)
        }
        lerp(t, e) {
          return (this.x += (t.x - this.x) * e), (this.y += (t.y - this.y) * e), this
        }
        lerpVectors(t, e, i) {
          return (this.x = t.x + (e.x - t.x) * i), (this.y = t.y + (e.y - t.y) * i), this
        }
        equals(t) {
          return t.x === this.x && t.y === this.y
        }
        fromArray(t, e = 0) {
          return (this.x = t[e]), (this.y = t[e + 1]), this
        }
        toArray(t = [], e = 0) {
          return (t[e] = this.x), (t[e + 1] = this.y), t
        }
        fromBufferAttribute(t, e, i) {
          return (this.x = t.getX(e)), (this.y = t.getY(e)), this
        }
        rotateAround(t, e) {
          const i = Math.cos(e),
            n = Math.sin(e),
            s = this.x - t.x,
            r = this.y - t.y
          return (this.x = s * i - r * n + t.x), (this.y = s * n + r * i + t.y), this
        }
        random() {
          return (this.x = Math.random()), (this.y = Math.random()), this
        }
      }
      gt.prototype.isVector2 = !0
      class mt {
        constructor() {
          this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]
        }
        set(t, e, i, n, s, r, a, o, l) {
          const c = this.elements
          return (
            (c[0] = t),
            (c[1] = n),
            (c[2] = a),
            (c[3] = e),
            (c[4] = s),
            (c[5] = o),
            (c[6] = i),
            (c[7] = r),
            (c[8] = l),
            this
          )
        }
        identity() {
          return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
        }
        copy(t) {
          const e = this.elements,
            i = t.elements
          return (
            (e[0] = i[0]),
            (e[1] = i[1]),
            (e[2] = i[2]),
            (e[3] = i[3]),
            (e[4] = i[4]),
            (e[5] = i[5]),
            (e[6] = i[6]),
            (e[7] = i[7]),
            (e[8] = i[8]),
            this
          )
        }
        extractBasis(t, e, i) {
          return t.setFromMatrix3Column(this, 0), e.setFromMatrix3Column(this, 1), i.setFromMatrix3Column(this, 2), this
        }
        setFromMatrix4(t) {
          const e = t.elements
          return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this
        }
        multiply(t) {
          return this.multiplyMatrices(this, t)
        }
        premultiply(t) {
          return this.multiplyMatrices(t, this)
        }
        multiplyMatrices(t, e) {
          const i = t.elements,
            n = e.elements,
            s = this.elements,
            r = i[0],
            a = i[3],
            o = i[6],
            l = i[1],
            c = i[4],
            h = i[7],
            u = i[2],
            d = i[5],
            p = i[8],
            A = n[0],
            g = n[3],
            m = n[6],
            f = n[1],
            v = n[4],
            y = n[7],
            x = n[2],
            w = n[5],
            _ = n[8]
          return (
            (s[0] = r * A + a * f + o * x),
            (s[3] = r * g + a * v + o * w),
            (s[6] = r * m + a * y + o * _),
            (s[1] = l * A + c * f + h * x),
            (s[4] = l * g + c * v + h * w),
            (s[7] = l * m + c * y + h * _),
            (s[2] = u * A + d * f + p * x),
            (s[5] = u * g + d * v + p * w),
            (s[8] = u * m + d * y + p * _),
            this
          )
        }
        multiplyScalar(t) {
          const e = this.elements
          return (
            (e[0] *= t),
            (e[3] *= t),
            (e[6] *= t),
            (e[1] *= t),
            (e[4] *= t),
            (e[7] *= t),
            (e[2] *= t),
            (e[5] *= t),
            (e[8] *= t),
            this
          )
        }
        determinant() {
          const t = this.elements,
            e = t[0],
            i = t[1],
            n = t[2],
            s = t[3],
            r = t[4],
            a = t[5],
            o = t[6],
            l = t[7],
            c = t[8]
          return e * r * c - e * a * l - i * s * c + i * a * o + n * s * l - n * r * o
        }
        invert() {
          const t = this.elements,
            e = t[0],
            i = t[1],
            n = t[2],
            s = t[3],
            r = t[4],
            a = t[5],
            o = t[6],
            l = t[7],
            c = t[8],
            h = c * r - a * l,
            u = a * o - c * s,
            d = l * s - r * o,
            p = e * h + i * u + n * d
          if (0 === p) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0)
          const A = 1 / p
          return (
            (t[0] = h * A),
            (t[1] = (n * l - c * i) * A),
            (t[2] = (a * i - n * r) * A),
            (t[3] = u * A),
            (t[4] = (c * e - n * o) * A),
            (t[5] = (n * s - a * e) * A),
            (t[6] = d * A),
            (t[7] = (i * o - l * e) * A),
            (t[8] = (r * e - i * s) * A),
            this
          )
        }
        transpose() {
          let t
          const e = this.elements
          return (
            (t = e[1]),
            (e[1] = e[3]),
            (e[3] = t),
            (t = e[2]),
            (e[2] = e[6]),
            (e[6] = t),
            (t = e[5]),
            (e[5] = e[7]),
            (e[7] = t),
            this
          )
        }
        getNormalMatrix(t) {
          return this.setFromMatrix4(t).invert().transpose()
        }
        transposeIntoArray(t) {
          const e = this.elements
          return (
            (t[0] = e[0]),
            (t[1] = e[3]),
            (t[2] = e[6]),
            (t[3] = e[1]),
            (t[4] = e[4]),
            (t[5] = e[7]),
            (t[6] = e[2]),
            (t[7] = e[5]),
            (t[8] = e[8]),
            this
          )
        }
        setUvTransform(t, e, i, n, s, r, a) {
          const o = Math.cos(s),
            l = Math.sin(s)
          return (
            this.set(i * o, i * l, -i * (o * r + l * a) + r + t, -n * l, n * o, -n * (-l * r + o * a) + a + e, 0, 0, 1),
            this
          )
        }
        scale(t, e) {
          const i = this.elements
          return (i[0] *= t), (i[3] *= t), (i[6] *= t), (i[1] *= e), (i[4] *= e), (i[7] *= e), this
        }
        rotate(t) {
          const e = Math.cos(t),
            i = Math.sin(t),
            n = this.elements,
            s = n[0],
            r = n[3],
            a = n[6],
            o = n[1],
            l = n[4],
            c = n[7]
          return (
            (n[0] = e * s + i * o),
            (n[3] = e * r + i * l),
            (n[6] = e * a + i * c),
            (n[1] = -i * s + e * o),
            (n[4] = -i * r + e * l),
            (n[7] = -i * a + e * c),
            this
          )
        }
        translate(t, e) {
          const i = this.elements
          return (
            (i[0] += t * i[2]),
            (i[3] += t * i[5]),
            (i[6] += t * i[8]),
            (i[1] += e * i[2]),
            (i[4] += e * i[5]),
            (i[7] += e * i[8]),
            this
          )
        }
        equals(t) {
          const e = this.elements,
            i = t.elements
          for (let n = 0; n < 9; n++) if (e[n] !== i[n]) return !1
          return !0
        }
        fromArray(t, e = 0) {
          for (let i = 0; i < 9; i++) this.elements[i] = t[i + e]
          return this
        }
        toArray(t = [], e = 0) {
          const i = this.elements
          return (
            (t[e] = i[0]),
            (t[e + 1] = i[1]),
            (t[e + 2] = i[2]),
            (t[e + 3] = i[3]),
            (t[e + 4] = i[4]),
            (t[e + 5] = i[5]),
            (t[e + 6] = i[6]),
            (t[e + 7] = i[7]),
            (t[e + 8] = i[8]),
            t
          )
        }
        clone() {
          return new this.constructor().fromArray(this.elements)
        }
      }
      let ft
      mt.prototype.isMatrix3 = !0
      class vt {
        static getDataURL(t) {
          if (/^data:/i.test(t.src)) return t.src
          if ('undefined' == typeof HTMLCanvasElement) return t.src
          let e
          if (t instanceof HTMLCanvasElement) e = t
          else {
            void 0 === ft && (ft = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas')),
              (ft.width = t.width),
              (ft.height = t.height)
            const i = ft.getContext('2d')
            t instanceof ImageData ? i.putImageData(t, 0, 0) : i.drawImage(t, 0, 0, t.width, t.height), (e = ft)
          }
          return e.width > 2048 || e.height > 2048 ? e.toDataURL('image/jpeg', 0.6) : e.toDataURL('image/png')
        }
      }
      let yt = 0
      class xt extends it {
        constructor(
          t = xt.DEFAULT_IMAGE,
          e = xt.DEFAULT_MAPPING,
          i = 1001,
          n = 1001,
          s = 1006,
          r = 1008,
          a = 1023,
          o = 1009,
          l = 1,
          c = 3e3,
        ) {
          super(),
            Object.defineProperty(this, 'id', { value: yt++ }),
            (this.uuid = ot()),
            (this.name = ''),
            (this.image = t),
            (this.mipmaps = []),
            (this.mapping = e),
            (this.wrapS = i),
            (this.wrapT = n),
            (this.magFilter = s),
            (this.minFilter = r),
            (this.anisotropy = l),
            (this.format = a),
            (this.internalFormat = null),
            (this.type = o),
            (this.offset = new gt(0, 0)),
            (this.repeat = new gt(1, 1)),
            (this.center = new gt(0, 0)),
            (this.rotation = 0),
            (this.matrixAutoUpdate = !0),
            (this.matrix = new mt()),
            (this.generateMipmaps = !0),
            (this.premultiplyAlpha = !1),
            (this.flipY = !0),
            (this.unpackAlignment = 4),
            (this.encoding = c),
            (this.version = 0),
            (this.onUpdate = null),
            (this.isRenderTargetTexture = !1)
        }
        updateMatrix() {
          this.matrix.setUvTransform(
            this.offset.x,
            this.offset.y,
            this.repeat.x,
            this.repeat.y,
            this.rotation,
            this.center.x,
            this.center.y,
          )
        }
        clone() {
          return new this.constructor().copy(this)
        }
        copy(t) {
          return (
            (this.name = t.name),
            (this.image = t.image),
            (this.mipmaps = t.mipmaps.slice(0)),
            (this.mapping = t.mapping),
            (this.wrapS = t.wrapS),
            (this.wrapT = t.wrapT),
            (this.magFilter = t.magFilter),
            (this.minFilter = t.minFilter),
            (this.anisotropy = t.anisotropy),
            (this.format = t.format),
            (this.internalFormat = t.internalFormat),
            (this.type = t.type),
            this.offset.copy(t.offset),
            this.repeat.copy(t.repeat),
            this.center.copy(t.center),
            (this.rotation = t.rotation),
            (this.matrixAutoUpdate = t.matrixAutoUpdate),
            this.matrix.copy(t.matrix),
            (this.generateMipmaps = t.generateMipmaps),
            (this.premultiplyAlpha = t.premultiplyAlpha),
            (this.flipY = t.flipY),
            (this.unpackAlignment = t.unpackAlignment),
            (this.encoding = t.encoding),
            this
          )
        }
        toJSON(t) {
          const e = void 0 === t || 'string' == typeof t
          if (!e && void 0 !== t.textures[this.uuid]) return t.textures[this.uuid]
          const i = {
            metadata: { version: 4.5, type: 'Texture', generator: 'Texture.toJSON' },
            uuid: this.uuid,
            name: this.name,
            mapping: this.mapping,
            repeat: [this.repeat.x, this.repeat.y],
            offset: [this.offset.x, this.offset.y],
            center: [this.center.x, this.center.y],
            rotation: this.rotation,
            wrap: [this.wrapS, this.wrapT],
            format: this.format,
            type: this.type,
            encoding: this.encoding,
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY,
            premultiplyAlpha: this.premultiplyAlpha,
            unpackAlignment: this.unpackAlignment,
          }
          if (void 0 !== this.image) {
            const n = this.image
            if ((void 0 === n.uuid && (n.uuid = ot()), !e && void 0 === t.images[n.uuid])) {
              let e
              if (Array.isArray(n)) {
                e = []
                for (let t = 0, i = n.length; t < i; t++) n[t].isDataTexture ? e.push(wt(n[t].image)) : e.push(wt(n[t]))
              } else e = wt(n)
              t.images[n.uuid] = { uuid: n.uuid, url: e }
            }
            i.image = n.uuid
          }
          return e || (t.textures[this.uuid] = i), i
        }
        dispose() {
          this.dispatchEvent({ type: 'dispose' })
        }
        transformUv(t) {
          if (300 !== this.mapping) return t
          if ((t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1))
            switch (this.wrapS) {
              case 1e3:
                t.x = t.x - Math.floor(t.x)
                break
              case 1001:
                t.x = t.x < 0 ? 0 : 1
                break
              case 1002:
                1 === Math.abs(Math.floor(t.x) % 2) ? (t.x = Math.ceil(t.x) - t.x) : (t.x = t.x - Math.floor(t.x))
            }
          if (t.y < 0 || t.y > 1)
            switch (this.wrapT) {
              case 1e3:
                t.y = t.y - Math.floor(t.y)
                break
              case 1001:
                t.y = t.y < 0 ? 0 : 1
                break
              case 1002:
                1 === Math.abs(Math.floor(t.y) % 2) ? (t.y = Math.ceil(t.y) - t.y) : (t.y = t.y - Math.floor(t.y))
            }
          return this.flipY && (t.y = 1 - t.y), t
        }
        set needsUpdate(t) {
          !0 === t && this.version++
        }
      }
      function wt(t) {
        return ('undefined' != typeof HTMLImageElement && t instanceof HTMLImageElement) ||
          ('undefined' != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement) ||
          ('undefined' != typeof ImageBitmap && t instanceof ImageBitmap)
          ? vt.getDataURL(t)
          : t.data
          ? {
              data: Array.prototype.slice.call(t.data),
              width: t.width,
              height: t.height,
              type: t.data.constructor.name,
            }
          : {}
      }
      ;(xt.DEFAULT_IMAGE = void 0), (xt.DEFAULT_MAPPING = 300), (xt.prototype.isTexture = !0)
      class _t {
        constructor(t = 0, e = 0, i = 0, n = 1) {
          ;(this.x = t), (this.y = e), (this.z = i), (this.w = n)
        }
        get width() {
          return this.z
        }
        set width(t) {
          this.z = t
        }
        get height() {
          return this.w
        }
        set height(t) {
          this.w = t
        }
        set(t, e, i, n) {
          return (this.x = t), (this.y = e), (this.z = i), (this.w = n), this
        }
        setScalar(t) {
          return (this.x = t), (this.y = t), (this.z = t), (this.w = t), this
        }
        setX(t) {
          return (this.x = t), this
        }
        setY(t) {
          return (this.y = t), this
        }
        setZ(t) {
          return (this.z = t), this
        }
        setW(t) {
          return (this.w = t), this
        }
        setComponent(t, e) {
          switch (t) {
            case 0:
              this.x = e
              break
            case 1:
              this.y = e
              break
            case 2:
              this.z = e
              break
            case 3:
              this.w = e
              break
            default:
              throw new Error('index is out of range: ' + t)
          }
          return this
        }
        getComponent(t) {
          switch (t) {
            case 0:
              return this.x
            case 1:
              return this.y
            case 2:
              return this.z
            case 3:
              return this.w
            default:
              throw new Error('index is out of range: ' + t)
          }
        }
        clone() {
          return new this.constructor(this.x, this.y, this.z, this.w)
        }
        copy(t) {
          return (this.x = t.x), (this.y = t.y), (this.z = t.z), (this.w = void 0 !== t.w ? t.w : 1), this
        }
        add(t, e) {
          return void 0 !== e
            ? this.addVectors(t, e)
            : ((this.x += t.x), (this.y += t.y), (this.z += t.z), (this.w += t.w), this)
        }
        addScalar(t) {
          return (this.x += t), (this.y += t), (this.z += t), (this.w += t), this
        }
        addVectors(t, e) {
          return (this.x = t.x + e.x), (this.y = t.y + e.y), (this.z = t.z + e.z), (this.w = t.w + e.w), this
        }
        addScaledVector(t, e) {
          return (this.x += t.x * e), (this.y += t.y * e), (this.z += t.z * e), (this.w += t.w * e), this
        }
        sub(t, e) {
          return void 0 !== e
            ? this.subVectors(t, e)
            : ((this.x -= t.x), (this.y -= t.y), (this.z -= t.z), (this.w -= t.w), this)
        }
        subScalar(t) {
          return (this.x -= t), (this.y -= t), (this.z -= t), (this.w -= t), this
        }
        subVectors(t, e) {
          return (this.x = t.x - e.x), (this.y = t.y - e.y), (this.z = t.z - e.z), (this.w = t.w - e.w), this
        }
        multiply(t) {
          return (this.x *= t.x), (this.y *= t.y), (this.z *= t.z), (this.w *= t.w), this
        }
        multiplyScalar(t) {
          return (this.x *= t), (this.y *= t), (this.z *= t), (this.w *= t), this
        }
        applyMatrix4(t) {
          const e = this.x,
            i = this.y,
            n = this.z,
            s = this.w,
            r = t.elements
          return (
            (this.x = r[0] * e + r[4] * i + r[8] * n + r[12] * s),
            (this.y = r[1] * e + r[5] * i + r[9] * n + r[13] * s),
            (this.z = r[2] * e + r[6] * i + r[10] * n + r[14] * s),
            (this.w = r[3] * e + r[7] * i + r[11] * n + r[15] * s),
            this
          )
        }
        divideScalar(t) {
          return this.multiplyScalar(1 / t)
        }
        setAxisAngleFromQuaternion(t) {
          this.w = 2 * Math.acos(t.w)
          const e = Math.sqrt(1 - t.w * t.w)
          return (
            e < 1e-4
              ? ((this.x = 1), (this.y = 0), (this.z = 0))
              : ((this.x = t.x / e), (this.y = t.y / e), (this.z = t.z / e)),
            this
          )
        }
        setAxisAngleFromRotationMatrix(t) {
          let e, i, n, s
          const r = 0.01,
            a = 0.1,
            o = t.elements,
            l = o[0],
            c = o[4],
            h = o[8],
            u = o[1],
            d = o[5],
            p = o[9],
            A = o[2],
            g = o[6],
            m = o[10]
          if (Math.abs(c - u) < r && Math.abs(h - A) < r && Math.abs(p - g) < r) {
            if (Math.abs(c + u) < a && Math.abs(h + A) < a && Math.abs(p + g) < a && Math.abs(l + d + m - 3) < a)
              return this.set(1, 0, 0, 0), this
            e = Math.PI
            const t = (l + 1) / 2,
              o = (d + 1) / 2,
              f = (m + 1) / 2,
              v = (c + u) / 4,
              y = (h + A) / 4,
              x = (p + g) / 4
            return (
              t > o && t > f
                ? t < r
                  ? ((i = 0), (n = 0.707106781), (s = 0.707106781))
                  : ((i = Math.sqrt(t)), (n = v / i), (s = y / i))
                : o > f
                ? o < r
                  ? ((i = 0.707106781), (n = 0), (s = 0.707106781))
                  : ((n = Math.sqrt(o)), (i = v / n), (s = x / n))
                : f < r
                ? ((i = 0.707106781), (n = 0.707106781), (s = 0))
                : ((s = Math.sqrt(f)), (i = y / s), (n = x / s)),
              this.set(i, n, s, e),
              this
            )
          }
          let f = Math.sqrt((g - p) * (g - p) + (h - A) * (h - A) + (u - c) * (u - c))
          return (
            Math.abs(f) < 0.001 && (f = 1),
            (this.x = (g - p) / f),
            (this.y = (h - A) / f),
            (this.z = (u - c) / f),
            (this.w = Math.acos((l + d + m - 1) / 2)),
            this
          )
        }
        min(t) {
          return (
            (this.x = Math.min(this.x, t.x)),
            (this.y = Math.min(this.y, t.y)),
            (this.z = Math.min(this.z, t.z)),
            (this.w = Math.min(this.w, t.w)),
            this
          )
        }
        max(t) {
          return (
            (this.x = Math.max(this.x, t.x)),
            (this.y = Math.max(this.y, t.y)),
            (this.z = Math.max(this.z, t.z)),
            (this.w = Math.max(this.w, t.w)),
            this
          )
        }
        clamp(t, e) {
          return (
            (this.x = Math.max(t.x, Math.min(e.x, this.x))),
            (this.y = Math.max(t.y, Math.min(e.y, this.y))),
            (this.z = Math.max(t.z, Math.min(e.z, this.z))),
            (this.w = Math.max(t.w, Math.min(e.w, this.w))),
            this
          )
        }
        clampScalar(t, e) {
          return (
            (this.x = Math.max(t, Math.min(e, this.x))),
            (this.y = Math.max(t, Math.min(e, this.y))),
            (this.z = Math.max(t, Math.min(e, this.z))),
            (this.w = Math.max(t, Math.min(e, this.w))),
            this
          )
        }
        clampLength(t, e) {
          const i = this.length()
          return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)))
        }
        floor() {
          return (
            (this.x = Math.floor(this.x)),
            (this.y = Math.floor(this.y)),
            (this.z = Math.floor(this.z)),
            (this.w = Math.floor(this.w)),
            this
          )
        }
        ceil() {
          return (
            (this.x = Math.ceil(this.x)),
            (this.y = Math.ceil(this.y)),
            (this.z = Math.ceil(this.z)),
            (this.w = Math.ceil(this.w)),
            this
          )
        }
        round() {
          return (
            (this.x = Math.round(this.x)),
            (this.y = Math.round(this.y)),
            (this.z = Math.round(this.z)),
            (this.w = Math.round(this.w)),
            this
          )
        }
        roundToZero() {
          return (
            (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
            (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
            (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
            (this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w)),
            this
          )
        }
        negate() {
          return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), (this.w = -this.w), this
        }
        dot(t) {
          return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
        }
        normalize() {
          return this.divideScalar(this.length() || 1)
        }
        setLength(t) {
          return this.normalize().multiplyScalar(t)
        }
        lerp(t, e) {
          return (
            (this.x += (t.x - this.x) * e),
            (this.y += (t.y - this.y) * e),
            (this.z += (t.z - this.z) * e),
            (this.w += (t.w - this.w) * e),
            this
          )
        }
        lerpVectors(t, e, i) {
          return (
            (this.x = t.x + (e.x - t.x) * i),
            (this.y = t.y + (e.y - t.y) * i),
            (this.z = t.z + (e.z - t.z) * i),
            (this.w = t.w + (e.w - t.w) * i),
            this
          )
        }
        equals(t) {
          return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
        }
        fromArray(t, e = 0) {
          return (this.x = t[e]), (this.y = t[e + 1]), (this.z = t[e + 2]), (this.w = t[e + 3]), this
        }
        toArray(t = [], e = 0) {
          return (t[e] = this.x), (t[e + 1] = this.y), (t[e + 2] = this.z), (t[e + 3] = this.w), t
        }
        fromBufferAttribute(t, e, i) {
          return (this.x = t.getX(e)), (this.y = t.getY(e)), (this.z = t.getZ(e)), (this.w = t.getW(e)), this
        }
        random() {
          return (
            (this.x = Math.random()), (this.y = Math.random()), (this.z = Math.random()), (this.w = Math.random()), this
          )
        }
      }
      _t.prototype.isVector4 = !0
      class It extends it {
        constructor(t, e, i = {}) {
          super(),
            (this.width = t),
            (this.height = e),
            (this.depth = 1),
            (this.scissor = new _t(0, 0, t, e)),
            (this.scissorTest = !1),
            (this.viewport = new _t(0, 0, t, e)),
            (this.texture = new xt(
              void 0,
              i.mapping,
              i.wrapS,
              i.wrapT,
              i.magFilter,
              i.minFilter,
              i.format,
              i.type,
              i.anisotropy,
              i.encoding,
            )),
            (this.texture.isRenderTargetTexture = !0),
            (this.texture.image = { width: t, height: e, depth: 1 }),
            (this.texture.generateMipmaps = void 0 !== i.generateMipmaps && i.generateMipmaps),
            (this.texture.minFilter = void 0 !== i.minFilter ? i.minFilter : 1006),
            (this.depthBuffer = void 0 === i.depthBuffer || i.depthBuffer),
            (this.stencilBuffer = void 0 !== i.stencilBuffer && i.stencilBuffer),
            (this.depthTexture = void 0 !== i.depthTexture ? i.depthTexture : null)
        }
        setTexture(t) {
          ;(t.image = { width: this.width, height: this.height, depth: this.depth }), (this.texture = t)
        }
        setSize(t, e, i = 1) {
          ;(this.width === t && this.height === e && this.depth === i) ||
            ((this.width = t),
            (this.height = e),
            (this.depth = i),
            (this.texture.image.width = t),
            (this.texture.image.height = e),
            (this.texture.image.depth = i),
            this.dispose()),
            this.viewport.set(0, 0, t, e),
            this.scissor.set(0, 0, t, e)
        }
        clone() {
          return new this.constructor().copy(this)
        }
        copy(t) {
          return (
            (this.width = t.width),
            (this.height = t.height),
            (this.depth = t.depth),
            this.viewport.copy(t.viewport),
            (this.texture = t.texture.clone()),
            (this.texture.image = { ...this.texture.image }),
            (this.depthBuffer = t.depthBuffer),
            (this.stencilBuffer = t.stencilBuffer),
            (this.depthTexture = t.depthTexture),
            this
          )
        }
        dispose() {
          this.dispatchEvent({ type: 'dispose' })
        }
      }
      ;(It.prototype.isWebGLRenderTarget = !0),
        (class extends It {
          constructor(t, e, i) {
            super(t, e)
            const n = this.texture
            this.texture = []
            for (let s = 0; s < i; s++) this.texture[s] = n.clone()
          }
          setSize(t, e, i = 1) {
            if (this.width !== t || this.height !== e || this.depth !== i) {
              ;(this.width = t), (this.height = e), (this.depth = i)
              for (let n = 0, s = this.texture.length; n < s; n++)
                (this.texture[n].image.width = t), (this.texture[n].image.height = e), (this.texture[n].image.depth = i)
              this.dispose()
            }
            return this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e), this
          }
          copy(t) {
            this.dispose(),
              (this.width = t.width),
              (this.height = t.height),
              (this.depth = t.depth),
              this.viewport.set(0, 0, this.width, this.height),
              this.scissor.set(0, 0, this.width, this.height),
              (this.depthBuffer = t.depthBuffer),
              (this.stencilBuffer = t.stencilBuffer),
              (this.depthTexture = t.depthTexture),
              (this.texture.length = 0)
            for (let e = 0, i = t.texture.length; e < i; e++) this.texture[e] = t.texture[e].clone()
            return this
          }
        }.prototype.isWebGLMultipleRenderTargets = !0)
      class Ct extends It {
        constructor(t, e, i) {
          super(t, e, i), (this.samples = 4)
        }
        copy(t) {
          return super.copy.call(this, t), (this.samples = t.samples), this
        }
      }
      Ct.prototype.isWebGLMultisampleRenderTarget = !0
      class Mt {
        constructor(t = 0, e = 0, i = 0, n = 1) {
          ;(this._x = t), (this._y = e), (this._z = i), (this._w = n)
        }
        static slerp(t, e, i, n) {
          return i.slerpQuaternions(t, e, n)
        }
        static slerpFlat(t, e, i, n, s, r, a) {
          let o = i[n + 0],
            l = i[n + 1],
            c = i[n + 2],
            h = i[n + 3]
          const u = s[r + 0],
            d = s[r + 1],
            p = s[r + 2],
            A = s[r + 3]
          if (0 === a) return (t[e + 0] = o), (t[e + 1] = l), (t[e + 2] = c), void (t[e + 3] = h)
          if (1 === a) return (t[e + 0] = u), (t[e + 1] = d), (t[e + 2] = p), void (t[e + 3] = A)
          if (h !== A || o !== u || l !== d || c !== p) {
            let t = 1 - a
            const e = o * u + l * d + c * p + h * A,
              i = e >= 0 ? 1 : -1,
              n = 1 - e * e
            if (n > Number.EPSILON) {
              const s = Math.sqrt(n),
                r = Math.atan2(s, e * i)
              ;(t = Math.sin(t * r) / s), (a = Math.sin(a * r) / s)
            }
            const s = a * i
            if (((o = o * t + u * s), (l = l * t + d * s), (c = c * t + p * s), (h = h * t + A * s), t === 1 - a)) {
              const t = 1 / Math.sqrt(o * o + l * l + c * c + h * h)
              ;(o *= t), (l *= t), (c *= t), (h *= t)
            }
          }
          ;(t[e] = o), (t[e + 1] = l), (t[e + 2] = c), (t[e + 3] = h)
        }
        static multiplyQuaternionsFlat(t, e, i, n, s, r) {
          const a = i[n],
            o = i[n + 1],
            l = i[n + 2],
            c = i[n + 3],
            h = s[r],
            u = s[r + 1],
            d = s[r + 2],
            p = s[r + 3]
          return (
            (t[e] = a * p + c * h + o * d - l * u),
            (t[e + 1] = o * p + c * u + l * h - a * d),
            (t[e + 2] = l * p + c * d + a * u - o * h),
            (t[e + 3] = c * p - a * h - o * u - l * d),
            t
          )
        }
        get x() {
          return this._x
        }
        set x(t) {
          ;(this._x = t), this._onChangeCallback()
        }
        get y() {
          return this._y
        }
        set y(t) {
          ;(this._y = t), this._onChangeCallback()
        }
        get z() {
          return this._z
        }
        set z(t) {
          ;(this._z = t), this._onChangeCallback()
        }
        get w() {
          return this._w
        }
        set w(t) {
          ;(this._w = t), this._onChangeCallback()
        }
        set(t, e, i, n) {
          return (this._x = t), (this._y = e), (this._z = i), (this._w = n), this._onChangeCallback(), this
        }
        clone() {
          return new this.constructor(this._x, this._y, this._z, this._w)
        }
        copy(t) {
          return (this._x = t.x), (this._y = t.y), (this._z = t.z), (this._w = t.w), this._onChangeCallback(), this
        }
        setFromEuler(t, e) {
          if (!t || !t.isEuler)
            throw new Error(
              'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.',
            )
          const i = t._x,
            n = t._y,
            s = t._z,
            r = t._order,
            a = Math.cos,
            o = Math.sin,
            l = a(i / 2),
            c = a(n / 2),
            h = a(s / 2),
            u = o(i / 2),
            d = o(n / 2),
            p = o(s / 2)
          switch (r) {
            case 'XYZ':
              ;(this._x = u * c * h + l * d * p),
                (this._y = l * d * h - u * c * p),
                (this._z = l * c * p + u * d * h),
                (this._w = l * c * h - u * d * p)
              break
            case 'YXZ':
              ;(this._x = u * c * h + l * d * p),
                (this._y = l * d * h - u * c * p),
                (this._z = l * c * p - u * d * h),
                (this._w = l * c * h + u * d * p)
              break
            case 'ZXY':
              ;(this._x = u * c * h - l * d * p),
                (this._y = l * d * h + u * c * p),
                (this._z = l * c * p + u * d * h),
                (this._w = l * c * h - u * d * p)
              break
            case 'ZYX':
              ;(this._x = u * c * h - l * d * p),
                (this._y = l * d * h + u * c * p),
                (this._z = l * c * p - u * d * h),
                (this._w = l * c * h + u * d * p)
              break
            case 'YZX':
              ;(this._x = u * c * h + l * d * p),
                (this._y = l * d * h + u * c * p),
                (this._z = l * c * p - u * d * h),
                (this._w = l * c * h - u * d * p)
              break
            case 'XZY':
              ;(this._x = u * c * h - l * d * p),
                (this._y = l * d * h - u * c * p),
                (this._z = l * c * p + u * d * h),
                (this._w = l * c * h + u * d * p)
          }
          return !1 !== e && this._onChangeCallback(), this
        }
        setFromAxisAngle(t, e) {
          const i = e / 2,
            n = Math.sin(i)
          return (
            (this._x = t.x * n),
            (this._y = t.y * n),
            (this._z = t.z * n),
            (this._w = Math.cos(i)),
            this._onChangeCallback(),
            this
          )
        }
        setFromRotationMatrix(t) {
          const e = t.elements,
            i = e[0],
            n = e[4],
            s = e[8],
            r = e[1],
            a = e[5],
            o = e[9],
            l = e[2],
            c = e[6],
            h = e[10],
            u = i + a + h
          if (u > 0) {
            const t = 0.5 / Math.sqrt(u + 1)
            ;(this._w = 0.25 / t), (this._x = (c - o) * t), (this._y = (s - l) * t), (this._z = (r - n) * t)
          } else if (i > a && i > h) {
            const t = 2 * Math.sqrt(1 + i - a - h)
            ;(this._w = (c - o) / t), (this._x = 0.25 * t), (this._y = (n + r) / t), (this._z = (s + l) / t)
          } else if (a > h) {
            const t = 2 * Math.sqrt(1 + a - i - h)
            ;(this._w = (s - l) / t), (this._x = (n + r) / t), (this._y = 0.25 * t), (this._z = (o + c) / t)
          } else {
            const t = 2 * Math.sqrt(1 + h - i - a)
            ;(this._w = (r - n) / t), (this._x = (s + l) / t), (this._y = (o + c) / t), (this._z = 0.25 * t)
          }
          return this._onChangeCallback(), this
        }
        setFromUnitVectors(t, e) {
          let i = t.dot(e) + 1
          return (
            i < Number.EPSILON
              ? ((i = 0),
                Math.abs(t.x) > Math.abs(t.z)
                  ? ((this._x = -t.y), (this._y = t.x), (this._z = 0), (this._w = i))
                  : ((this._x = 0), (this._y = -t.z), (this._z = t.y), (this._w = i)))
              : ((this._x = t.y * e.z - t.z * e.y),
                (this._y = t.z * e.x - t.x * e.z),
                (this._z = t.x * e.y - t.y * e.x),
                (this._w = i)),
            this.normalize()
          )
        }
        angleTo(t) {
          return 2 * Math.acos(Math.abs(lt(this.dot(t), -1, 1)))
        }
        rotateTowards(t, e) {
          const i = this.angleTo(t)
          if (0 === i) return this
          const n = Math.min(1, e / i)
          return this.slerp(t, n), this
        }
        identity() {
          return this.set(0, 0, 0, 1)
        }
        invert() {
          return this.conjugate()
        }
        conjugate() {
          return (this._x *= -1), (this._y *= -1), (this._z *= -1), this._onChangeCallback(), this
        }
        dot(t) {
          return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
        }
        lengthSq() {
          return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
        }
        length() {
          return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
        }
        normalize() {
          let t = this.length()
          return (
            0 === t
              ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
              : ((t = 1 / t),
                (this._x = this._x * t),
                (this._y = this._y * t),
                (this._z = this._z * t),
                (this._w = this._w * t)),
            this._onChangeCallback(),
            this
          )
        }
        multiply(t, e) {
          return void 0 !== e ? this.multiplyQuaternions(t, e) : this.multiplyQuaternions(this, t)
        }
        premultiply(t) {
          return this.multiplyQuaternions(t, this)
        }
        multiplyQuaternions(t, e) {
          const i = t._x,
            n = t._y,
            s = t._z,
            r = t._w,
            a = e._x,
            o = e._y,
            l = e._z,
            c = e._w
          return (
            (this._x = i * c + r * a + n * l - s * o),
            (this._y = n * c + r * o + s * a - i * l),
            (this._z = s * c + r * l + i * o - n * a),
            (this._w = r * c - i * a - n * o - s * l),
            this._onChangeCallback(),
            this
          )
        }
        slerp(t, e) {
          if (0 === e) return this
          if (1 === e) return this.copy(t)
          const i = this._x,
            n = this._y,
            s = this._z,
            r = this._w
          let a = r * t._w + i * t._x + n * t._y + s * t._z
          if (
            (a < 0
              ? ((this._w = -t._w), (this._x = -t._x), (this._y = -t._y), (this._z = -t._z), (a = -a))
              : this.copy(t),
            a >= 1)
          )
            return (this._w = r), (this._x = i), (this._y = n), (this._z = s), this
          const o = 1 - a * a
          if (o <= Number.EPSILON) {
            const t = 1 - e
            return (
              (this._w = t * r + e * this._w),
              (this._x = t * i + e * this._x),
              (this._y = t * n + e * this._y),
              (this._z = t * s + e * this._z),
              this.normalize(),
              this._onChangeCallback(),
              this
            )
          }
          const l = Math.sqrt(o),
            c = Math.atan2(l, a),
            h = Math.sin((1 - e) * c) / l,
            u = Math.sin(e * c) / l
          return (
            (this._w = r * h + this._w * u),
            (this._x = i * h + this._x * u),
            (this._y = n * h + this._y * u),
            (this._z = s * h + this._z * u),
            this._onChangeCallback(),
            this
          )
        }
        slerpQuaternions(t, e, i) {
          this.copy(t).slerp(e, i)
        }
        equals(t) {
          return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w
        }
        fromArray(t, e = 0) {
          return (
            (this._x = t[e]),
            (this._y = t[e + 1]),
            (this._z = t[e + 2]),
            (this._w = t[e + 3]),
            this._onChangeCallback(),
            this
          )
        }
        toArray(t = [], e = 0) {
          return (t[e] = this._x), (t[e + 1] = this._y), (t[e + 2] = this._z), (t[e + 3] = this._w), t
        }
        fromBufferAttribute(t, e) {
          return (this._x = t.getX(e)), (this._y = t.getY(e)), (this._z = t.getZ(e)), (this._w = t.getW(e)), this
        }
        _onChange(t) {
          return (this._onChangeCallback = t), this
        }
        _onChangeCallback() {}
      }
      Mt.prototype.isQuaternion = !0
      class Et {
        constructor(t = 0, e = 0, i = 0) {
          ;(this.x = t), (this.y = e), (this.z = i)
        }
        set(t, e, i) {
          return void 0 === i && (i = this.z), (this.x = t), (this.y = e), (this.z = i), this
        }
        setScalar(t) {
          return (this.x = t), (this.y = t), (this.z = t), this
        }
        setX(t) {
          return (this.x = t), this
        }
        setY(t) {
          return (this.y = t), this
        }
        setZ(t) {
          return (this.z = t), this
        }
        setComponent(t, e) {
          switch (t) {
            case 0:
              this.x = e
              break
            case 1:
              this.y = e
              break
            case 2:
              this.z = e
              break
            default:
              throw new Error('index is out of range: ' + t)
          }
          return this
        }
        getComponent(t) {
          switch (t) {
            case 0:
              return this.x
            case 1:
              return this.y
            case 2:
              return this.z
            default:
              throw new Error('index is out of range: ' + t)
          }
        }
        clone() {
          return new this.constructor(this.x, this.y, this.z)
        }
        copy(t) {
          return (this.x = t.x), (this.y = t.y), (this.z = t.z), this
        }
        add(t, e) {
          return void 0 !== e ? this.addVectors(t, e) : ((this.x += t.x), (this.y += t.y), (this.z += t.z), this)
        }
        addScalar(t) {
          return (this.x += t), (this.y += t), (this.z += t), this
        }
        addVectors(t, e) {
          return (this.x = t.x + e.x), (this.y = t.y + e.y), (this.z = t.z + e.z), this
        }
        addScaledVector(t, e) {
          return (this.x += t.x * e), (this.y += t.y * e), (this.z += t.z * e), this
        }
        sub(t, e) {
          return void 0 !== e ? this.subVectors(t, e) : ((this.x -= t.x), (this.y -= t.y), (this.z -= t.z), this)
        }
        subScalar(t) {
          return (this.x -= t), (this.y -= t), (this.z -= t), this
        }
        subVectors(t, e) {
          return (this.x = t.x - e.x), (this.y = t.y - e.y), (this.z = t.z - e.z), this
        }
        multiply(t, e) {
          return void 0 !== e ? this.multiplyVectors(t, e) : ((this.x *= t.x), (this.y *= t.y), (this.z *= t.z), this)
        }
        multiplyScalar(t) {
          return (this.x *= t), (this.y *= t), (this.z *= t), this
        }
        multiplyVectors(t, e) {
          return (this.x = t.x * e.x), (this.y = t.y * e.y), (this.z = t.z * e.z), this
        }
        applyEuler(t) {
          return t && t.isEuler, this.applyQuaternion(St.setFromEuler(t))
        }
        applyAxisAngle(t, e) {
          return this.applyQuaternion(St.setFromAxisAngle(t, e))
        }
        applyMatrix3(t) {
          const e = this.x,
            i = this.y,
            n = this.z,
            s = t.elements
          return (
            (this.x = s[0] * e + s[3] * i + s[6] * n),
            (this.y = s[1] * e + s[4] * i + s[7] * n),
            (this.z = s[2] * e + s[5] * i + s[8] * n),
            this
          )
        }
        applyNormalMatrix(t) {
          return this.applyMatrix3(t).normalize()
        }
        applyMatrix4(t) {
          const e = this.x,
            i = this.y,
            n = this.z,
            s = t.elements,
            r = 1 / (s[3] * e + s[7] * i + s[11] * n + s[15])
          return (
            (this.x = (s[0] * e + s[4] * i + s[8] * n + s[12]) * r),
            (this.y = (s[1] * e + s[5] * i + s[9] * n + s[13]) * r),
            (this.z = (s[2] * e + s[6] * i + s[10] * n + s[14]) * r),
            this
          )
        }
        applyQuaternion(t) {
          const e = this.x,
            i = this.y,
            n = this.z,
            s = t.x,
            r = t.y,
            a = t.z,
            o = t.w,
            l = o * e + r * n - a * i,
            c = o * i + a * e - s * n,
            h = o * n + s * i - r * e,
            u = -s * e - r * i - a * n
          return (
            (this.x = l * o + u * -s + c * -a - h * -r),
            (this.y = c * o + u * -r + h * -s - l * -a),
            (this.z = h * o + u * -a + l * -r - c * -s),
            this
          )
        }
        project(t) {
          return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)
        }
        unproject(t) {
          return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)
        }
        transformDirection(t) {
          const e = this.x,
            i = this.y,
            n = this.z,
            s = t.elements
          return (
            (this.x = s[0] * e + s[4] * i + s[8] * n),
            (this.y = s[1] * e + s[5] * i + s[9] * n),
            (this.z = s[2] * e + s[6] * i + s[10] * n),
            this.normalize()
          )
        }
        divide(t) {
          return (this.x /= t.x), (this.y /= t.y), (this.z /= t.z), this
        }
        divideScalar(t) {
          return this.multiplyScalar(1 / t)
        }
        min(t) {
          return (
            (this.x = Math.min(this.x, t.x)), (this.y = Math.min(this.y, t.y)), (this.z = Math.min(this.z, t.z)), this
          )
        }
        max(t) {
          return (
            (this.x = Math.max(this.x, t.x)), (this.y = Math.max(this.y, t.y)), (this.z = Math.max(this.z, t.z)), this
          )
        }
        clamp(t, e) {
          return (
            (this.x = Math.max(t.x, Math.min(e.x, this.x))),
            (this.y = Math.max(t.y, Math.min(e.y, this.y))),
            (this.z = Math.max(t.z, Math.min(e.z, this.z))),
            this
          )
        }
        clampScalar(t, e) {
          return (
            (this.x = Math.max(t, Math.min(e, this.x))),
            (this.y = Math.max(t, Math.min(e, this.y))),
            (this.z = Math.max(t, Math.min(e, this.z))),
            this
          )
        }
        clampLength(t, e) {
          const i = this.length()
          return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)))
        }
        floor() {
          return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), (this.z = Math.floor(this.z)), this
        }
        ceil() {
          return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), (this.z = Math.ceil(this.z)), this
        }
        round() {
          return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), (this.z = Math.round(this.z)), this
        }
        roundToZero() {
          return (
            (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
            (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
            (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
            this
          )
        }
        negate() {
          return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this
        }
        dot(t) {
          return this.x * t.x + this.y * t.y + this.z * t.z
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y + this.z * this.z
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
        }
        normalize() {
          return this.divideScalar(this.length() || 1)
        }
        setLength(t) {
          return this.normalize().multiplyScalar(t)
        }
        lerp(t, e) {
          return (this.x += (t.x - this.x) * e), (this.y += (t.y - this.y) * e), (this.z += (t.z - this.z) * e), this
        }
        lerpVectors(t, e, i) {
          return (
            (this.x = t.x + (e.x - t.x) * i), (this.y = t.y + (e.y - t.y) * i), (this.z = t.z + (e.z - t.z) * i), this
          )
        }
        cross(t, e) {
          return void 0 !== e ? this.crossVectors(t, e) : this.crossVectors(this, t)
        }
        crossVectors(t, e) {
          const i = t.x,
            n = t.y,
            s = t.z,
            r = e.x,
            a = e.y,
            o = e.z
          return (this.x = n * o - s * a), (this.y = s * r - i * o), (this.z = i * a - n * r), this
        }
        projectOnVector(t) {
          const e = t.lengthSq()
          if (0 === e) return this.set(0, 0, 0)
          const i = t.dot(this) / e
          return this.copy(t).multiplyScalar(i)
        }
        projectOnPlane(t) {
          return bt.copy(this).projectOnVector(t), this.sub(bt)
        }
        reflect(t) {
          return this.sub(bt.copy(t).multiplyScalar(2 * this.dot(t)))
        }
        angleTo(t) {
          const e = Math.sqrt(this.lengthSq() * t.lengthSq())
          if (0 === e) return Math.PI / 2
          const i = this.dot(t) / e
          return Math.acos(lt(i, -1, 1))
        }
        distanceTo(t) {
          return Math.sqrt(this.distanceToSquared(t))
        }
        distanceToSquared(t) {
          const e = this.x - t.x,
            i = this.y - t.y,
            n = this.z - t.z
          return e * e + i * i + n * n
        }
        manhattanDistanceTo(t) {
          return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
        }
        setFromSpherical(t) {
          return this.setFromSphericalCoords(t.radius, t.phi, t.theta)
        }
        setFromSphericalCoords(t, e, i) {
          const n = Math.sin(e) * t
          return (this.x = n * Math.sin(i)), (this.y = Math.cos(e) * t), (this.z = n * Math.cos(i)), this
        }
        setFromCylindrical(t) {
          return this.setFromCylindricalCoords(t.radius, t.theta, t.y)
        }
        setFromCylindricalCoords(t, e, i) {
          return (this.x = t * Math.sin(e)), (this.y = i), (this.z = t * Math.cos(e)), this
        }
        setFromMatrixPosition(t) {
          const e = t.elements
          return (this.x = e[12]), (this.y = e[13]), (this.z = e[14]), this
        }
        setFromMatrixScale(t) {
          const e = this.setFromMatrixColumn(t, 0).length(),
            i = this.setFromMatrixColumn(t, 1).length(),
            n = this.setFromMatrixColumn(t, 2).length()
          return (this.x = e), (this.y = i), (this.z = n), this
        }
        setFromMatrixColumn(t, e) {
          return this.fromArray(t.elements, 4 * e)
        }
        setFromMatrix3Column(t, e) {
          return this.fromArray(t.elements, 3 * e)
        }
        equals(t) {
          return t.x === this.x && t.y === this.y && t.z === this.z
        }
        fromArray(t, e = 0) {
          return (this.x = t[e]), (this.y = t[e + 1]), (this.z = t[e + 2]), this
        }
        toArray(t = [], e = 0) {
          return (t[e] = this.x), (t[e + 1] = this.y), (t[e + 2] = this.z), t
        }
        fromBufferAttribute(t, e, i) {
          return (this.x = t.getX(e)), (this.y = t.getY(e)), (this.z = t.getZ(e)), this
        }
        random() {
          return (this.x = Math.random()), (this.y = Math.random()), (this.z = Math.random()), this
        }
      }
      Et.prototype.isVector3 = !0
      const bt = new Et(),
        St = new Mt()
      class Bt {
        constructor(t = new Et(1 / 0, 1 / 0, 1 / 0), e = new Et(-1 / 0, -1 / 0, -1 / 0)) {
          ;(this.min = t), (this.max = e)
        }
        set(t, e) {
          return this.min.copy(t), this.max.copy(e), this
        }
        setFromArray(t) {
          let e = 1 / 0,
            i = 1 / 0,
            n = 1 / 0,
            s = -1 / 0,
            r = -1 / 0,
            a = -1 / 0
          for (let o = 0, l = t.length; o < l; o += 3) {
            const l = t[o],
              c = t[o + 1],
              h = t[o + 2]
            l < e && (e = l), c < i && (i = c), h < n && (n = h), l > s && (s = l), c > r && (r = c), h > a && (a = h)
          }
          return this.min.set(e, i, n), this.max.set(s, r, a), this
        }
        setFromBufferAttribute(t) {
          let e = 1 / 0,
            i = 1 / 0,
            n = 1 / 0,
            s = -1 / 0,
            r = -1 / 0,
            a = -1 / 0
          for (let o = 0, l = t.count; o < l; o++) {
            const l = t.getX(o),
              c = t.getY(o),
              h = t.getZ(o)
            l < e && (e = l), c < i && (i = c), h < n && (n = h), l > s && (s = l), c > r && (r = c), h > a && (a = h)
          }
          return this.min.set(e, i, n), this.max.set(s, r, a), this
        }
        setFromPoints(t) {
          this.makeEmpty()
          for (let e = 0, i = t.length; e < i; e++) this.expandByPoint(t[e])
          return this
        }
        setFromCenterAndSize(t, e) {
          const i = Lt.copy(e).multiplyScalar(0.5)
          return this.min.copy(t).sub(i), this.max.copy(t).add(i), this
        }
        setFromObject(t) {
          return this.makeEmpty(), this.expandByObject(t)
        }
        clone() {
          return new this.constructor().copy(this)
        }
        copy(t) {
          return this.min.copy(t.min), this.max.copy(t.max), this
        }
        makeEmpty() {
          return (this.min.x = this.min.y = this.min.z = 1 / 0), (this.max.x = this.max.y = this.max.z = -1 / 0), this
        }
        isEmpty() {
          return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
        }
        getCenter(t) {
          return this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(0.5)
        }
        getSize(t) {
          return this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min)
        }
        expandByPoint(t) {
          return this.min.min(t), this.max.max(t), this
        }
        expandByVector(t) {
          return this.min.sub(t), this.max.add(t), this
        }
        expandByScalar(t) {
          return this.min.addScalar(-t), this.max.addScalar(t), this
        }
        expandByObject(t) {
          t.updateWorldMatrix(!1, !1)
          const e = t.geometry
          void 0 !== e &&
            (null === e.boundingBox && e.computeBoundingBox(),
            Dt.copy(e.boundingBox),
            Dt.applyMatrix4(t.matrixWorld),
            this.union(Dt))
          const i = t.children
          for (let n = 0, s = i.length; n < s; n++) this.expandByObject(i[n])
          return this
        }
        containsPoint(t) {
          return !(
            t.x < this.min.x ||
            t.x > this.max.x ||
            t.y < this.min.y ||
            t.y > this.max.y ||
            t.z < this.min.z ||
            t.z > this.max.z
          )
        }
        containsBox(t) {
          return (
            this.min.x <= t.min.x &&
            t.max.x <= this.max.x &&
            this.min.y <= t.min.y &&
            t.max.y <= this.max.y &&
            this.min.z <= t.min.z &&
            t.max.z <= this.max.z
          )
        }
        getParameter(t, e) {
          return e.set(
            (t.x - this.min.x) / (this.max.x - this.min.x),
            (t.y - this.min.y) / (this.max.y - this.min.y),
            (t.z - this.min.z) / (this.max.z - this.min.z),
          )
        }
        intersectsBox(t) {
          return !(
            t.max.x < this.min.x ||
            t.min.x > this.max.x ||
            t.max.y < this.min.y ||
            t.min.y > this.max.y ||
            t.max.z < this.min.z ||
            t.min.z > this.max.z
          )
        }
        intersectsSphere(t) {
          return this.clampPoint(t.center, Lt), Lt.distanceToSquared(t.center) <= t.radius * t.radius
        }
        intersectsPlane(t) {
          let e, i
          return (
            t.normal.x > 0
              ? ((e = t.normal.x * this.min.x), (i = t.normal.x * this.max.x))
              : ((e = t.normal.x * this.max.x), (i = t.normal.x * this.min.x)),
            t.normal.y > 0
              ? ((e += t.normal.y * this.min.y), (i += t.normal.y * this.max.y))
              : ((e += t.normal.y * this.max.y), (i += t.normal.y * this.min.y)),
            t.normal.z > 0
              ? ((e += t.normal.z * this.min.z), (i += t.normal.z * this.max.z))
              : ((e += t.normal.z * this.max.z), (i += t.normal.z * this.min.z)),
            e <= -t.constant && i >= -t.constant
          )
        }
        intersectsTriangle(t) {
          if (this.isEmpty()) return !1
          this.getCenter(kt),
            Ot.subVectors(this.max, kt),
            Qt.subVectors(t.a, kt),
            Rt.subVectors(t.b, kt),
            Pt.subVectors(t.c, kt),
            Nt.subVectors(Rt, Qt),
            Ft.subVectors(Pt, Rt),
            Ut.subVectors(Qt, Pt)
          let e = [
            0,
            -Nt.z,
            Nt.y,
            0,
            -Ft.z,
            Ft.y,
            0,
            -Ut.z,
            Ut.y,
            Nt.z,
            0,
            -Nt.x,
            Ft.z,
            0,
            -Ft.x,
            Ut.z,
            0,
            -Ut.x,
            -Nt.y,
            Nt.x,
            0,
            -Ft.y,
            Ft.x,
            0,
            -Ut.y,
            Ut.x,
            0,
          ]
          return (
            !!Vt(e, Qt, Rt, Pt, Ot) &&
            ((e = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
            !!Vt(e, Qt, Rt, Pt, Ot) && (Gt.crossVectors(Nt, Ft), (e = [Gt.x, Gt.y, Gt.z]), Vt(e, Qt, Rt, Pt, Ot)))
          )
        }
        clampPoint(t, e) {
          return e.copy(t).clamp(this.min, this.max)
        }
        distanceToPoint(t) {
          return Lt.copy(t).clamp(this.min, this.max).sub(t).length()
        }
        getBoundingSphere(t) {
          return this.getCenter(t.center), (t.radius = 0.5 * this.getSize(Lt).length()), t
        }
        intersect(t) {
          return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this
        }
        union(t) {
          return this.min.min(t.min), this.max.max(t.max), this
        }
        applyMatrix4(t) {
          return (
            this.isEmpty() ||
              (Tt[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t),
              Tt[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t),
              Tt[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t),
              Tt[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t),
              Tt[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t),
              Tt[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t),
              Tt[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t),
              Tt[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t),
              this.setFromPoints(Tt)),
            this
          )
        }
        translate(t) {
          return this.min.add(t), this.max.add(t), this
        }
        equals(t) {
          return t.min.equals(this.min) && t.max.equals(this.max)
        }
      }
      Bt.prototype.isBox3 = !0
      const Tt = [new Et(), new Et(), new Et(), new Et(), new Et(), new Et(), new Et(), new Et()],
        Lt = new Et(),
        Dt = new Bt(),
        Qt = new Et(),
        Rt = new Et(),
        Pt = new Et(),
        Nt = new Et(),
        Ft = new Et(),
        Ut = new Et(),
        kt = new Et(),
        Ot = new Et(),
        Gt = new Et(),
        zt = new Et()
      function Vt(t, e, i, n, s) {
        for (let r = 0, a = t.length - 3; r <= a; r += 3) {
          zt.fromArray(t, r)
          const a = s.x * Math.abs(zt.x) + s.y * Math.abs(zt.y) + s.z * Math.abs(zt.z),
            o = e.dot(zt),
            l = i.dot(zt),
            c = n.dot(zt)
          if (Math.max(-Math.max(o, l, c), Math.min(o, l, c)) > a) return !1
        }
        return !0
      }
      const Ht = new Bt(),
        Wt = new Et(),
        qt = new Et(),
        jt = new Et()
      class Yt {
        constructor(t = new Et(), e = -1) {
          ;(this.center = t), (this.radius = e)
        }
        set(t, e) {
          return this.center.copy(t), (this.radius = e), this
        }
        setFromPoints(t, e) {
          const i = this.center
          void 0 !== e ? i.copy(e) : Ht.setFromPoints(t).getCenter(i)
          let n = 0
          for (let s = 0, r = t.length; s < r; s++) n = Math.max(n, i.distanceToSquared(t[s]))
          return (this.radius = Math.sqrt(n)), this
        }
        copy(t) {
          return this.center.copy(t.center), (this.radius = t.radius), this
        }
        isEmpty() {
          return this.radius < 0
        }
        makeEmpty() {
          return this.center.set(0, 0, 0), (this.radius = -1), this
        }
        containsPoint(t) {
          return t.distanceToSquared(this.center) <= this.radius * this.radius
        }
        distanceToPoint(t) {
          return t.distanceTo(this.center) - this.radius
        }
        intersectsSphere(t) {
          const e = this.radius + t.radius
          return t.center.distanceToSquared(this.center) <= e * e
        }
        intersectsBox(t) {
          return t.intersectsSphere(this)
        }
        intersectsPlane(t) {
          return Math.abs(t.distanceToPoint(this.center)) <= this.radius
        }
        clampPoint(t, e) {
          const i = this.center.distanceToSquared(t)
          return (
            e.copy(t),
            i > this.radius * this.radius &&
              (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)),
            e
          )
        }
        getBoundingBox(t) {
          return this.isEmpty()
            ? (t.makeEmpty(), t)
            : (t.set(this.center, this.center), t.expandByScalar(this.radius), t)
        }
        applyMatrix4(t) {
          return this.center.applyMatrix4(t), (this.radius = this.radius * t.getMaxScaleOnAxis()), this
        }
        translate(t) {
          return this.center.add(t), this
        }
        expandByPoint(t) {
          jt.subVectors(t, this.center)
          const e = jt.lengthSq()
          if (e > this.radius * this.radius) {
            const t = Math.sqrt(e),
              i = 0.5 * (t - this.radius)
            this.center.add(jt.multiplyScalar(i / t)), (this.radius += i)
          }
          return this
        }
        union(t) {
          return (
            qt.subVectors(t.center, this.center).normalize().multiplyScalar(t.radius),
            this.expandByPoint(Wt.copy(t.center).add(qt)),
            this.expandByPoint(Wt.copy(t.center).sub(qt)),
            this
          )
        }
        equals(t) {
          return t.center.equals(this.center) && t.radius === this.radius
        }
        clone() {
          return new this.constructor().copy(this)
        }
      }
      const Jt = new Et(),
        Xt = new Et(),
        Kt = new Et(),
        Zt = new Et(),
        $t = new Et(),
        te = new Et(),
        ee = new Et()
      class ie {
        constructor(t = new Et(), e = new Et(0, 0, -1)) {
          ;(this.origin = t), (this.direction = e)
        }
        set(t, e) {
          return this.origin.copy(t), this.direction.copy(e), this
        }
        copy(t) {
          return this.origin.copy(t.origin), this.direction.copy(t.direction), this
        }
        at(t, e) {
          return e.copy(this.direction).multiplyScalar(t).add(this.origin)
        }
        lookAt(t) {
          return this.direction.copy(t).sub(this.origin).normalize(), this
        }
        recast(t) {
          return this.origin.copy(this.at(t, Jt)), this
        }
        closestPointToPoint(t, e) {
          e.subVectors(t, this.origin)
          const i = e.dot(this.direction)
          return i < 0 ? e.copy(this.origin) : e.copy(this.direction).multiplyScalar(i).add(this.origin)
        }
        distanceToPoint(t) {
          return Math.sqrt(this.distanceSqToPoint(t))
        }
        distanceSqToPoint(t) {
          const e = Jt.subVectors(t, this.origin).dot(this.direction)
          return e < 0
            ? this.origin.distanceToSquared(t)
            : (Jt.copy(this.direction).multiplyScalar(e).add(this.origin), Jt.distanceToSquared(t))
        }
        distanceSqToSegment(t, e, i, n) {
          Xt.copy(t).add(e).multiplyScalar(0.5), Kt.copy(e).sub(t).normalize(), Zt.copy(this.origin).sub(Xt)
          const s = 0.5 * t.distanceTo(e),
            r = -this.direction.dot(Kt),
            a = Zt.dot(this.direction),
            o = -Zt.dot(Kt),
            l = Zt.lengthSq(),
            c = Math.abs(1 - r * r)
          let h, u, d, p
          if (c > 0)
            if (((h = r * o - a), (u = r * a - o), (p = s * c), h >= 0))
              if (u >= -p)
                if (u <= p) {
                  const t = 1 / c
                  ;(h *= t), (u *= t), (d = h * (h + r * u + 2 * a) + u * (r * h + u + 2 * o) + l)
                } else (u = s), (h = Math.max(0, -(r * u + a))), (d = -h * h + u * (u + 2 * o) + l)
              else (u = -s), (h = Math.max(0, -(r * u + a))), (d = -h * h + u * (u + 2 * o) + l)
            else
              u <= -p
                ? ((h = Math.max(0, -(-r * s + a))),
                  (u = h > 0 ? -s : Math.min(Math.max(-s, -o), s)),
                  (d = -h * h + u * (u + 2 * o) + l))
                : u <= p
                ? ((h = 0), (u = Math.min(Math.max(-s, -o), s)), (d = u * (u + 2 * o) + l))
                : ((h = Math.max(0, -(r * s + a))),
                  (u = h > 0 ? s : Math.min(Math.max(-s, -o), s)),
                  (d = -h * h + u * (u + 2 * o) + l))
          else (u = r > 0 ? -s : s), (h = Math.max(0, -(r * u + a))), (d = -h * h + u * (u + 2 * o) + l)
          return (
            i && i.copy(this.direction).multiplyScalar(h).add(this.origin), n && n.copy(Kt).multiplyScalar(u).add(Xt), d
          )
        }
        intersectSphere(t, e) {
          Jt.subVectors(t.center, this.origin)
          const i = Jt.dot(this.direction),
            n = Jt.dot(Jt) - i * i,
            s = t.radius * t.radius
          if (n > s) return null
          const r = Math.sqrt(s - n),
            a = i - r,
            o = i + r
          return a < 0 && o < 0 ? null : a < 0 ? this.at(o, e) : this.at(a, e)
        }
        intersectsSphere(t) {
          return this.distanceSqToPoint(t.center) <= t.radius * t.radius
        }
        distanceToPlane(t) {
          const e = t.normal.dot(this.direction)
          if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null
          const i = -(this.origin.dot(t.normal) + t.constant) / e
          return i >= 0 ? i : null
        }
        intersectPlane(t, e) {
          const i = this.distanceToPlane(t)
          return null === i ? null : this.at(i, e)
        }
        intersectsPlane(t) {
          const e = t.distanceToPoint(this.origin)
          return 0 === e || t.normal.dot(this.direction) * e < 0
        }
        intersectBox(t, e) {
          let i, n, s, r, a, o
          const l = 1 / this.direction.x,
            c = 1 / this.direction.y,
            h = 1 / this.direction.z,
            u = this.origin
          return (
            l >= 0
              ? ((i = (t.min.x - u.x) * l), (n = (t.max.x - u.x) * l))
              : ((i = (t.max.x - u.x) * l), (n = (t.min.x - u.x) * l)),
            c >= 0
              ? ((s = (t.min.y - u.y) * c), (r = (t.max.y - u.y) * c))
              : ((s = (t.max.y - u.y) * c), (r = (t.min.y - u.y) * c)),
            i > r || s > n
              ? null
              : ((s > i || i != i) && (i = s),
                (r < n || n != n) && (n = r),
                h >= 0
                  ? ((a = (t.min.z - u.z) * h), (o = (t.max.z - u.z) * h))
                  : ((a = (t.max.z - u.z) * h), (o = (t.min.z - u.z) * h)),
                i > o || a > n
                  ? null
                  : ((a > i || i != i) && (i = a),
                    (o < n || n != n) && (n = o),
                    n < 0 ? null : this.at(i >= 0 ? i : n, e)))
          )
        }
        intersectsBox(t) {
          return null !== this.intersectBox(t, Jt)
        }
        intersectTriangle(t, e, i, n, s) {
          $t.subVectors(e, t), te.subVectors(i, t), ee.crossVectors($t, te)
          let r,
            a = this.direction.dot(ee)
          if (a > 0) {
            if (n) return null
            r = 1
          } else {
            if (!(a < 0)) return null
            ;(r = -1), (a = -a)
          }
          Zt.subVectors(this.origin, t)
          const o = r * this.direction.dot(te.crossVectors(Zt, te))
          if (o < 0) return null
          const l = r * this.direction.dot($t.cross(Zt))
          if (l < 0) return null
          if (o + l > a) return null
          const c = -r * Zt.dot(ee)
          return c < 0 ? null : this.at(c / a, s)
        }
        applyMatrix4(t) {
          return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this
        }
        equals(t) {
          return t.origin.equals(this.origin) && t.direction.equals(this.direction)
        }
        clone() {
          return new this.constructor().copy(this)
        }
      }
      class ne {
        constructor() {
          this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]
        }
        set(t, e, i, n, s, r, a, o, l, c, h, u, d, p, A, g) {
          const m = this.elements
          return (
            (m[0] = t),
            (m[4] = e),
            (m[8] = i),
            (m[12] = n),
            (m[1] = s),
            (m[5] = r),
            (m[9] = a),
            (m[13] = o),
            (m[2] = l),
            (m[6] = c),
            (m[10] = h),
            (m[14] = u),
            (m[3] = d),
            (m[7] = p),
            (m[11] = A),
            (m[15] = g),
            this
          )
        }
        identity() {
          return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
        }
        clone() {
          return new ne().fromArray(this.elements)
        }
        copy(t) {
          const e = this.elements,
            i = t.elements
          return (
            (e[0] = i[0]),
            (e[1] = i[1]),
            (e[2] = i[2]),
            (e[3] = i[3]),
            (e[4] = i[4]),
            (e[5] = i[5]),
            (e[6] = i[6]),
            (e[7] = i[7]),
            (e[8] = i[8]),
            (e[9] = i[9]),
            (e[10] = i[10]),
            (e[11] = i[11]),
            (e[12] = i[12]),
            (e[13] = i[13]),
            (e[14] = i[14]),
            (e[15] = i[15]),
            this
          )
        }
        copyPosition(t) {
          const e = this.elements,
            i = t.elements
          return (e[12] = i[12]), (e[13] = i[13]), (e[14] = i[14]), this
        }
        setFromMatrix3(t) {
          const e = t.elements
          return this.set(e[0], e[3], e[6], 0, e[1], e[4], e[7], 0, e[2], e[5], e[8], 0, 0, 0, 0, 1), this
        }
        extractBasis(t, e, i) {
          return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), i.setFromMatrixColumn(this, 2), this
        }
        makeBasis(t, e, i) {
          return this.set(t.x, e.x, i.x, 0, t.y, e.y, i.y, 0, t.z, e.z, i.z, 0, 0, 0, 0, 1), this
        }
        extractRotation(t) {
          const e = this.elements,
            i = t.elements,
            n = 1 / se.setFromMatrixColumn(t, 0).length(),
            s = 1 / se.setFromMatrixColumn(t, 1).length(),
            r = 1 / se.setFromMatrixColumn(t, 2).length()
          return (
            (e[0] = i[0] * n),
            (e[1] = i[1] * n),
            (e[2] = i[2] * n),
            (e[3] = 0),
            (e[4] = i[4] * s),
            (e[5] = i[5] * s),
            (e[6] = i[6] * s),
            (e[7] = 0),
            (e[8] = i[8] * r),
            (e[9] = i[9] * r),
            (e[10] = i[10] * r),
            (e[11] = 0),
            (e[12] = 0),
            (e[13] = 0),
            (e[14] = 0),
            (e[15] = 1),
            this
          )
        }
        makeRotationFromEuler(t) {
          t && t.isEuler
          const e = this.elements,
            i = t.x,
            n = t.y,
            s = t.z,
            r = Math.cos(i),
            a = Math.sin(i),
            o = Math.cos(n),
            l = Math.sin(n),
            c = Math.cos(s),
            h = Math.sin(s)
          if ('XYZ' === t.order) {
            const t = r * c,
              i = r * h,
              n = a * c,
              s = a * h
            ;(e[0] = o * c),
              (e[4] = -o * h),
              (e[8] = l),
              (e[1] = i + n * l),
              (e[5] = t - s * l),
              (e[9] = -a * o),
              (e[2] = s - t * l),
              (e[6] = n + i * l),
              (e[10] = r * o)
          } else if ('YXZ' === t.order) {
            const t = o * c,
              i = o * h,
              n = l * c,
              s = l * h
            ;(e[0] = t + s * a),
              (e[4] = n * a - i),
              (e[8] = r * l),
              (e[1] = r * h),
              (e[5] = r * c),
              (e[9] = -a),
              (e[2] = i * a - n),
              (e[6] = s + t * a),
              (e[10] = r * o)
          } else if ('ZXY' === t.order) {
            const t = o * c,
              i = o * h,
              n = l * c,
              s = l * h
            ;(e[0] = t - s * a),
              (e[4] = -r * h),
              (e[8] = n + i * a),
              (e[1] = i + n * a),
              (e[5] = r * c),
              (e[9] = s - t * a),
              (e[2] = -r * l),
              (e[6] = a),
              (e[10] = r * o)
          } else if ('ZYX' === t.order) {
            const t = r * c,
              i = r * h,
              n = a * c,
              s = a * h
            ;(e[0] = o * c),
              (e[4] = n * l - i),
              (e[8] = t * l + s),
              (e[1] = o * h),
              (e[5] = s * l + t),
              (e[9] = i * l - n),
              (e[2] = -l),
              (e[6] = a * o),
              (e[10] = r * o)
          } else if ('YZX' === t.order) {
            const t = r * o,
              i = r * l,
              n = a * o,
              s = a * l
            ;(e[0] = o * c),
              (e[4] = s - t * h),
              (e[8] = n * h + i),
              (e[1] = h),
              (e[5] = r * c),
              (e[9] = -a * c),
              (e[2] = -l * c),
              (e[6] = i * h + n),
              (e[10] = t - s * h)
          } else if ('XZY' === t.order) {
            const t = r * o,
              i = r * l,
              n = a * o,
              s = a * l
            ;(e[0] = o * c),
              (e[4] = -h),
              (e[8] = l * c),
              (e[1] = t * h + s),
              (e[5] = r * c),
              (e[9] = i * h - n),
              (e[2] = n * h - i),
              (e[6] = a * c),
              (e[10] = s * h + t)
          }
          return (e[3] = 0), (e[7] = 0), (e[11] = 0), (e[12] = 0), (e[13] = 0), (e[14] = 0), (e[15] = 1), this
        }
        makeRotationFromQuaternion(t) {
          return this.compose(ae, t, oe)
        }
        lookAt(t, e, i) {
          const n = this.elements
          return (
            he.subVectors(t, e),
            0 === he.lengthSq() && (he.z = 1),
            he.normalize(),
            le.crossVectors(i, he),
            0 === le.lengthSq() &&
              (1 === Math.abs(i.z) ? (he.x += 1e-4) : (he.z += 1e-4), he.normalize(), le.crossVectors(i, he)),
            le.normalize(),
            ce.crossVectors(he, le),
            (n[0] = le.x),
            (n[4] = ce.x),
            (n[8] = he.x),
            (n[1] = le.y),
            (n[5] = ce.y),
            (n[9] = he.y),
            (n[2] = le.z),
            (n[6] = ce.z),
            (n[10] = he.z),
            this
          )
        }
        multiply(t, e) {
          return void 0 !== e ? this.multiplyMatrices(t, e) : this.multiplyMatrices(this, t)
        }
        premultiply(t) {
          return this.multiplyMatrices(t, this)
        }
        multiplyMatrices(t, e) {
          const i = t.elements,
            n = e.elements,
            s = this.elements,
            r = i[0],
            a = i[4],
            o = i[8],
            l = i[12],
            c = i[1],
            h = i[5],
            u = i[9],
            d = i[13],
            p = i[2],
            A = i[6],
            g = i[10],
            m = i[14],
            f = i[3],
            v = i[7],
            y = i[11],
            x = i[15],
            w = n[0],
            _ = n[4],
            I = n[8],
            C = n[12],
            M = n[1],
            E = n[5],
            b = n[9],
            S = n[13],
            B = n[2],
            T = n[6],
            L = n[10],
            D = n[14],
            Q = n[3],
            R = n[7],
            P = n[11],
            N = n[15]
          return (
            (s[0] = r * w + a * M + o * B + l * Q),
            (s[4] = r * _ + a * E + o * T + l * R),
            (s[8] = r * I + a * b + o * L + l * P),
            (s[12] = r * C + a * S + o * D + l * N),
            (s[1] = c * w + h * M + u * B + d * Q),
            (s[5] = c * _ + h * E + u * T + d * R),
            (s[9] = c * I + h * b + u * L + d * P),
            (s[13] = c * C + h * S + u * D + d * N),
            (s[2] = p * w + A * M + g * B + m * Q),
            (s[6] = p * _ + A * E + g * T + m * R),
            (s[10] = p * I + A * b + g * L + m * P),
            (s[14] = p * C + A * S + g * D + m * N),
            (s[3] = f * w + v * M + y * B + x * Q),
            (s[7] = f * _ + v * E + y * T + x * R),
            (s[11] = f * I + v * b + y * L + x * P),
            (s[15] = f * C + v * S + y * D + x * N),
            this
          )
        }
        multiplyScalar(t) {
          const e = this.elements
          return (
            (e[0] *= t),
            (e[4] *= t),
            (e[8] *= t),
            (e[12] *= t),
            (e[1] *= t),
            (e[5] *= t),
            (e[9] *= t),
            (e[13] *= t),
            (e[2] *= t),
            (e[6] *= t),
            (e[10] *= t),
            (e[14] *= t),
            (e[3] *= t),
            (e[7] *= t),
            (e[11] *= t),
            (e[15] *= t),
            this
          )
        }
        determinant() {
          const t = this.elements,
            e = t[0],
            i = t[4],
            n = t[8],
            s = t[12],
            r = t[1],
            a = t[5],
            o = t[9],
            l = t[13],
            c = t[2],
            h = t[6],
            u = t[10],
            d = t[14]
          return (
            t[3] * (+s * o * h - n * l * h - s * a * u + i * l * u + n * a * d - i * o * d) +
            t[7] * (+e * o * d - e * l * u + s * r * u - n * r * d + n * l * c - s * o * c) +
            t[11] * (+e * l * h - e * a * d - s * r * h + i * r * d + s * a * c - i * l * c) +
            t[15] * (-n * a * c - e * o * h + e * a * u + n * r * h - i * r * u + i * o * c)
          )
        }
        transpose() {
          const t = this.elements
          let e
          return (
            (e = t[1]),
            (t[1] = t[4]),
            (t[4] = e),
            (e = t[2]),
            (t[2] = t[8]),
            (t[8] = e),
            (e = t[6]),
            (t[6] = t[9]),
            (t[9] = e),
            (e = t[3]),
            (t[3] = t[12]),
            (t[12] = e),
            (e = t[7]),
            (t[7] = t[13]),
            (t[13] = e),
            (e = t[11]),
            (t[11] = t[14]),
            (t[14] = e),
            this
          )
        }
        setPosition(t, e, i) {
          const n = this.elements
          return (
            t.isVector3 ? ((n[12] = t.x), (n[13] = t.y), (n[14] = t.z)) : ((n[12] = t), (n[13] = e), (n[14] = i)), this
          )
        }
        invert() {
          const t = this.elements,
            e = t[0],
            i = t[1],
            n = t[2],
            s = t[3],
            r = t[4],
            a = t[5],
            o = t[6],
            l = t[7],
            c = t[8],
            h = t[9],
            u = t[10],
            d = t[11],
            p = t[12],
            A = t[13],
            g = t[14],
            m = t[15],
            f = h * g * l - A * u * l + A * o * d - a * g * d - h * o * m + a * u * m,
            v = p * u * l - c * g * l - p * o * d + r * g * d + c * o * m - r * u * m,
            y = c * A * l - p * h * l + p * a * d - r * A * d - c * a * m + r * h * m,
            x = p * h * o - c * A * o - p * a * u + r * A * u + c * a * g - r * h * g,
            w = e * f + i * v + n * y + s * x
          if (0 === w) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
          const _ = 1 / w
          return (
            (t[0] = f * _),
            (t[1] = (A * u * s - h * g * s - A * n * d + i * g * d + h * n * m - i * u * m) * _),
            (t[2] = (a * g * s - A * o * s + A * n * l - i * g * l - a * n * m + i * o * m) * _),
            (t[3] = (h * o * s - a * u * s - h * n * l + i * u * l + a * n * d - i * o * d) * _),
            (t[4] = v * _),
            (t[5] = (c * g * s - p * u * s + p * n * d - e * g * d - c * n * m + e * u * m) * _),
            (t[6] = (p * o * s - r * g * s - p * n * l + e * g * l + r * n * m - e * o * m) * _),
            (t[7] = (r * u * s - c * o * s + c * n * l - e * u * l - r * n * d + e * o * d) * _),
            (t[8] = y * _),
            (t[9] = (p * h * s - c * A * s - p * i * d + e * A * d + c * i * m - e * h * m) * _),
            (t[10] = (r * A * s - p * a * s + p * i * l - e * A * l - r * i * m + e * a * m) * _),
            (t[11] = (c * a * s - r * h * s - c * i * l + e * h * l + r * i * d - e * a * d) * _),
            (t[12] = x * _),
            (t[13] = (c * A * n - p * h * n + p * i * u - e * A * u - c * i * g + e * h * g) * _),
            (t[14] = (p * a * n - r * A * n - p * i * o + e * A * o + r * i * g - e * a * g) * _),
            (t[15] = (r * h * n - c * a * n + c * i * o - e * h * o - r * i * u + e * a * u) * _),
            this
          )
        }
        scale(t) {
          const e = this.elements,
            i = t.x,
            n = t.y,
            s = t.z
          return (
            (e[0] *= i),
            (e[4] *= n),
            (e[8] *= s),
            (e[1] *= i),
            (e[5] *= n),
            (e[9] *= s),
            (e[2] *= i),
            (e[6] *= n),
            (e[10] *= s),
            (e[3] *= i),
            (e[7] *= n),
            (e[11] *= s),
            this
          )
        }
        getMaxScaleOnAxis() {
          const t = this.elements,
            e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
            i = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
            n = t[8] * t[8] + t[9] * t[9] + t[10] * t[10]
          return Math.sqrt(Math.max(e, i, n))
        }
        makeTranslation(t, e, i) {
          return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, i, 0, 0, 0, 1), this
        }
        makeRotationX(t) {
          const e = Math.cos(t),
            i = Math.sin(t)
          return this.set(1, 0, 0, 0, 0, e, -i, 0, 0, i, e, 0, 0, 0, 0, 1), this
        }
        makeRotationY(t) {
          const e = Math.cos(t),
            i = Math.sin(t)
          return this.set(e, 0, i, 0, 0, 1, 0, 0, -i, 0, e, 0, 0, 0, 0, 1), this
        }
        makeRotationZ(t) {
          const e = Math.cos(t),
            i = Math.sin(t)
          return this.set(e, -i, 0, 0, i, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
        }
        makeRotationAxis(t, e) {
          const i = Math.cos(e),
            n = Math.sin(e),
            s = 1 - i,
            r = t.x,
            a = t.y,
            o = t.z,
            l = s * r,
            c = s * a
          return (
            this.set(
              l * r + i,
              l * a - n * o,
              l * o + n * a,
              0,
              l * a + n * o,
              c * a + i,
              c * o - n * r,
              0,
              l * o - n * a,
              c * o + n * r,
              s * o * o + i,
              0,
              0,
              0,
              0,
              1,
            ),
            this
          )
        }
        makeScale(t, e, i) {
          return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this
        }
        makeShear(t, e, i, n, s, r) {
          return this.set(1, i, s, 0, t, 1, r, 0, e, n, 1, 0, 0, 0, 0, 1), this
        }
        compose(t, e, i) {
          const n = this.elements,
            s = e._x,
            r = e._y,
            a = e._z,
            o = e._w,
            l = s + s,
            c = r + r,
            h = a + a,
            u = s * l,
            d = s * c,
            p = s * h,
            A = r * c,
            g = r * h,
            m = a * h,
            f = o * l,
            v = o * c,
            y = o * h,
            x = i.x,
            w = i.y,
            _ = i.z
          return (
            (n[0] = (1 - (A + m)) * x),
            (n[1] = (d + y) * x),
            (n[2] = (p - v) * x),
            (n[3] = 0),
            (n[4] = (d - y) * w),
            (n[5] = (1 - (u + m)) * w),
            (n[6] = (g + f) * w),
            (n[7] = 0),
            (n[8] = (p + v) * _),
            (n[9] = (g - f) * _),
            (n[10] = (1 - (u + A)) * _),
            (n[11] = 0),
            (n[12] = t.x),
            (n[13] = t.y),
            (n[14] = t.z),
            (n[15] = 1),
            this
          )
        }
        decompose(t, e, i) {
          const n = this.elements
          let s = se.set(n[0], n[1], n[2]).length()
          const r = se.set(n[4], n[5], n[6]).length(),
            a = se.set(n[8], n[9], n[10]).length()
          this.determinant() < 0 && (s = -s), (t.x = n[12]), (t.y = n[13]), (t.z = n[14]), re.copy(this)
          const o = 1 / s,
            l = 1 / r,
            c = 1 / a
          return (
            (re.elements[0] *= o),
            (re.elements[1] *= o),
            (re.elements[2] *= o),
            (re.elements[4] *= l),
            (re.elements[5] *= l),
            (re.elements[6] *= l),
            (re.elements[8] *= c),
            (re.elements[9] *= c),
            (re.elements[10] *= c),
            e.setFromRotationMatrix(re),
            (i.x = s),
            (i.y = r),
            (i.z = a),
            this
          )
        }
        makePerspective(t, e, i, n, s, r) {
          const a = this.elements,
            o = (2 * s) / (e - t),
            l = (2 * s) / (i - n),
            c = (e + t) / (e - t),
            h = (i + n) / (i - n),
            u = -(r + s) / (r - s),
            d = (-2 * r * s) / (r - s)
          return (
            (a[0] = o),
            (a[4] = 0),
            (a[8] = c),
            (a[12] = 0),
            (a[1] = 0),
            (a[5] = l),
            (a[9] = h),
            (a[13] = 0),
            (a[2] = 0),
            (a[6] = 0),
            (a[10] = u),
            (a[14] = d),
            (a[3] = 0),
            (a[7] = 0),
            (a[11] = -1),
            (a[15] = 0),
            this
          )
        }
        makeOrthographic(t, e, i, n, s, r) {
          const a = this.elements,
            o = 1 / (e - t),
            l = 1 / (i - n),
            c = 1 / (r - s),
            h = (e + t) * o,
            u = (i + n) * l,
            d = (r + s) * c
          return (
            (a[0] = 2 * o),
            (a[4] = 0),
            (a[8] = 0),
            (a[12] = -h),
            (a[1] = 0),
            (a[5] = 2 * l),
            (a[9] = 0),
            (a[13] = -u),
            (a[2] = 0),
            (a[6] = 0),
            (a[10] = -2 * c),
            (a[14] = -d),
            (a[3] = 0),
            (a[7] = 0),
            (a[11] = 0),
            (a[15] = 1),
            this
          )
        }
        equals(t) {
          const e = this.elements,
            i = t.elements
          for (let n = 0; n < 16; n++) if (e[n] !== i[n]) return !1
          return !0
        }
        fromArray(t, e = 0) {
          for (let i = 0; i < 16; i++) this.elements[i] = t[i + e]
          return this
        }
        toArray(t = [], e = 0) {
          const i = this.elements
          return (
            (t[e] = i[0]),
            (t[e + 1] = i[1]),
            (t[e + 2] = i[2]),
            (t[e + 3] = i[3]),
            (t[e + 4] = i[4]),
            (t[e + 5] = i[5]),
            (t[e + 6] = i[6]),
            (t[e + 7] = i[7]),
            (t[e + 8] = i[8]),
            (t[e + 9] = i[9]),
            (t[e + 10] = i[10]),
            (t[e + 11] = i[11]),
            (t[e + 12] = i[12]),
            (t[e + 13] = i[13]),
            (t[e + 14] = i[14]),
            (t[e + 15] = i[15]),
            t
          )
        }
      }
      ne.prototype.isMatrix4 = !0
      const se = new Et(),
        re = new ne(),
        ae = new Et(0, 0, 0),
        oe = new Et(1, 1, 1),
        le = new Et(),
        ce = new Et(),
        he = new Et(),
        ue = new ne(),
        de = new Mt()
      class pe {
        constructor(t = 0, e = 0, i = 0, n = pe.DefaultOrder) {
          ;(this._x = t), (this._y = e), (this._z = i), (this._order = n)
        }
        get x() {
          return this._x
        }
        set x(t) {
          ;(this._x = t), this._onChangeCallback()
        }
        get y() {
          return this._y
        }
        set y(t) {
          ;(this._y = t), this._onChangeCallback()
        }
        get z() {
          return this._z
        }
        set z(t) {
          ;(this._z = t), this._onChangeCallback()
        }
        get order() {
          return this._order
        }
        set order(t) {
          ;(this._order = t), this._onChangeCallback()
        }
        set(t, e, i, n = this._order) {
          return (this._x = t), (this._y = e), (this._z = i), (this._order = n), this._onChangeCallback(), this
        }
        clone() {
          return new this.constructor(this._x, this._y, this._z, this._order)
        }
        copy(t) {
          return (
            (this._x = t._x),
            (this._y = t._y),
            (this._z = t._z),
            (this._order = t._order),
            this._onChangeCallback(),
            this
          )
        }
        setFromRotationMatrix(t, e = this._order, i = !0) {
          const n = t.elements,
            s = n[0],
            r = n[4],
            a = n[8],
            o = n[1],
            l = n[5],
            c = n[9],
            h = n[2],
            u = n[6],
            d = n[10]
          switch (e) {
            case 'XYZ':
              ;(this._y = Math.asin(lt(a, -1, 1))),
                Math.abs(a) < 0.9999999
                  ? ((this._x = Math.atan2(-c, d)), (this._z = Math.atan2(-r, s)))
                  : ((this._x = Math.atan2(u, l)), (this._z = 0))
              break
            case 'YXZ':
              ;(this._x = Math.asin(-lt(c, -1, 1))),
                Math.abs(c) < 0.9999999
                  ? ((this._y = Math.atan2(a, d)), (this._z = Math.atan2(o, l)))
                  : ((this._y = Math.atan2(-h, s)), (this._z = 0))
              break
            case 'ZXY':
              ;(this._x = Math.asin(lt(u, -1, 1))),
                Math.abs(u) < 0.9999999
                  ? ((this._y = Math.atan2(-h, d)), (this._z = Math.atan2(-r, l)))
                  : ((this._y = 0), (this._z = Math.atan2(o, s)))
              break
            case 'ZYX':
              ;(this._y = Math.asin(-lt(h, -1, 1))),
                Math.abs(h) < 0.9999999
                  ? ((this._x = Math.atan2(u, d)), (this._z = Math.atan2(o, s)))
                  : ((this._x = 0), (this._z = Math.atan2(-r, l)))
              break
            case 'YZX':
              ;(this._z = Math.asin(lt(o, -1, 1))),
                Math.abs(o) < 0.9999999
                  ? ((this._x = Math.atan2(-c, l)), (this._y = Math.atan2(-h, s)))
                  : ((this._x = 0), (this._y = Math.atan2(a, d)))
              break
            case 'XZY':
              ;(this._z = Math.asin(-lt(r, -1, 1))),
                Math.abs(r) < 0.9999999
                  ? ((this._x = Math.atan2(u, l)), (this._y = Math.atan2(a, s)))
                  : ((this._x = Math.atan2(-c, d)), (this._y = 0))
          }
          return (this._order = e), !0 === i && this._onChangeCallback(), this
        }
        setFromQuaternion(t, e, i) {
          return ue.makeRotationFromQuaternion(t), this.setFromRotationMatrix(ue, e, i)
        }
        setFromVector3(t, e = this._order) {
          return this.set(t.x, t.y, t.z, e)
        }
        reorder(t) {
          return de.setFromEuler(this), this.setFromQuaternion(de, t)
        }
        equals(t) {
          return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order
        }
        fromArray(t) {
          return (
            (this._x = t[0]),
            (this._y = t[1]),
            (this._z = t[2]),
            void 0 !== t[3] && (this._order = t[3]),
            this._onChangeCallback(),
            this
          )
        }
        toArray(t = [], e = 0) {
          return (t[e] = this._x), (t[e + 1] = this._y), (t[e + 2] = this._z), (t[e + 3] = this._order), t
        }
        toVector3(t) {
          return t ? t.set(this._x, this._y, this._z) : new Et(this._x, this._y, this._z)
        }
        _onChange(t) {
          return (this._onChangeCallback = t), this
        }
        _onChangeCallback() {}
      }
      ;(pe.prototype.isEuler = !0),
        (pe.DefaultOrder = 'XYZ'),
        (pe.RotationOrders = ['XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX'])
      class Ae {
        constructor() {
          this.mask = 1
        }
        set(t) {
          this.mask = (1 << t) | 0
        }
        enable(t) {
          this.mask |= (1 << t) | 0
        }
        enableAll() {
          this.mask = -1
        }
        toggle(t) {
          this.mask ^= (1 << t) | 0
        }
        disable(t) {
          this.mask &= ~((1 << t) | 0)
        }
        disableAll() {
          this.mask = 0
        }
        test(t) {
          return 0 != (this.mask & t.mask)
        }
      }
      let ge = 0
      const me = new Et(),
        fe = new Mt(),
        ve = new ne(),
        ye = new Et(),
        xe = new Et(),
        we = new Et(),
        _e = new Mt(),
        Ie = new Et(1, 0, 0),
        Ce = new Et(0, 1, 0),
        Me = new Et(0, 0, 1),
        Ee = { type: 'added' },
        be = { type: 'removed' }
      class Se extends it {
        constructor() {
          super(),
            Object.defineProperty(this, 'id', { value: ge++ }),
            (this.uuid = ot()),
            (this.name = ''),
            (this.type = 'Object3D'),
            (this.parent = null),
            (this.children = []),
            (this.up = Se.DefaultUp.clone())
          const t = new Et(),
            e = new pe(),
            i = new Mt(),
            n = new Et(1, 1, 1)
          e._onChange(function () {
            i.setFromEuler(e, !1)
          }),
            i._onChange(function () {
              e.setFromQuaternion(i, void 0, !1)
            }),
            Object.defineProperties(this, {
              position: { configurable: !0, enumerable: !0, value: t },
              rotation: { configurable: !0, enumerable: !0, value: e },
              quaternion: { configurable: !0, enumerable: !0, value: i },
              scale: { configurable: !0, enumerable: !0, value: n },
              modelViewMatrix: { value: new ne() },
              normalMatrix: { value: new mt() },
            }),
            (this.matrix = new ne()),
            (this.matrixWorld = new ne()),
            (this.matrixAutoUpdate = Se.DefaultMatrixAutoUpdate),
            (this.matrixWorldNeedsUpdate = !1),
            (this.layers = new Ae()),
            (this.visible = !0),
            (this.castShadow = !1),
            (this.receiveShadow = !1),
            (this.frustumCulled = !0),
            (this.renderOrder = 0),
            (this.animations = []),
            (this.userData = {})
        }
        onBeforeRender() {}
        onAfterRender() {}
        applyMatrix4(t) {
          this.matrixAutoUpdate && this.updateMatrix(),
            this.matrix.premultiply(t),
            this.matrix.decompose(this.position, this.quaternion, this.scale)
        }
        applyQuaternion(t) {
          return this.quaternion.premultiply(t), this
        }
        setRotationFromAxisAngle(t, e) {
          this.quaternion.setFromAxisAngle(t, e)
        }
        setRotationFromEuler(t) {
          this.quaternion.setFromEuler(t, !0)
        }
        setRotationFromMatrix(t) {
          this.quaternion.setFromRotationMatrix(t)
        }
        setRotationFromQuaternion(t) {
          this.quaternion.copy(t)
        }
        rotateOnAxis(t, e) {
          return fe.setFromAxisAngle(t, e), this.quaternion.multiply(fe), this
        }
        rotateOnWorldAxis(t, e) {
          return fe.setFromAxisAngle(t, e), this.quaternion.premultiply(fe), this
        }
        rotateX(t) {
          return this.rotateOnAxis(Ie, t)
        }
        rotateY(t) {
          return this.rotateOnAxis(Ce, t)
        }
        rotateZ(t) {
          return this.rotateOnAxis(Me, t)
        }
        translateOnAxis(t, e) {
          return me.copy(t).applyQuaternion(this.quaternion), this.position.add(me.multiplyScalar(e)), this
        }
        translateX(t) {
          return this.translateOnAxis(Ie, t)
        }
        translateY(t) {
          return this.translateOnAxis(Ce, t)
        }
        translateZ(t) {
          return this.translateOnAxis(Me, t)
        }
        localToWorld(t) {
          return t.applyMatrix4(this.matrixWorld)
        }
        worldToLocal(t) {
          return t.applyMatrix4(ve.copy(this.matrixWorld).invert())
        }
        lookAt(t, e, i) {
          t.isVector3 ? ye.copy(t) : ye.set(t, e, i)
          const n = this.parent
          this.updateWorldMatrix(!0, !1),
            xe.setFromMatrixPosition(this.matrixWorld),
            this.isCamera || this.isLight ? ve.lookAt(xe, ye, this.up) : ve.lookAt(ye, xe, this.up),
            this.quaternion.setFromRotationMatrix(ve),
            n &&
              (ve.extractRotation(n.matrixWorld),
              fe.setFromRotationMatrix(ve),
              this.quaternion.premultiply(fe.invert()))
        }
        add(t) {
          if (arguments.length > 1) {
            for (let t = 0; t < arguments.length; t++) this.add(arguments[t])
            return this
          }
          return (
            t === this ||
              (t &&
                t.isObject3D &&
                (null !== t.parent && t.parent.remove(t),
                (t.parent = this),
                this.children.push(t),
                t.dispatchEvent(Ee))),
            this
          )
        }
        remove(t) {
          if (arguments.length > 1) {
            for (let t = 0; t < arguments.length; t++) this.remove(arguments[t])
            return this
          }
          const e = this.children.indexOf(t)
          return -1 !== e && ((t.parent = null), this.children.splice(e, 1), t.dispatchEvent(be)), this
        }
        removeFromParent() {
          const t = this.parent
          return null !== t && t.remove(this), this
        }
        clear() {
          for (let t = 0; t < this.children.length; t++) {
            const e = this.children[t]
            ;(e.parent = null), e.dispatchEvent(be)
          }
          return (this.children.length = 0), this
        }
        attach(t) {
          return (
            this.updateWorldMatrix(!0, !1),
            ve.copy(this.matrixWorld).invert(),
            null !== t.parent && (t.parent.updateWorldMatrix(!0, !1), ve.multiply(t.parent.matrixWorld)),
            t.applyMatrix4(ve),
            this.add(t),
            t.updateWorldMatrix(!1, !0),
            this
          )
        }
        getObjectById(t) {
          return this.getObjectByProperty('id', t)
        }
        getObjectByName(t) {
          return this.getObjectByProperty('name', t)
        }
        getObjectByProperty(t, e) {
          if (this[t] === e) return this
          for (let i = 0, n = this.children.length; i < n; i++) {
            const n = this.children[i].getObjectByProperty(t, e)
            if (void 0 !== n) return n
          }
        }
        getWorldPosition(t) {
          return this.updateWorldMatrix(!0, !1), t.setFromMatrixPosition(this.matrixWorld)
        }
        getWorldQuaternion(t) {
          return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(xe, t, we), t
        }
        getWorldScale(t) {
          return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(xe, _e, t), t
        }
        getWorldDirection(t) {
          this.updateWorldMatrix(!0, !1)
          const e = this.matrixWorld.elements
          return t.set(e[8], e[9], e[10]).normalize()
        }
        raycast() {}
        traverse(t) {
          t(this)
          const e = this.children
          for (let i = 0, n = e.length; i < n; i++) e[i].traverse(t)
        }
        traverseVisible(t) {
          if (!1 === this.visible) return
          t(this)
          const e = this.children
          for (let i = 0, n = e.length; i < n; i++) e[i].traverseVisible(t)
        }
        traverseAncestors(t) {
          const e = this.parent
          null !== e && (t(e), e.traverseAncestors(t))
        }
        updateMatrix() {
          this.matrix.compose(this.position, this.quaternion, this.scale), (this.matrixWorldNeedsUpdate = !0)
        }
        updateMatrixWorld(t) {
          this.matrixAutoUpdate && this.updateMatrix(),
            (this.matrixWorldNeedsUpdate || t) &&
              (null === this.parent
                ? this.matrixWorld.copy(this.matrix)
                : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
              (this.matrixWorldNeedsUpdate = !1),
              (t = !0))
          const e = this.children
          for (let i = 0, n = e.length; i < n; i++) e[i].updateMatrixWorld(t)
        }
        updateWorldMatrix(t, e) {
          const i = this.parent
          if (
            (!0 === t && null !== i && i.updateWorldMatrix(!0, !1),
            this.matrixAutoUpdate && this.updateMatrix(),
            null === this.parent
              ? this.matrixWorld.copy(this.matrix)
              : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
            !0 === e)
          ) {
            const t = this.children
            for (let e = 0, i = t.length; e < i; e++) t[e].updateWorldMatrix(!1, !0)
          }
        }
        toJSON(t) {
          const e = void 0 === t || 'string' == typeof t,
            i = {}
          e &&
            ((t = {
              geometries: {},
              materials: {},
              textures: {},
              images: {},
              shapes: {},
              skeletons: {},
              animations: {},
            }),
            (i.metadata = { version: 4.5, type: 'Object', generator: 'Object3D.toJSON' }))
          const n = {}
          function s(e, i) {
            return void 0 === e[i.uuid] && (e[i.uuid] = i.toJSON(t)), i.uuid
          }
          if (
            ((n.uuid = this.uuid),
            (n.type = this.type),
            '' !== this.name && (n.name = this.name),
            !0 === this.castShadow && (n.castShadow = !0),
            !0 === this.receiveShadow && (n.receiveShadow = !0),
            !1 === this.visible && (n.visible = !1),
            !1 === this.frustumCulled && (n.frustumCulled = !1),
            0 !== this.renderOrder && (n.renderOrder = this.renderOrder),
            '{}' !== JSON.stringify(this.userData) && (n.userData = this.userData),
            (n.layers = this.layers.mask),
            (n.matrix = this.matrix.toArray()),
            !1 === this.matrixAutoUpdate && (n.matrixAutoUpdate = !1),
            this.isInstancedMesh &&
              ((n.type = 'InstancedMesh'),
              (n.count = this.count),
              (n.instanceMatrix = this.instanceMatrix.toJSON()),
              null !== this.instanceColor && (n.instanceColor = this.instanceColor.toJSON())),
            this.isScene)
          )
            this.background &&
              (this.background.isColor
                ? (n.background = this.background.toJSON())
                : this.background.isTexture && (n.background = this.background.toJSON(t).uuid)),
              this.environment && this.environment.isTexture && (n.environment = this.environment.toJSON(t).uuid)
          else if (this.isMesh || this.isLine || this.isPoints) {
            n.geometry = s(t.geometries, this.geometry)
            const e = this.geometry.parameters
            if (void 0 !== e && void 0 !== e.shapes) {
              const i = e.shapes
              if (Array.isArray(i))
                for (let e = 0, n = i.length; e < n; e++) {
                  const n = i[e]
                  s(t.shapes, n)
                }
              else s(t.shapes, i)
            }
          }
          if (
            (this.isSkinnedMesh &&
              ((n.bindMode = this.bindMode),
              (n.bindMatrix = this.bindMatrix.toArray()),
              void 0 !== this.skeleton && (s(t.skeletons, this.skeleton), (n.skeleton = this.skeleton.uuid))),
            void 0 !== this.material)
          )
            if (Array.isArray(this.material)) {
              const e = []
              for (let i = 0, n = this.material.length; i < n; i++) e.push(s(t.materials, this.material[i]))
              n.material = e
            } else n.material = s(t.materials, this.material)
          if (this.children.length > 0) {
            n.children = []
            for (let e = 0; e < this.children.length; e++) n.children.push(this.children[e].toJSON(t).object)
          }
          if (this.animations.length > 0) {
            n.animations = []
            for (let e = 0; e < this.animations.length; e++) {
              const i = this.animations[e]
              n.animations.push(s(t.animations, i))
            }
          }
          if (e) {
            const e = r(t.geometries),
              n = r(t.materials),
              s = r(t.textures),
              a = r(t.images),
              o = r(t.shapes),
              l = r(t.skeletons),
              c = r(t.animations)
            e.length > 0 && (i.geometries = e),
              n.length > 0 && (i.materials = n),
              s.length > 0 && (i.textures = s),
              a.length > 0 && (i.images = a),
              o.length > 0 && (i.shapes = o),
              l.length > 0 && (i.skeletons = l),
              c.length > 0 && (i.animations = c)
          }
          return (i.object = n), i
          function r(t) {
            const e = []
            for (const i in t) {
              const n = t[i]
              delete n.metadata, e.push(n)
            }
            return e
          }
        }
        clone(t) {
          return new this.constructor().copy(this, t)
        }
        copy(t, e = !0) {
          if (
            ((this.name = t.name),
            this.up.copy(t.up),
            this.position.copy(t.position),
            (this.rotation.order = t.rotation.order),
            this.quaternion.copy(t.quaternion),
            this.scale.copy(t.scale),
            this.matrix.copy(t.matrix),
            this.matrixWorld.copy(t.matrixWorld),
            (this.matrixAutoUpdate = t.matrixAutoUpdate),
            (this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate),
            (this.layers.mask = t.layers.mask),
            (this.visible = t.visible),
            (this.castShadow = t.castShadow),
            (this.receiveShadow = t.receiveShadow),
            (this.frustumCulled = t.frustumCulled),
            (this.renderOrder = t.renderOrder),
            (this.userData = JSON.parse(JSON.stringify(t.userData))),
            !0 === e)
          )
            for (let i = 0; i < t.children.length; i++) {
              const e = t.children[i]
              this.add(e.clone())
            }
          return this
        }
      }
      ;(Se.DefaultUp = new Et(0, 1, 0)), (Se.DefaultMatrixAutoUpdate = !0), (Se.prototype.isObject3D = !0)
      const Be = new Et(),
        Te = new Et(),
        Le = new Et(),
        De = new Et(),
        Qe = new Et(),
        Re = new Et(),
        Pe = new Et(),
        Ne = new Et(),
        Fe = new Et(),
        Ue = new Et()
      class ke {
        constructor(t = new Et(), e = new Et(), i = new Et()) {
          ;(this.a = t), (this.b = e), (this.c = i)
        }
        static getNormal(t, e, i, n) {
          n.subVectors(i, e), Be.subVectors(t, e), n.cross(Be)
          const s = n.lengthSq()
          return s > 0 ? n.multiplyScalar(1 / Math.sqrt(s)) : n.set(0, 0, 0)
        }
        static getBarycoord(t, e, i, n, s) {
          Be.subVectors(n, e), Te.subVectors(i, e), Le.subVectors(t, e)
          const r = Be.dot(Be),
            a = Be.dot(Te),
            o = Be.dot(Le),
            l = Te.dot(Te),
            c = Te.dot(Le),
            h = r * l - a * a
          if (0 === h) return s.set(-2, -1, -1)
          const u = 1 / h,
            d = (l * o - a * c) * u,
            p = (r * c - a * o) * u
          return s.set(1 - d - p, p, d)
        }
        static containsPoint(t, e, i, n) {
          return this.getBarycoord(t, e, i, n, De), De.x >= 0 && De.y >= 0 && De.x + De.y <= 1
        }
        static getUV(t, e, i, n, s, r, a, o) {
          return (
            this.getBarycoord(t, e, i, n, De),
            o.set(0, 0),
            o.addScaledVector(s, De.x),
            o.addScaledVector(r, De.y),
            o.addScaledVector(a, De.z),
            o
          )
        }
        static isFrontFacing(t, e, i, n) {
          return Be.subVectors(i, e), Te.subVectors(t, e), Be.cross(Te).dot(n) < 0
        }
        set(t, e, i) {
          return this.a.copy(t), this.b.copy(e), this.c.copy(i), this
        }
        setFromPointsAndIndices(t, e, i, n) {
          return this.a.copy(t[e]), this.b.copy(t[i]), this.c.copy(t[n]), this
        }
        clone() {
          return new this.constructor().copy(this)
        }
        copy(t) {
          return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this
        }
        getArea() {
          return Be.subVectors(this.c, this.b), Te.subVectors(this.a, this.b), 0.5 * Be.cross(Te).length()
        }
        getMidpoint(t) {
          return t
            .addVectors(this.a, this.b)
            .add(this.c)
            .multiplyScalar(1 / 3)
        }
        getNormal(t) {
          return ke.getNormal(this.a, this.b, this.c, t)
        }
        getPlane(t) {
          return t.setFromCoplanarPoints(this.a, this.b, this.c)
        }
        getBarycoord(t, e) {
          return ke.getBarycoord(t, this.a, this.b, this.c, e)
        }
        getUV(t, e, i, n, s) {
          return ke.getUV(t, this.a, this.b, this.c, e, i, n, s)
        }
        containsPoint(t) {
          return ke.containsPoint(t, this.a, this.b, this.c)
        }
        isFrontFacing(t) {
          return ke.isFrontFacing(this.a, this.b, this.c, t)
        }
        intersectsBox(t) {
          return t.intersectsTriangle(this)
        }
        closestPointToPoint(t, e) {
          const i = this.a,
            n = this.b,
            s = this.c
          let r, a
          Qe.subVectors(n, i), Re.subVectors(s, i), Ne.subVectors(t, i)
          const o = Qe.dot(Ne),
            l = Re.dot(Ne)
          if (o <= 0 && l <= 0) return e.copy(i)
          Fe.subVectors(t, n)
          const c = Qe.dot(Fe),
            h = Re.dot(Fe)
          if (c >= 0 && h <= c) return e.copy(n)
          const u = o * h - c * l
          if (u <= 0 && o >= 0 && c <= 0) return (r = o / (o - c)), e.copy(i).addScaledVector(Qe, r)
          Ue.subVectors(t, s)
          const d = Qe.dot(Ue),
            p = Re.dot(Ue)
          if (p >= 0 && d <= p) return e.copy(s)
          const A = d * l - o * p
          if (A <= 0 && l >= 0 && p <= 0) return (a = l / (l - p)), e.copy(i).addScaledVector(Re, a)
          const g = c * p - d * h
          if (g <= 0 && h - c >= 0 && d - p >= 0)
            return Pe.subVectors(s, n), (a = (h - c) / (h - c + (d - p))), e.copy(n).addScaledVector(Pe, a)
          const m = 1 / (g + A + u)
          return (r = A * m), (a = u * m), e.copy(i).addScaledVector(Qe, r).addScaledVector(Re, a)
        }
        equals(t) {
          return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
        }
      }
      let Oe = 0
      class Ge extends it {
        constructor() {
          super(),
            Object.defineProperty(this, 'id', { value: Oe++ }),
            (this.uuid = ot()),
            (this.name = ''),
            (this.type = 'Material'),
            (this.fog = !0),
            (this.blending = 1),
            (this.side = 0),
            (this.vertexColors = !1),
            (this.opacity = 1),
            (this.transparent = !1),
            (this.blendSrc = 204),
            (this.blendDst = 205),
            (this.blendEquation = 100),
            (this.blendSrcAlpha = null),
            (this.blendDstAlpha = null),
            (this.blendEquationAlpha = null),
            (this.depthFunc = 3),
            (this.depthTest = !0),
            (this.depthWrite = !0),
            (this.stencilWriteMask = 255),
            (this.stencilFunc = 519),
            (this.stencilRef = 0),
            (this.stencilFuncMask = 255),
            (this.stencilFail = 7680),
            (this.stencilZFail = 7680),
            (this.stencilZPass = 7680),
            (this.stencilWrite = !1),
            (this.clippingPlanes = null),
            (this.clipIntersection = !1),
            (this.clipShadows = !1),
            (this.shadowSide = null),
            (this.colorWrite = !0),
            (this.precision = null),
            (this.polygonOffset = !1),
            (this.polygonOffsetFactor = 0),
            (this.polygonOffsetUnits = 0),
            (this.dithering = !1),
            (this.alphaTest = 0),
            (this.alphaToCoverage = !1),
            (this.premultipliedAlpha = !1),
            (this.visible = !0),
            (this.toneMapped = !0),
            (this.userData = {}),
            (this.version = 0)
        }
        onBuild() {}
        onBeforeCompile() {}
        customProgramCacheKey() {
          return this.onBeforeCompile.toString()
        }
        setValues(t) {
          if (void 0 !== t)
            for (const e in t) {
              const i = t[e]
              if (void 0 === i) continue
              if ('shading' === e) {
                this.flatShading = 1 === i
                continue
              }
              const n = this[e]
              void 0 !== n &&
                (n && n.isColor ? n.set(i) : n && n.isVector3 && i && i.isVector3 ? n.copy(i) : (this[e] = i))
            }
        }
        toJSON(t) {
          const e = void 0 === t || 'string' == typeof t
          e && (t = { textures: {}, images: {} })
          const i = { metadata: { version: 4.5, type: 'Material', generator: 'Material.toJSON' } }
          function n(t) {
            const e = []
            for (const i in t) {
              const n = t[i]
              delete n.metadata, e.push(n)
            }
            return e
          }
          if (
            ((i.uuid = this.uuid),
            (i.type = this.type),
            '' !== this.name && (i.name = this.name),
            this.color && this.color.isColor && (i.color = this.color.getHex()),
            void 0 !== this.roughness && (i.roughness = this.roughness),
            void 0 !== this.metalness && (i.metalness = this.metalness),
            this.sheen && this.sheen.isColor && (i.sheen = this.sheen.getHex()),
            this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()),
            this.emissiveIntensity && 1 !== this.emissiveIntensity && (i.emissiveIntensity = this.emissiveIntensity),
            this.specular && this.specular.isColor && (i.specular = this.specular.getHex()),
            void 0 !== this.specularIntensity && (i.specularIntensity = this.specularIntensity),
            this.specularTint && this.specularTint.isColor && (i.specularTint = this.specularTint.getHex()),
            void 0 !== this.shininess && (i.shininess = this.shininess),
            void 0 !== this.clearcoat && (i.clearcoat = this.clearcoat),
            void 0 !== this.clearcoatRoughness && (i.clearcoatRoughness = this.clearcoatRoughness),
            this.clearcoatMap && this.clearcoatMap.isTexture && (i.clearcoatMap = this.clearcoatMap.toJSON(t).uuid),
            this.clearcoatRoughnessMap &&
              this.clearcoatRoughnessMap.isTexture &&
              (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid),
            this.clearcoatNormalMap &&
              this.clearcoatNormalMap.isTexture &&
              ((i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid),
              (i.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
            this.map && this.map.isTexture && (i.map = this.map.toJSON(t).uuid),
            this.matcap && this.matcap.isTexture && (i.matcap = this.matcap.toJSON(t).uuid),
            this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(t).uuid),
            this.lightMap &&
              this.lightMap.isTexture &&
              ((i.lightMap = this.lightMap.toJSON(t).uuid), (i.lightMapIntensity = this.lightMapIntensity)),
            this.aoMap &&
              this.aoMap.isTexture &&
              ((i.aoMap = this.aoMap.toJSON(t).uuid), (i.aoMapIntensity = this.aoMapIntensity)),
            this.bumpMap &&
              this.bumpMap.isTexture &&
              ((i.bumpMap = this.bumpMap.toJSON(t).uuid), (i.bumpScale = this.bumpScale)),
            this.normalMap &&
              this.normalMap.isTexture &&
              ((i.normalMap = this.normalMap.toJSON(t).uuid),
              (i.normalMapType = this.normalMapType),
              (i.normalScale = this.normalScale.toArray())),
            this.displacementMap &&
              this.displacementMap.isTexture &&
              ((i.displacementMap = this.displacementMap.toJSON(t).uuid),
              (i.displacementScale = this.displacementScale),
              (i.displacementBias = this.displacementBias)),
            this.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this.roughnessMap.toJSON(t).uuid),
            this.metalnessMap && this.metalnessMap.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(t).uuid),
            this.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this.emissiveMap.toJSON(t).uuid),
            this.specularMap && this.specularMap.isTexture && (i.specularMap = this.specularMap.toJSON(t).uuid),
            this.specularIntensityMap &&
              this.specularIntensityMap.isTexture &&
              (i.specularIntensityMap = this.specularIntensityMap.toJSON(t).uuid),
            this.specularTintMap &&
              this.specularTintMap.isTexture &&
              (i.specularTintMap = this.specularTintMap.toJSON(t).uuid),
            this.envMap &&
              this.envMap.isTexture &&
              ((i.envMap = this.envMap.toJSON(t).uuid), void 0 !== this.combine && (i.combine = this.combine)),
            void 0 !== this.envMapIntensity && (i.envMapIntensity = this.envMapIntensity),
            void 0 !== this.reflectivity && (i.reflectivity = this.reflectivity),
            void 0 !== this.refractionRatio && (i.refractionRatio = this.refractionRatio),
            this.gradientMap && this.gradientMap.isTexture && (i.gradientMap = this.gradientMap.toJSON(t).uuid),
            void 0 !== this.transmission && (i.transmission = this.transmission),
            this.transmissionMap &&
              this.transmissionMap.isTexture &&
              (i.transmissionMap = this.transmissionMap.toJSON(t).uuid),
            void 0 !== this.thickness && (i.thickness = this.thickness),
            this.thicknessMap && this.thicknessMap.isTexture && (i.thicknessMap = this.thicknessMap.toJSON(t).uuid),
            void 0 !== this.attenuationDistance && (i.attenuationDistance = this.attenuationDistance),
            void 0 !== this.attenuationTint && (i.attenuationTint = this.attenuationTint.getHex()),
            void 0 !== this.size && (i.size = this.size),
            null !== this.shadowSide && (i.shadowSide = this.shadowSide),
            void 0 !== this.sizeAttenuation && (i.sizeAttenuation = this.sizeAttenuation),
            1 !== this.blending && (i.blending = this.blending),
            0 !== this.side && (i.side = this.side),
            this.vertexColors && (i.vertexColors = !0),
            this.opacity < 1 && (i.opacity = this.opacity),
            !0 === this.transparent && (i.transparent = this.transparent),
            (i.depthFunc = this.depthFunc),
            (i.depthTest = this.depthTest),
            (i.depthWrite = this.depthWrite),
            (i.colorWrite = this.colorWrite),
            (i.stencilWrite = this.stencilWrite),
            (i.stencilWriteMask = this.stencilWriteMask),
            (i.stencilFunc = this.stencilFunc),
            (i.stencilRef = this.stencilRef),
            (i.stencilFuncMask = this.stencilFuncMask),
            (i.stencilFail = this.stencilFail),
            (i.stencilZFail = this.stencilZFail),
            (i.stencilZPass = this.stencilZPass),
            this.rotation && 0 !== this.rotation && (i.rotation = this.rotation),
            !0 === this.polygonOffset && (i.polygonOffset = !0),
            0 !== this.polygonOffsetFactor && (i.polygonOffsetFactor = this.polygonOffsetFactor),
            0 !== this.polygonOffsetUnits && (i.polygonOffsetUnits = this.polygonOffsetUnits),
            this.linewidth && 1 !== this.linewidth && (i.linewidth = this.linewidth),
            void 0 !== this.dashSize && (i.dashSize = this.dashSize),
            void 0 !== this.gapSize && (i.gapSize = this.gapSize),
            void 0 !== this.scale && (i.scale = this.scale),
            !0 === this.dithering && (i.dithering = !0),
            this.alphaTest > 0 && (i.alphaTest = this.alphaTest),
            !0 === this.alphaToCoverage && (i.alphaToCoverage = this.alphaToCoverage),
            !0 === this.premultipliedAlpha && (i.premultipliedAlpha = this.premultipliedAlpha),
            !0 === this.wireframe && (i.wireframe = this.wireframe),
            this.wireframeLinewidth > 1 && (i.wireframeLinewidth = this.wireframeLinewidth),
            'round' !== this.wireframeLinecap && (i.wireframeLinecap = this.wireframeLinecap),
            'round' !== this.wireframeLinejoin && (i.wireframeLinejoin = this.wireframeLinejoin),
            !0 === this.flatShading && (i.flatShading = this.flatShading),
            !1 === this.visible && (i.visible = !1),
            !1 === this.toneMapped && (i.toneMapped = !1),
            '{}' !== JSON.stringify(this.userData) && (i.userData = this.userData),
            e)
          ) {
            const e = n(t.textures),
              s = n(t.images)
            e.length > 0 && (i.textures = e), s.length > 0 && (i.images = s)
          }
          return i
        }
        clone() {
          return new this.constructor().copy(this)
        }
        copy(t) {
          ;(this.name = t.name),
            (this.fog = t.fog),
            (this.blending = t.blending),
            (this.side = t.side),
            (this.vertexColors = t.vertexColors),
            (this.opacity = t.opacity),
            (this.transparent = t.transparent),
            (this.blendSrc = t.blendSrc),
            (this.blendDst = t.blendDst),
            (this.blendEquation = t.blendEquation),
            (this.blendSrcAlpha = t.blendSrcAlpha),
            (this.blendDstAlpha = t.blendDstAlpha),
            (this.blendEquationAlpha = t.blendEquationAlpha),
            (this.depthFunc = t.depthFunc),
            (this.depthTest = t.depthTest),
            (this.depthWrite = t.depthWrite),
            (this.stencilWriteMask = t.stencilWriteMask),
            (this.stencilFunc = t.stencilFunc),
            (this.stencilRef = t.stencilRef),
            (this.stencilFuncMask = t.stencilFuncMask),
            (this.stencilFail = t.stencilFail),
            (this.stencilZFail = t.stencilZFail),
            (this.stencilZPass = t.stencilZPass),
            (this.stencilWrite = t.stencilWrite)
          const e = t.clippingPlanes
          let i = null
          if (null !== e) {
            const t = e.length
            i = new Array(t)
            for (let n = 0; n !== t; ++n) i[n] = e[n].clone()
          }
          return (
            (this.clippingPlanes = i),
            (this.clipIntersection = t.clipIntersection),
            (this.clipShadows = t.clipShadows),
            (this.shadowSide = t.shadowSide),
            (this.colorWrite = t.colorWrite),
            (this.precision = t.precision),
            (this.polygonOffset = t.polygonOffset),
            (this.polygonOffsetFactor = t.polygonOffsetFactor),
            (this.polygonOffsetUnits = t.polygonOffsetUnits),
            (this.dithering = t.dithering),
            (this.alphaTest = t.alphaTest),
            (this.alphaToCoverage = t.alphaToCoverage),
            (this.premultipliedAlpha = t.premultipliedAlpha),
            (this.visible = t.visible),
            (this.toneMapped = t.toneMapped),
            (this.userData = JSON.parse(JSON.stringify(t.userData))),
            this
          )
        }
        dispose() {
          this.dispatchEvent({ type: 'dispose' })
        }
        set needsUpdate(t) {
          !0 === t && this.version++
        }
      }
      Ge.prototype.isMaterial = !0
      const ze = {
          aliceblue: 15792383,
          antiquewhite: 16444375,
          aqua: 65535,
          aquamarine: 8388564,
          azure: 15794175,
          beige: 16119260,
          bisque: 16770244,
          black: 0,
          blanchedalmond: 16772045,
          blue: 255,
          blueviolet: 9055202,
          brown: 10824234,
          burlywood: 14596231,
          cadetblue: 6266528,
          chartreuse: 8388352,
          chocolate: 13789470,
          coral: 16744272,
          cornflowerblue: 6591981,
          cornsilk: 16775388,
          crimson: 14423100,
          cyan: 65535,
          darkblue: 139,
          darkcyan: 35723,
          darkgoldenrod: 12092939,
          darkgray: 11119017,
          darkgreen: 25600,
          darkgrey: 11119017,
          darkkhaki: 12433259,
          darkmagenta: 9109643,
          darkolivegreen: 5597999,
          darkorange: 16747520,
          darkorchid: 10040012,
          darkred: 9109504,
          darksalmon: 15308410,
          darkseagreen: 9419919,
          darkslateblue: 4734347,
          darkslategray: 3100495,
          darkslategrey: 3100495,
          darkturquoise: 52945,
          darkviolet: 9699539,
          deeppink: 16716947,
          deepskyblue: 49151,
          dimgray: 6908265,
          dimgrey: 6908265,
          dodgerblue: 2003199,
          firebrick: 11674146,
          floralwhite: 16775920,
          forestgreen: 2263842,
          fuchsia: 16711935,
          gainsboro: 14474460,
          ghostwhite: 16316671,
          gold: 16766720,
          goldenrod: 14329120,
          gray: 8421504,
          green: 32768,
          greenyellow: 11403055,
          grey: 8421504,
          honeydew: 15794160,
          hotpink: 16738740,
          indianred: 13458524,
          indigo: 4915330,
          ivory: 16777200,
          khaki: 15787660,
          lavender: 15132410,
          lavenderblush: 16773365,
          lawngreen: 8190976,
          lemonchiffon: 16775885,
          lightblue: 11393254,
          lightcoral: 15761536,
          lightcyan: 14745599,
          lightgoldenrodyellow: 16448210,
          lightgray: 13882323,
          lightgreen: 9498256,
          lightgrey: 13882323,
          lightpink: 16758465,
          lightsalmon: 16752762,
          lightseagreen: 2142890,
          lightskyblue: 8900346,
          lightslategray: 7833753,
          lightslategrey: 7833753,
          lightsteelblue: 11584734,
          lightyellow: 16777184,
          lime: 65280,
          limegreen: 3329330,
          linen: 16445670,
          magenta: 16711935,
          maroon: 8388608,
          mediumaquamarine: 6737322,
          mediumblue: 205,
          mediumorchid: 12211667,
          mediumpurple: 9662683,
          mediumseagreen: 3978097,
          mediumslateblue: 8087790,
          mediumspringgreen: 64154,
          mediumturquoise: 4772300,
          mediumvioletred: 13047173,
          midnightblue: 1644912,
          mintcream: 16121850,
          mistyrose: 16770273,
          moccasin: 16770229,
          navajowhite: 16768685,
          navy: 128,
          oldlace: 16643558,
          olive: 8421376,
          olivedrab: 7048739,
          orange: 16753920,
          orangered: 16729344,
          orchid: 14315734,
          palegoldenrod: 15657130,
          palegreen: 10025880,
          paleturquoise: 11529966,
          palevioletred: 14381203,
          papayawhip: 16773077,
          peachpuff: 16767673,
          peru: 13468991,
          pink: 16761035,
          plum: 14524637,
          powderblue: 11591910,
          purple: 8388736,
          rebeccapurple: 6697881,
          red: 16711680,
          rosybrown: 12357519,
          royalblue: 4286945,
          saddlebrown: 9127187,
          salmon: 16416882,
          sandybrown: 16032864,
          seagreen: 3050327,
          seashell: 16774638,
          sienna: 10506797,
          silver: 12632256,
          skyblue: 8900331,
          slateblue: 6970061,
          slategray: 7372944,
          slategrey: 7372944,
          snow: 16775930,
          springgreen: 65407,
          steelblue: 4620980,
          tan: 13808780,
          teal: 32896,
          thistle: 14204888,
          tomato: 16737095,
          turquoise: 4251856,
          violet: 15631086,
          wheat: 16113331,
          white: 16777215,
          whitesmoke: 16119285,
          yellow: 16776960,
          yellowgreen: 10145074,
        },
        Ve = { h: 0, s: 0, l: 0 },
        He = { h: 0, s: 0, l: 0 }
      function We(t, e, i) {
        return (
          i < 0 && (i += 1),
          i > 1 && (i -= 1),
          i < 1 / 6 ? t + 6 * (e - t) * i : i < 0.5 ? e : i < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - i) : t
        )
      }
      function qe(t) {
        return t < 0.04045 ? 0.0773993808 * t : Math.pow(0.9478672986 * t + 0.0521327014, 2.4)
      }
      function je(t) {
        return t < 0.0031308 ? 12.92 * t : 1.055 * Math.pow(t, 0.41666) - 0.055
      }
      class Ye {
        constructor(t, e, i) {
          return void 0 === e && void 0 === i ? this.set(t) : this.setRGB(t, e, i)
        }
        set(t) {
          return (
            t && t.isColor
              ? this.copy(t)
              : 'number' == typeof t
              ? this.setHex(t)
              : 'string' == typeof t && this.setStyle(t),
            this
          )
        }
        setScalar(t) {
          return (this.r = t), (this.g = t), (this.b = t), this
        }
        setHex(t) {
          return (
            (t = Math.floor(t)),
            (this.r = ((t >> 16) & 255) / 255),
            (this.g = ((t >> 8) & 255) / 255),
            (this.b = (255 & t) / 255),
            this
          )
        }
        setRGB(t, e, i) {
          return (this.r = t), (this.g = e), (this.b = i), this
        }
        setHSL(t, e, i) {
          if (((t = ct(t, 1)), (e = lt(e, 0, 1)), (i = lt(i, 0, 1)), 0 === e)) this.r = this.g = this.b = i
          else {
            const n = i <= 0.5 ? i * (1 + e) : i + e - i * e,
              s = 2 * i - n
            ;(this.r = We(s, n, t + 1 / 3)), (this.g = We(s, n, t)), (this.b = We(s, n, t - 1 / 3))
          }
          return this
        }
        setStyle(t) {
          function e(t) {
            void 0 !== t && parseFloat(t)
          }
          let i
          if ((i = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t))) {
            let t
            const n = i[1],
              s = i[2]
            switch (n) {
              case 'rgb':
              case 'rgba':
                if ((t = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s)))
                  return (
                    (this.r = Math.min(255, parseInt(t[1], 10)) / 255),
                    (this.g = Math.min(255, parseInt(t[2], 10)) / 255),
                    (this.b = Math.min(255, parseInt(t[3], 10)) / 255),
                    e(t[4]),
                    this
                  )
                if ((t = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s)))
                  return (
                    (this.r = Math.min(100, parseInt(t[1], 10)) / 100),
                    (this.g = Math.min(100, parseInt(t[2], 10)) / 100),
                    (this.b = Math.min(100, parseInt(t[3], 10)) / 100),
                    e(t[4]),
                    this
                  )
                break
              case 'hsl':
              case 'hsla':
                if ((t = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s))) {
                  const i = parseFloat(t[1]) / 360,
                    n = parseInt(t[2], 10) / 100,
                    s = parseInt(t[3], 10) / 100
                  return e(t[4]), this.setHSL(i, n, s)
                }
            }
          } else if ((i = /^\#([A-Fa-f\d]+)$/.exec(t))) {
            const t = i[1],
              e = t.length
            if (3 === e)
              return (
                (this.r = parseInt(t.charAt(0) + t.charAt(0), 16) / 255),
                (this.g = parseInt(t.charAt(1) + t.charAt(1), 16) / 255),
                (this.b = parseInt(t.charAt(2) + t.charAt(2), 16) / 255),
                this
              )
            if (6 === e)
              return (
                (this.r = parseInt(t.charAt(0) + t.charAt(1), 16) / 255),
                (this.g = parseInt(t.charAt(2) + t.charAt(3), 16) / 255),
                (this.b = parseInt(t.charAt(4) + t.charAt(5), 16) / 255),
                this
              )
          }
          return t && t.length > 0 ? this.setColorName(t) : this
        }
        setColorName(t) {
          const e = ze[t.toLowerCase()]
          return void 0 !== e && this.setHex(e), this
        }
        clone() {
          return new this.constructor(this.r, this.g, this.b)
        }
        copy(t) {
          return (this.r = t.r), (this.g = t.g), (this.b = t.b), this
        }
        copyGammaToLinear(t, e = 2) {
          return (this.r = Math.pow(t.r, e)), (this.g = Math.pow(t.g, e)), (this.b = Math.pow(t.b, e)), this
        }
        copyLinearToGamma(t, e = 2) {
          const i = e > 0 ? 1 / e : 1
          return (this.r = Math.pow(t.r, i)), (this.g = Math.pow(t.g, i)), (this.b = Math.pow(t.b, i)), this
        }
        convertGammaToLinear(t) {
          return this.copyGammaToLinear(this, t), this
        }
        convertLinearToGamma(t) {
          return this.copyLinearToGamma(this, t), this
        }
        copySRGBToLinear(t) {
          return (this.r = qe(t.r)), (this.g = qe(t.g)), (this.b = qe(t.b)), this
        }
        copyLinearToSRGB(t) {
          return (this.r = je(t.r)), (this.g = je(t.g)), (this.b = je(t.b)), this
        }
        convertSRGBToLinear() {
          return this.copySRGBToLinear(this), this
        }
        convertLinearToSRGB() {
          return this.copyLinearToSRGB(this), this
        }
        getHex() {
          return ((255 * this.r) << 16) ^ ((255 * this.g) << 8) ^ ((255 * this.b) << 0)
        }
        getHexString() {
          return ('000000' + this.getHex().toString(16)).slice(-6)
        }
        getHSL(t) {
          const e = this.r,
            i = this.g,
            n = this.b,
            s = Math.max(e, i, n),
            r = Math.min(e, i, n)
          let a, o
          const l = (r + s) / 2
          if (r === s) (a = 0), (o = 0)
          else {
            const t = s - r
            switch (((o = l <= 0.5 ? t / (s + r) : t / (2 - s - r)), s)) {
              case e:
                a = (i - n) / t + (i < n ? 6 : 0)
                break
              case i:
                a = (n - e) / t + 2
                break
              case n:
                a = (e - i) / t + 4
            }
            a /= 6
          }
          return (t.h = a), (t.s = o), (t.l = l), t
        }
        getStyle() {
          return 'rgb(' + ((255 * this.r) | 0) + ',' + ((255 * this.g) | 0) + ',' + ((255 * this.b) | 0) + ')'
        }
        offsetHSL(t, e, i) {
          return this.getHSL(Ve), (Ve.h += t), (Ve.s += e), (Ve.l += i), this.setHSL(Ve.h, Ve.s, Ve.l), this
        }
        add(t) {
          return (this.r += t.r), (this.g += t.g), (this.b += t.b), this
        }
        addColors(t, e) {
          return (this.r = t.r + e.r), (this.g = t.g + e.g), (this.b = t.b + e.b), this
        }
        addScalar(t) {
          return (this.r += t), (this.g += t), (this.b += t), this
        }
        sub(t) {
          return (
            (this.r = Math.max(0, this.r - t.r)),
            (this.g = Math.max(0, this.g - t.g)),
            (this.b = Math.max(0, this.b - t.b)),
            this
          )
        }
        multiply(t) {
          return (this.r *= t.r), (this.g *= t.g), (this.b *= t.b), this
        }
        multiplyScalar(t) {
          return (this.r *= t), (this.g *= t), (this.b *= t), this
        }
        lerp(t, e) {
          return (this.r += (t.r - this.r) * e), (this.g += (t.g - this.g) * e), (this.b += (t.b - this.b) * e), this
        }
        lerpColors(t, e, i) {
          return (
            (this.r = t.r + (e.r - t.r) * i), (this.g = t.g + (e.g - t.g) * i), (this.b = t.b + (e.b - t.b) * i), this
          )
        }
        lerpHSL(t, e) {
          this.getHSL(Ve), t.getHSL(He)
          const i = ht(Ve.h, He.h, e),
            n = ht(Ve.s, He.s, e),
            s = ht(Ve.l, He.l, e)
          return this.setHSL(i, n, s), this
        }
        equals(t) {
          return t.r === this.r && t.g === this.g && t.b === this.b
        }
        fromArray(t, e = 0) {
          return (this.r = t[e]), (this.g = t[e + 1]), (this.b = t[e + 2]), this
        }
        toArray(t = [], e = 0) {
          return (t[e] = this.r), (t[e + 1] = this.g), (t[e + 2] = this.b), t
        }
        fromBufferAttribute(t, e) {
          return (
            (this.r = t.getX(e)),
            (this.g = t.getY(e)),
            (this.b = t.getZ(e)),
            !0 === t.normalized && ((this.r /= 255), (this.g /= 255), (this.b /= 255)),
            this
          )
        }
        toJSON() {
          return this.getHex()
        }
      }
      ;(Ye.NAMES = ze), (Ye.prototype.isColor = !0), (Ye.prototype.r = 1), (Ye.prototype.g = 1), (Ye.prototype.b = 1)
      class Je extends Ge {
        constructor(t) {
          super(),
            (this.type = 'MeshBasicMaterial'),
            (this.color = new Ye(16777215)),
            (this.map = null),
            (this.lightMap = null),
            (this.lightMapIntensity = 1),
            (this.aoMap = null),
            (this.aoMapIntensity = 1),
            (this.specularMap = null),
            (this.alphaMap = null),
            (this.envMap = null),
            (this.combine = 0),
            (this.reflectivity = 1),
            (this.refractionRatio = 0.98),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.wireframeLinecap = 'round'),
            (this.wireframeLinejoin = 'round'),
            this.setValues(t)
        }
        copy(t) {
          return (
            super.copy(t),
            this.color.copy(t.color),
            (this.map = t.map),
            (this.lightMap = t.lightMap),
            (this.lightMapIntensity = t.lightMapIntensity),
            (this.aoMap = t.aoMap),
            (this.aoMapIntensity = t.aoMapIntensity),
            (this.specularMap = t.specularMap),
            (this.alphaMap = t.alphaMap),
            (this.envMap = t.envMap),
            (this.combine = t.combine),
            (this.reflectivity = t.reflectivity),
            (this.refractionRatio = t.refractionRatio),
            (this.wireframe = t.wireframe),
            (this.wireframeLinewidth = t.wireframeLinewidth),
            (this.wireframeLinecap = t.wireframeLinecap),
            (this.wireframeLinejoin = t.wireframeLinejoin),
            this
          )
        }
      }
      Je.prototype.isMeshBasicMaterial = !0
      const Xe = new Et(),
        Ke = new gt()
      class Ze {
        constructor(t, e, i) {
          if (Array.isArray(t)) throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.')
          ;(this.name = ''),
            (this.array = t),
            (this.itemSize = e),
            (this.count = void 0 !== t ? t.length / e : 0),
            (this.normalized = !0 === i),
            (this.usage = 35044),
            (this.updateRange = { offset: 0, count: -1 }),
            (this.version = 0)
        }
        onUploadCallback() {}
        set needsUpdate(t) {
          !0 === t && this.version++
        }
        setUsage(t) {
          return (this.usage = t), this
        }
        copy(t) {
          return (
            (this.name = t.name),
            (this.array = new t.array.constructor(t.array)),
            (this.itemSize = t.itemSize),
            (this.count = t.count),
            (this.normalized = t.normalized),
            (this.usage = t.usage),
            this
          )
        }
        copyAt(t, e, i) {
          ;(t *= this.itemSize), (i *= e.itemSize)
          for (let n = 0, s = this.itemSize; n < s; n++) this.array[t + n] = e.array[i + n]
          return this
        }
        copyArray(t) {
          return this.array.set(t), this
        }
        copyColorsArray(t) {
          const e = this.array
          let i = 0
          for (let n = 0, s = t.length; n < s; n++) {
            let s = t[n]
            void 0 === s && (s = new Ye()), (e[i++] = s.r), (e[i++] = s.g), (e[i++] = s.b)
          }
          return this
        }
        copyVector2sArray(t) {
          const e = this.array
          let i = 0
          for (let n = 0, s = t.length; n < s; n++) {
            let s = t[n]
            void 0 === s && (s = new gt()), (e[i++] = s.x), (e[i++] = s.y)
          }
          return this
        }
        copyVector3sArray(t) {
          const e = this.array
          let i = 0
          for (let n = 0, s = t.length; n < s; n++) {
            let s = t[n]
            void 0 === s && (s = new Et()), (e[i++] = s.x), (e[i++] = s.y), (e[i++] = s.z)
          }
          return this
        }
        copyVector4sArray(t) {
          const e = this.array
          let i = 0
          for (let n = 0, s = t.length; n < s; n++) {
            let s = t[n]
            void 0 === s && (s = new _t()), (e[i++] = s.x), (e[i++] = s.y), (e[i++] = s.z), (e[i++] = s.w)
          }
          return this
        }
        applyMatrix3(t) {
          if (2 === this.itemSize)
            for (let e = 0, i = this.count; e < i; e++)
              Ke.fromBufferAttribute(this, e), Ke.applyMatrix3(t), this.setXY(e, Ke.x, Ke.y)
          else if (3 === this.itemSize)
            for (let e = 0, i = this.count; e < i; e++)
              Xe.fromBufferAttribute(this, e), Xe.applyMatrix3(t), this.setXYZ(e, Xe.x, Xe.y, Xe.z)
          return this
        }
        applyMatrix4(t) {
          for (let e = 0, i = this.count; e < i; e++)
            (Xe.x = this.getX(e)),
              (Xe.y = this.getY(e)),
              (Xe.z = this.getZ(e)),
              Xe.applyMatrix4(t),
              this.setXYZ(e, Xe.x, Xe.y, Xe.z)
          return this
        }
        applyNormalMatrix(t) {
          for (let e = 0, i = this.count; e < i; e++)
            (Xe.x = this.getX(e)),
              (Xe.y = this.getY(e)),
              (Xe.z = this.getZ(e)),
              Xe.applyNormalMatrix(t),
              this.setXYZ(e, Xe.x, Xe.y, Xe.z)
          return this
        }
        transformDirection(t) {
          for (let e = 0, i = this.count; e < i; e++)
            (Xe.x = this.getX(e)),
              (Xe.y = this.getY(e)),
              (Xe.z = this.getZ(e)),
              Xe.transformDirection(t),
              this.setXYZ(e, Xe.x, Xe.y, Xe.z)
          return this
        }
        set(t, e = 0) {
          return this.array.set(t, e), this
        }
        getX(t) {
          return this.array[t * this.itemSize]
        }
        setX(t, e) {
          return (this.array[t * this.itemSize] = e), this
        }
        getY(t) {
          return this.array[t * this.itemSize + 1]
        }
        setY(t, e) {
          return (this.array[t * this.itemSize + 1] = e), this
        }
        getZ(t) {
          return this.array[t * this.itemSize + 2]
        }
        setZ(t, e) {
          return (this.array[t * this.itemSize + 2] = e), this
        }
        getW(t) {
          return this.array[t * this.itemSize + 3]
        }
        setW(t, e) {
          return (this.array[t * this.itemSize + 3] = e), this
        }
        setXY(t, e, i) {
          return (t *= this.itemSize), (this.array[t + 0] = e), (this.array[t + 1] = i), this
        }
        setXYZ(t, e, i, n) {
          return (t *= this.itemSize), (this.array[t + 0] = e), (this.array[t + 1] = i), (this.array[t + 2] = n), this
        }
        setXYZW(t, e, i, n, s) {
          return (
            (t *= this.itemSize),
            (this.array[t + 0] = e),
            (this.array[t + 1] = i),
            (this.array[t + 2] = n),
            (this.array[t + 3] = s),
            this
          )
        }
        onUpload(t) {
          return (this.onUploadCallback = t), this
        }
        clone() {
          return new this.constructor(this.array, this.itemSize).copy(this)
        }
        toJSON() {
          const t = {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: Array.prototype.slice.call(this.array),
            normalized: this.normalized,
          }
          return (
            '' !== this.name && (t.name = this.name),
            35044 !== this.usage && (t.usage = this.usage),
            (0 === this.updateRange.offset && -1 === this.updateRange.count) || (t.updateRange = this.updateRange),
            t
          )
        }
      }
      Ze.prototype.isBufferAttribute = !0
      class $e extends Ze {
        constructor(t, e, i) {
          super(new Uint16Array(t), e, i)
        }
      }
      class ti extends Ze {
        constructor(t, e, i) {
          super(new Uint32Array(t), e, i)
        }
      }
      ;(class extends Ze {
        constructor(t, e, i) {
          super(new Uint16Array(t), e, i)
        }
      }.prototype.isFloat16BufferAttribute = !0)
      class ei extends Ze {
        constructor(t, e, i) {
          super(new Float32Array(t), e, i)
        }
      }
      function ii(t) {
        if (0 === t.length) return -1 / 0
        let e = t[0]
        for (let i = 1, n = t.length; i < n; ++i) t[i] > e && (e = t[i])
        return e
      }
      let ni = 0
      const si = new ne(),
        ri = new Se(),
        ai = new Et(),
        oi = new Bt(),
        li = new Bt(),
        ci = new Et()
      class hi extends it {
        constructor() {
          super(),
            Object.defineProperty(this, 'id', { value: ni++ }),
            (this.uuid = ot()),
            (this.name = ''),
            (this.type = 'BufferGeometry'),
            (this.index = null),
            (this.attributes = {}),
            (this.morphAttributes = {}),
            (this.morphTargetsRelative = !1),
            (this.groups = []),
            (this.boundingBox = null),
            (this.boundingSphere = null),
            (this.drawRange = { start: 0, count: 1 / 0 }),
            (this.userData = {})
        }
        getIndex() {
          return this.index
        }
        setIndex(t) {
          return Array.isArray(t) ? (this.index = new (ii(t) > 65535 ? ti : $e)(t, 1)) : (this.index = t), this
        }
        getAttribute(t) {
          return this.attributes[t]
        }
        setAttribute(t, e) {
          return (this.attributes[t] = e), this
        }
        deleteAttribute(t) {
          return delete this.attributes[t], this
        }
        hasAttribute(t) {
          return void 0 !== this.attributes[t]
        }
        addGroup(t, e, i = 0) {
          this.groups.push({ start: t, count: e, materialIndex: i })
        }
        clearGroups() {
          this.groups = []
        }
        setDrawRange(t, e) {
          ;(this.drawRange.start = t), (this.drawRange.count = e)
        }
        applyMatrix4(t) {
          const e = this.attributes.position
          void 0 !== e && (e.applyMatrix4(t), (e.needsUpdate = !0))
          const i = this.attributes.normal
          if (void 0 !== i) {
            const e = new mt().getNormalMatrix(t)
            i.applyNormalMatrix(e), (i.needsUpdate = !0)
          }
          const n = this.attributes.tangent
          return (
            void 0 !== n && (n.transformDirection(t), (n.needsUpdate = !0)),
            null !== this.boundingBox && this.computeBoundingBox(),
            null !== this.boundingSphere && this.computeBoundingSphere(),
            this
          )
        }
        applyQuaternion(t) {
          return si.makeRotationFromQuaternion(t), this.applyMatrix4(si), this
        }
        rotateX(t) {
          return si.makeRotationX(t), this.applyMatrix4(si), this
        }
        rotateY(t) {
          return si.makeRotationY(t), this.applyMatrix4(si), this
        }
        rotateZ(t) {
          return si.makeRotationZ(t), this.applyMatrix4(si), this
        }
        translate(t, e, i) {
          return si.makeTranslation(t, e, i), this.applyMatrix4(si), this
        }
        scale(t, e, i) {
          return si.makeScale(t, e, i), this.applyMatrix4(si), this
        }
        lookAt(t) {
          return ri.lookAt(t), ri.updateMatrix(), this.applyMatrix4(ri.matrix), this
        }
        center() {
          return (
            this.computeBoundingBox(), this.boundingBox.getCenter(ai).negate(), this.translate(ai.x, ai.y, ai.z), this
          )
        }
        setFromPoints(t) {
          const e = []
          for (let i = 0, n = t.length; i < n; i++) {
            const n = t[i]
            e.push(n.x, n.y, n.z || 0)
          }
          return this.setAttribute('position', new ei(e, 3)), this
        }
        computeBoundingBox() {
          null === this.boundingBox && (this.boundingBox = new Bt())
          const t = this.attributes.position,
            e = this.morphAttributes.position
          if (t && t.isGLBufferAttribute)
            this.boundingBox.set(new Et(-1 / 0, -1 / 0, -1 / 0), new Et(1 / 0, 1 / 0, 1 / 0))
          else {
            if (void 0 !== t) {
              if ((this.boundingBox.setFromBufferAttribute(t), e))
                for (let t = 0, i = e.length; t < i; t++) {
                  const i = e[t]
                  oi.setFromBufferAttribute(i),
                    this.morphTargetsRelative
                      ? (ci.addVectors(this.boundingBox.min, oi.min),
                        this.boundingBox.expandByPoint(ci),
                        ci.addVectors(this.boundingBox.max, oi.max),
                        this.boundingBox.expandByPoint(ci))
                      : (this.boundingBox.expandByPoint(oi.min), this.boundingBox.expandByPoint(oi.max))
                }
            } else this.boundingBox.makeEmpty()
            isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)
          }
        }
        computeBoundingSphere() {
          null === this.boundingSphere && (this.boundingSphere = new Yt())
          const t = this.attributes.position,
            e = this.morphAttributes.position
          if (t && t.isGLBufferAttribute) this.boundingSphere.set(new Et(), 1 / 0)
          else if (t) {
            const i = this.boundingSphere.center
            if ((oi.setFromBufferAttribute(t), e))
              for (let t = 0, s = e.length; t < s; t++) {
                const i = e[t]
                li.setFromBufferAttribute(i),
                  this.morphTargetsRelative
                    ? (ci.addVectors(oi.min, li.min),
                      oi.expandByPoint(ci),
                      ci.addVectors(oi.max, li.max),
                      oi.expandByPoint(ci))
                    : (oi.expandByPoint(li.min), oi.expandByPoint(li.max))
              }
            oi.getCenter(i)
            let n = 0
            for (let e = 0, s = t.count; e < s; e++)
              ci.fromBufferAttribute(t, e), (n = Math.max(n, i.distanceToSquared(ci)))
            if (e)
              for (let s = 0, r = e.length; s < r; s++) {
                const r = e[s],
                  a = this.morphTargetsRelative
                for (let e = 0, s = r.count; e < s; e++)
                  ci.fromBufferAttribute(r, e),
                    a && (ai.fromBufferAttribute(t, e), ci.add(ai)),
                    (n = Math.max(n, i.distanceToSquared(ci)))
              }
            ;(this.boundingSphere.radius = Math.sqrt(n)), isNaN(this.boundingSphere.radius)
          }
        }
        computeFaceNormals() {}
        computeTangents() {
          const t = this.index,
            e = this.attributes
          if (null === t || void 0 === e.position || void 0 === e.normal || void 0 === e.uv) return
          const i = t.array,
            n = e.position.array,
            s = e.normal.array,
            r = e.uv.array,
            a = n.length / 3
          void 0 === e.tangent && this.setAttribute('tangent', new Ze(new Float32Array(4 * a), 4))
          const o = e.tangent.array,
            l = [],
            c = []
          for (let M = 0; M < a; M++) (l[M] = new Et()), (c[M] = new Et())
          const h = new Et(),
            u = new Et(),
            d = new Et(),
            p = new gt(),
            A = new gt(),
            g = new gt(),
            m = new Et(),
            f = new Et()
          function v(t, e, i) {
            h.fromArray(n, 3 * t),
              u.fromArray(n, 3 * e),
              d.fromArray(n, 3 * i),
              p.fromArray(r, 2 * t),
              A.fromArray(r, 2 * e),
              g.fromArray(r, 2 * i),
              u.sub(h),
              d.sub(h),
              A.sub(p),
              g.sub(p)
            const s = 1 / (A.x * g.y - g.x * A.y)
            isFinite(s) &&
              (m.copy(u).multiplyScalar(g.y).addScaledVector(d, -A.y).multiplyScalar(s),
              f.copy(d).multiplyScalar(A.x).addScaledVector(u, -g.x).multiplyScalar(s),
              l[t].add(m),
              l[e].add(m),
              l[i].add(m),
              c[t].add(f),
              c[e].add(f),
              c[i].add(f))
          }
          let y = this.groups
          0 === y.length && (y = [{ start: 0, count: i.length }])
          for (let M = 0, E = y.length; M < E; ++M) {
            const t = y[M],
              e = t.start
            for (let n = e, s = e + t.count; n < s; n += 3) v(i[n + 0], i[n + 1], i[n + 2])
          }
          const x = new Et(),
            w = new Et(),
            _ = new Et(),
            I = new Et()
          function C(t) {
            _.fromArray(s, 3 * t), I.copy(_)
            const e = l[t]
            x.copy(e), x.sub(_.multiplyScalar(_.dot(e))).normalize(), w.crossVectors(I, e)
            const i = w.dot(c[t]) < 0 ? -1 : 1
            ;(o[4 * t] = x.x), (o[4 * t + 1] = x.y), (o[4 * t + 2] = x.z), (o[4 * t + 3] = i)
          }
          for (let M = 0, E = y.length; M < E; ++M) {
            const t = y[M],
              e = t.start
            for (let n = e, s = e + t.count; n < s; n += 3) C(i[n + 0]), C(i[n + 1]), C(i[n + 2])
          }
        }
        computeVertexNormals() {
          const t = this.index,
            e = this.getAttribute('position')
          if (void 0 !== e) {
            let i = this.getAttribute('normal')
            if (void 0 === i) (i = new Ze(new Float32Array(3 * e.count), 3)), this.setAttribute('normal', i)
            else for (let t = 0, e = i.count; t < e; t++) i.setXYZ(t, 0, 0, 0)
            const n = new Et(),
              s = new Et(),
              r = new Et(),
              a = new Et(),
              o = new Et(),
              l = new Et(),
              c = new Et(),
              h = new Et()
            if (t)
              for (let u = 0, d = t.count; u < d; u += 3) {
                const d = t.getX(u + 0),
                  p = t.getX(u + 1),
                  A = t.getX(u + 2)
                n.fromBufferAttribute(e, d),
                  s.fromBufferAttribute(e, p),
                  r.fromBufferAttribute(e, A),
                  c.subVectors(r, s),
                  h.subVectors(n, s),
                  c.cross(h),
                  a.fromBufferAttribute(i, d),
                  o.fromBufferAttribute(i, p),
                  l.fromBufferAttribute(i, A),
                  a.add(c),
                  o.add(c),
                  l.add(c),
                  i.setXYZ(d, a.x, a.y, a.z),
                  i.setXYZ(p, o.x, o.y, o.z),
                  i.setXYZ(A, l.x, l.y, l.z)
              }
            else
              for (let t = 0, u = e.count; t < u; t += 3)
                n.fromBufferAttribute(e, t + 0),
                  s.fromBufferAttribute(e, t + 1),
                  r.fromBufferAttribute(e, t + 2),
                  c.subVectors(r, s),
                  h.subVectors(n, s),
                  c.cross(h),
                  i.setXYZ(t + 0, c.x, c.y, c.z),
                  i.setXYZ(t + 1, c.x, c.y, c.z),
                  i.setXYZ(t + 2, c.x, c.y, c.z)
            this.normalizeNormals(), (i.needsUpdate = !0)
          }
        }
        merge(t, e) {
          if (!t || !t.isBufferGeometry) return
          void 0 === e && (e = 0)
          const i = this.attributes
          for (const n in i) {
            if (void 0 === t.attributes[n]) continue
            const s = i[n].array,
              r = t.attributes[n],
              a = r.array,
              o = r.itemSize * e,
              l = Math.min(a.length, s.length - o)
            for (let t = 0, e = o; t < l; t++, e++) s[e] = a[t]
          }
          return this
        }
        normalizeNormals() {
          const t = this.attributes.normal
          for (let e = 0, i = t.count; e < i; e++)
            ci.fromBufferAttribute(t, e), ci.normalize(), t.setXYZ(e, ci.x, ci.y, ci.z)
        }
        toNonIndexed() {
          function t(t, e) {
            const i = t.array,
              n = t.itemSize,
              s = t.normalized,
              r = new i.constructor(e.length * n)
            let a = 0,
              o = 0
            for (let l = 0, c = e.length; l < c; l++) {
              a = t.isInterleavedBufferAttribute ? e[l] * t.data.stride + t.offset : e[l] * n
              for (let t = 0; t < n; t++) r[o++] = i[a++]
            }
            return new Ze(r, n, s)
          }
          if (null === this.index) return this
          const e = new hi(),
            i = this.index.array,
            n = this.attributes
          for (const a in n) {
            const s = t(n[a], i)
            e.setAttribute(a, s)
          }
          const s = this.morphAttributes
          for (const a in s) {
            const n = [],
              r = s[a]
            for (let e = 0, s = r.length; e < s; e++) {
              const s = t(r[e], i)
              n.push(s)
            }
            e.morphAttributes[a] = n
          }
          e.morphTargetsRelative = this.morphTargetsRelative
          const r = this.groups
          for (let a = 0, o = r.length; a < o; a++) {
            const t = r[a]
            e.addGroup(t.start, t.count, t.materialIndex)
          }
          return e
        }
        toJSON() {
          const t = { metadata: { version: 4.5, type: 'BufferGeometry', generator: 'BufferGeometry.toJSON' } }
          if (
            ((t.uuid = this.uuid),
            (t.type = this.type),
            '' !== this.name && (t.name = this.name),
            Object.keys(this.userData).length > 0 && (t.userData = this.userData),
            void 0 !== this.parameters)
          ) {
            const e = this.parameters
            for (const i in e) void 0 !== e[i] && (t[i] = e[i])
            return t
          }
          t.data = { attributes: {} }
          const e = this.index
          null !== e && (t.data.index = { type: e.array.constructor.name, array: Array.prototype.slice.call(e.array) })
          const i = this.attributes
          for (const o in i) {
            const e = i[o]
            t.data.attributes[o] = e.toJSON(t.data)
          }
          const n = {}
          let s = !1
          for (const o in this.morphAttributes) {
            const e = this.morphAttributes[o],
              i = []
            for (let n = 0, s = e.length; n < s; n++) {
              const s = e[n]
              i.push(s.toJSON(t.data))
            }
            i.length > 0 && ((n[o] = i), (s = !0))
          }
          s && ((t.data.morphAttributes = n), (t.data.morphTargetsRelative = this.morphTargetsRelative))
          const r = this.groups
          r.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(r)))
          const a = this.boundingSphere
          return null !== a && (t.data.boundingSphere = { center: a.center.toArray(), radius: a.radius }), t
        }
        clone() {
          return new hi().copy(this)
        }
        copy(t) {
          ;(this.index = null),
            (this.attributes = {}),
            (this.morphAttributes = {}),
            (this.groups = []),
            (this.boundingBox = null),
            (this.boundingSphere = null)
          const e = {}
          this.name = t.name
          const i = t.index
          null !== i && this.setIndex(i.clone(e))
          const n = t.attributes
          for (const l in n) {
            const t = n[l]
            this.setAttribute(l, t.clone(e))
          }
          const s = t.morphAttributes
          for (const l in s) {
            const t = [],
              i = s[l]
            for (let n = 0, s = i.length; n < s; n++) t.push(i[n].clone(e))
            this.morphAttributes[l] = t
          }
          this.morphTargetsRelative = t.morphTargetsRelative
          const r = t.groups
          for (let l = 0, c = r.length; l < c; l++) {
            const t = r[l]
            this.addGroup(t.start, t.count, t.materialIndex)
          }
          const a = t.boundingBox
          null !== a && (this.boundingBox = a.clone())
          const o = t.boundingSphere
          return (
            null !== o && (this.boundingSphere = o.clone()),
            (this.drawRange.start = t.drawRange.start),
            (this.drawRange.count = t.drawRange.count),
            (this.userData = t.userData),
            this
          )
        }
        dispose() {
          this.dispatchEvent({ type: 'dispose' })
        }
      }
      hi.prototype.isBufferGeometry = !0
      const ui = new ne(),
        di = new ie(),
        pi = new Yt(),
        Ai = new Et(),
        gi = new Et(),
        mi = new Et(),
        fi = new Et(),
        vi = new Et(),
        yi = new Et(),
        xi = new Et(),
        wi = new Et(),
        _i = new Et(),
        Ii = new gt(),
        Ci = new gt(),
        Mi = new gt(),
        Ei = new Et(),
        bi = new Et()
      class Si extends Se {
        constructor(t = new hi(), e = new Je()) {
          super(), (this.type = 'Mesh'), (this.geometry = t), (this.material = e), this.updateMorphTargets()
        }
        copy(t) {
          return (
            super.copy(t),
            void 0 !== t.morphTargetInfluences && (this.morphTargetInfluences = t.morphTargetInfluences.slice()),
            void 0 !== t.morphTargetDictionary &&
              (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)),
            (this.material = t.material),
            (this.geometry = t.geometry),
            this
          )
        }
        updateMorphTargets() {
          const t = this.geometry
          if (t.isBufferGeometry) {
            const e = t.morphAttributes,
              i = Object.keys(e)
            if (i.length > 0) {
              const t = e[i[0]]
              if (void 0 !== t) {
                ;(this.morphTargetInfluences = []), (this.morphTargetDictionary = {})
                for (let e = 0, i = t.length; e < i; e++) {
                  const i = t[e].name || String(e)
                  this.morphTargetInfluences.push(0), (this.morphTargetDictionary[i] = e)
                }
              }
            }
          } else {
            const e = t.morphTargets
            void 0 !== e && e.length
          }
        }
        raycast(t, e) {
          const i = this.geometry,
            n = this.material,
            s = this.matrixWorld
          if (void 0 === n) return
          if (
            (null === i.boundingSphere && i.computeBoundingSphere(),
            pi.copy(i.boundingSphere),
            pi.applyMatrix4(s),
            !1 === t.ray.intersectsSphere(pi))
          )
            return
          if (
            (ui.copy(s).invert(),
            di.copy(t.ray).applyMatrix4(ui),
            null !== i.boundingBox && !1 === di.intersectsBox(i.boundingBox))
          )
            return
          let r
          if (i.isBufferGeometry) {
            const s = i.index,
              a = i.attributes.position,
              o = i.morphAttributes.position,
              l = i.morphTargetsRelative,
              c = i.attributes.uv,
              h = i.attributes.uv2,
              u = i.groups,
              d = i.drawRange
            if (null !== s)
              if (Array.isArray(n))
                for (let i = 0, p = u.length; i < p; i++) {
                  const p = u[i],
                    A = n[p.materialIndex]
                  for (
                    let i = Math.max(p.start, d.start), n = Math.min(p.start + p.count, d.start + d.count);
                    i < n;
                    i += 3
                  ) {
                    const n = s.getX(i),
                      u = s.getX(i + 1),
                      d = s.getX(i + 2)
                    ;(r = Bi(this, A, t, di, a, o, l, c, h, n, u, d)),
                      r && ((r.faceIndex = Math.floor(i / 3)), (r.face.materialIndex = p.materialIndex), e.push(r))
                  }
                }
              else
                for (let i = Math.max(0, d.start), p = Math.min(s.count, d.start + d.count); i < p; i += 3) {
                  const u = s.getX(i),
                    d = s.getX(i + 1),
                    p = s.getX(i + 2)
                  ;(r = Bi(this, n, t, di, a, o, l, c, h, u, d, p)), r && ((r.faceIndex = Math.floor(i / 3)), e.push(r))
                }
            else if (void 0 !== a)
              if (Array.isArray(n))
                for (let i = 0, p = u.length; i < p; i++) {
                  const s = u[i],
                    p = n[s.materialIndex]
                  for (
                    let i = Math.max(s.start, d.start), n = Math.min(s.start + s.count, d.start + d.count);
                    i < n;
                    i += 3
                  )
                    (r = Bi(this, p, t, di, a, o, l, c, h, i, i + 1, i + 2)),
                      r && ((r.faceIndex = Math.floor(i / 3)), (r.face.materialIndex = s.materialIndex), e.push(r))
                }
              else
                for (let i = Math.max(0, d.start), p = Math.min(a.count, d.start + d.count); i < p; i += 3)
                  (r = Bi(this, n, t, di, a, o, l, c, h, i, i + 1, i + 2)),
                    r && ((r.faceIndex = Math.floor(i / 3)), e.push(r))
          } else i.isGeometry
        }
      }
      function Bi(t, e, i, n, s, r, a, o, l, c, h, u) {
        Ai.fromBufferAttribute(s, c), gi.fromBufferAttribute(s, h), mi.fromBufferAttribute(s, u)
        const d = t.morphTargetInfluences
        if (r && d) {
          xi.set(0, 0, 0), wi.set(0, 0, 0), _i.set(0, 0, 0)
          for (let t = 0, e = r.length; t < e; t++) {
            const e = d[t],
              i = r[t]
            0 !== e &&
              (fi.fromBufferAttribute(i, c),
              vi.fromBufferAttribute(i, h),
              yi.fromBufferAttribute(i, u),
              a
                ? (xi.addScaledVector(fi, e), wi.addScaledVector(vi, e), _i.addScaledVector(yi, e))
                : (xi.addScaledVector(fi.sub(Ai), e),
                  wi.addScaledVector(vi.sub(gi), e),
                  _i.addScaledVector(yi.sub(mi), e)))
          }
          Ai.add(xi), gi.add(wi), mi.add(_i)
        }
        t.isSkinnedMesh && (t.boneTransform(c, Ai), t.boneTransform(h, gi), t.boneTransform(u, mi))
        const p = (function (t, e, i, n, s, r, a, o) {
          let l
          if (
            ((l = 1 === e.side ? n.intersectTriangle(a, r, s, !0, o) : n.intersectTriangle(s, r, a, 2 !== e.side, o)),
            null === l)
          )
            return null
          bi.copy(o), bi.applyMatrix4(t.matrixWorld)
          const c = i.ray.origin.distanceTo(bi)
          return c < i.near || c > i.far ? null : { distance: c, point: bi.clone(), object: t }
        })(t, e, i, n, Ai, gi, mi, Ei)
        if (p) {
          o &&
            (Ii.fromBufferAttribute(o, c),
            Ci.fromBufferAttribute(o, h),
            Mi.fromBufferAttribute(o, u),
            (p.uv = ke.getUV(Ei, Ai, gi, mi, Ii, Ci, Mi, new gt()))),
            l &&
              (Ii.fromBufferAttribute(l, c),
              Ci.fromBufferAttribute(l, h),
              Mi.fromBufferAttribute(l, u),
              (p.uv2 = ke.getUV(Ei, Ai, gi, mi, Ii, Ci, Mi, new gt())))
          const t = { a: c, b: h, c: u, normal: new Et(), materialIndex: 0 }
          ke.getNormal(Ai, gi, mi, t.normal), (p.face = t)
        }
        return p
      }
      Si.prototype.isMesh = !0
      class Ti extends hi {
        constructor(t = 1, e = 1, i = 1, n = 1, s = 1, r = 1) {
          super(),
            (this.type = 'BoxGeometry'),
            (this.parameters = { width: t, height: e, depth: i, widthSegments: n, heightSegments: s, depthSegments: r })
          const a = this
          ;(n = Math.floor(n)), (s = Math.floor(s)), (r = Math.floor(r))
          const o = [],
            l = [],
            c = [],
            h = []
          let u = 0,
            d = 0
          function p(t, e, i, n, s, r, p, A, g, m, f) {
            const v = r / g,
              y = p / m,
              x = r / 2,
              w = p / 2,
              _ = A / 2,
              I = g + 1,
              C = m + 1
            let M = 0,
              E = 0
            const b = new Et()
            for (let a = 0; a < C; a++) {
              const r = a * y - w
              for (let o = 0; o < I; o++) {
                const u = o * v - x
                ;(b[t] = u * n),
                  (b[e] = r * s),
                  (b[i] = _),
                  l.push(b.x, b.y, b.z),
                  (b[t] = 0),
                  (b[e] = 0),
                  (b[i] = A > 0 ? 1 : -1),
                  c.push(b.x, b.y, b.z),
                  h.push(o / g),
                  h.push(1 - a / m),
                  (M += 1)
              }
            }
            for (let a = 0; a < m; a++)
              for (let t = 0; t < g; t++) {
                const e = u + t + I * a,
                  i = u + t + I * (a + 1),
                  n = u + (t + 1) + I * (a + 1),
                  s = u + (t + 1) + I * a
                o.push(e, i, s), o.push(i, n, s), (E += 6)
              }
            a.addGroup(d, E, f), (d += E), (u += M)
          }
          p('z', 'y', 'x', -1, -1, i, e, t, r, s, 0),
            p('z', 'y', 'x', 1, -1, i, e, -t, r, s, 1),
            p('x', 'z', 'y', 1, 1, t, i, e, n, r, 2),
            p('x', 'z', 'y', 1, -1, t, i, -e, n, r, 3),
            p('x', 'y', 'z', 1, -1, t, e, i, n, s, 4),
            p('x', 'y', 'z', -1, -1, t, e, -i, n, s, 5),
            this.setIndex(o),
            this.setAttribute('position', new ei(l, 3)),
            this.setAttribute('normal', new ei(c, 3)),
            this.setAttribute('uv', new ei(h, 2))
        }
        static fromJSON(t) {
          return new Ti(t.width, t.height, t.depth, t.widthSegments, t.heightSegments, t.depthSegments)
        }
      }
      function Li(t) {
        const e = {}
        for (const i in t) {
          e[i] = {}
          for (const n in t[i]) {
            const s = t[i][n]
            s &&
            (s.isColor ||
              s.isMatrix3 ||
              s.isMatrix4 ||
              s.isVector2 ||
              s.isVector3 ||
              s.isVector4 ||
              s.isTexture ||
              s.isQuaternion)
              ? (e[i][n] = s.clone())
              : Array.isArray(s)
              ? (e[i][n] = s.slice())
              : (e[i][n] = s)
          }
        }
        return e
      }
      function Di(t) {
        const e = {}
        for (let i = 0; i < t.length; i++) {
          const n = Li(t[i])
          for (const t in n) e[t] = n[t]
        }
        return e
      }
      const Qi = { clone: Li, merge: Di }
      class Ri extends Ge {
        constructor(t) {
          super(),
            (this.type = 'ShaderMaterial'),
            (this.defines = {}),
            (this.uniforms = {}),
            (this.vertexShader =
              'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}'),
            (this.fragmentShader = 'void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}'),
            (this.linewidth = 1),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.fog = !1),
            (this.lights = !1),
            (this.clipping = !1),
            (this.extensions = { derivatives: !1, fragDepth: !1, drawBuffers: !1, shaderTextureLOD: !1 }),
            (this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv2: [0, 0] }),
            (this.index0AttributeName = void 0),
            (this.uniformsNeedUpdate = !1),
            (this.glslVersion = null),
            void 0 !== t && (t.attributes, this.setValues(t))
        }
        copy(t) {
          return (
            super.copy(t),
            (this.fragmentShader = t.fragmentShader),
            (this.vertexShader = t.vertexShader),
            (this.uniforms = Li(t.uniforms)),
            (this.defines = Object.assign({}, t.defines)),
            (this.wireframe = t.wireframe),
            (this.wireframeLinewidth = t.wireframeLinewidth),
            (this.lights = t.lights),
            (this.clipping = t.clipping),
            (this.extensions = Object.assign({}, t.extensions)),
            (this.glslVersion = t.glslVersion),
            this
          )
        }
        toJSON(t) {
          const e = super.toJSON(t)
          ;(e.glslVersion = this.glslVersion), (e.uniforms = {})
          for (const n in this.uniforms) {
            const i = this.uniforms[n].value
            i && i.isTexture
              ? (e.uniforms[n] = { type: 't', value: i.toJSON(t).uuid })
              : i && i.isColor
              ? (e.uniforms[n] = { type: 'c', value: i.getHex() })
              : i && i.isVector2
              ? (e.uniforms[n] = { type: 'v2', value: i.toArray() })
              : i && i.isVector3
              ? (e.uniforms[n] = { type: 'v3', value: i.toArray() })
              : i && i.isVector4
              ? (e.uniforms[n] = { type: 'v4', value: i.toArray() })
              : i && i.isMatrix3
              ? (e.uniforms[n] = { type: 'm3', value: i.toArray() })
              : i && i.isMatrix4
              ? (e.uniforms[n] = { type: 'm4', value: i.toArray() })
              : (e.uniforms[n] = { value: i })
          }
          Object.keys(this.defines).length > 0 && (e.defines = this.defines),
            (e.vertexShader = this.vertexShader),
            (e.fragmentShader = this.fragmentShader)
          const i = {}
          for (const n in this.extensions) !0 === this.extensions[n] && (i[n] = !0)
          return Object.keys(i).length > 0 && (e.extensions = i), e
        }
      }
      Ri.prototype.isShaderMaterial = !0
      class Pi extends Se {
        constructor() {
          super(),
            (this.type = 'Camera'),
            (this.matrixWorldInverse = new ne()),
            (this.projectionMatrix = new ne()),
            (this.projectionMatrixInverse = new ne())
        }
        copy(t, e) {
          return (
            super.copy(t, e),
            this.matrixWorldInverse.copy(t.matrixWorldInverse),
            this.projectionMatrix.copy(t.projectionMatrix),
            this.projectionMatrixInverse.copy(t.projectionMatrixInverse),
            this
          )
        }
        getWorldDirection(t) {
          this.updateWorldMatrix(!0, !1)
          const e = this.matrixWorld.elements
          return t.set(-e[8], -e[9], -e[10]).normalize()
        }
        updateMatrixWorld(t) {
          super.updateMatrixWorld(t), this.matrixWorldInverse.copy(this.matrixWorld).invert()
        }
        updateWorldMatrix(t, e) {
          super.updateWorldMatrix(t, e), this.matrixWorldInverse.copy(this.matrixWorld).invert()
        }
        clone() {
          return new this.constructor().copy(this)
        }
      }
      Pi.prototype.isCamera = !0
      class Ni extends Pi {
        constructor(t = 50, e = 1, i = 0.1, n = 2e3) {
          super(),
            (this.type = 'PerspectiveCamera'),
            (this.fov = t),
            (this.zoom = 1),
            (this.near = i),
            (this.far = n),
            (this.focus = 10),
            (this.aspect = e),
            (this.view = null),
            (this.filmGauge = 35),
            (this.filmOffset = 0),
            this.updateProjectionMatrix()
        }
        copy(t, e) {
          return (
            super.copy(t, e),
            (this.fov = t.fov),
            (this.zoom = t.zoom),
            (this.near = t.near),
            (this.far = t.far),
            (this.focus = t.focus),
            (this.aspect = t.aspect),
            (this.view = null === t.view ? null : Object.assign({}, t.view)),
            (this.filmGauge = t.filmGauge),
            (this.filmOffset = t.filmOffset),
            this
          )
        }
        setFocalLength(t) {
          const e = (0.5 * this.getFilmHeight()) / t
          ;(this.fov = 2 * at * Math.atan(e)), this.updateProjectionMatrix()
        }
        getFocalLength() {
          const t = Math.tan(0.5 * rt * this.fov)
          return (0.5 * this.getFilmHeight()) / t
        }
        getEffectiveFOV() {
          return 2 * at * Math.atan(Math.tan(0.5 * rt * this.fov) / this.zoom)
        }
        getFilmWidth() {
          return this.filmGauge * Math.min(this.aspect, 1)
        }
        getFilmHeight() {
          return this.filmGauge / Math.max(this.aspect, 1)
        }
        setViewOffset(t, e, i, n, s, r) {
          ;(this.aspect = t / e),
            null === this.view &&
              (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }),
            (this.view.enabled = !0),
            (this.view.fullWidth = t),
            (this.view.fullHeight = e),
            (this.view.offsetX = i),
            (this.view.offsetY = n),
            (this.view.width = s),
            (this.view.height = r),
            this.updateProjectionMatrix()
        }
        clearViewOffset() {
          null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
        }
        updateProjectionMatrix() {
          const t = this.near
          let e = (t * Math.tan(0.5 * rt * this.fov)) / this.zoom,
            i = 2 * e,
            n = this.aspect * i,
            s = -0.5 * n
          const r = this.view
          if (null !== this.view && this.view.enabled) {
            const t = r.fullWidth,
              a = r.fullHeight
            ;(s += (r.offsetX * n) / t), (e -= (r.offsetY * i) / a), (n *= r.width / t), (i *= r.height / a)
          }
          const a = this.filmOffset
          0 !== a && (s += (t * a) / this.getFilmWidth()),
            this.projectionMatrix.makePerspective(s, s + n, e, e - i, t, this.far),
            this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
        }
        toJSON(t) {
          const e = super.toJSON(t)
          return (
            (e.object.fov = this.fov),
            (e.object.zoom = this.zoom),
            (e.object.near = this.near),
            (e.object.far = this.far),
            (e.object.focus = this.focus),
            (e.object.aspect = this.aspect),
            null !== this.view && (e.object.view = Object.assign({}, this.view)),
            (e.object.filmGauge = this.filmGauge),
            (e.object.filmOffset = this.filmOffset),
            e
          )
        }
      }
      Ni.prototype.isPerspectiveCamera = !0
      class Fi extends Se {
        constructor(t, e, i) {
          if ((super(), (this.type = 'CubeCamera'), !0 !== i.isWebGLCubeRenderTarget)) return
          this.renderTarget = i
          const n = new Ni(90, 1, t, e)
          ;(n.layers = this.layers), n.up.set(0, -1, 0), n.lookAt(new Et(1, 0, 0)), this.add(n)
          const s = new Ni(90, 1, t, e)
          ;(s.layers = this.layers), s.up.set(0, -1, 0), s.lookAt(new Et(-1, 0, 0)), this.add(s)
          const r = new Ni(90, 1, t, e)
          ;(r.layers = this.layers), r.up.set(0, 0, 1), r.lookAt(new Et(0, 1, 0)), this.add(r)
          const a = new Ni(90, 1, t, e)
          ;(a.layers = this.layers), a.up.set(0, 0, -1), a.lookAt(new Et(0, -1, 0)), this.add(a)
          const o = new Ni(90, 1, t, e)
          ;(o.layers = this.layers), o.up.set(0, -1, 0), o.lookAt(new Et(0, 0, 1)), this.add(o)
          const l = new Ni(90, 1, t, e)
          ;(l.layers = this.layers), l.up.set(0, -1, 0), l.lookAt(new Et(0, 0, -1)), this.add(l)
        }
        update(t, e) {
          null === this.parent && this.updateMatrixWorld()
          const i = this.renderTarget,
            [n, s, r, a, o, l] = this.children,
            c = t.xr.enabled,
            h = t.getRenderTarget()
          t.xr.enabled = !1
          const u = i.texture.generateMipmaps
          ;(i.texture.generateMipmaps = !1),
            t.setRenderTarget(i, 0),
            t.render(e, n),
            t.setRenderTarget(i, 1),
            t.render(e, s),
            t.setRenderTarget(i, 2),
            t.render(e, r),
            t.setRenderTarget(i, 3),
            t.render(e, a),
            t.setRenderTarget(i, 4),
            t.render(e, o),
            (i.texture.generateMipmaps = u),
            t.setRenderTarget(i, 5),
            t.render(e, l),
            t.setRenderTarget(h),
            (t.xr.enabled = c)
        }
      }
      class Ui extends xt {
        constructor(t, e, i, n, s, r, a, o, l, c) {
          super(
            (t = void 0 !== t ? t : []),
            (e = void 0 !== e ? e : 301),
            i,
            n,
            s,
            r,
            (a = void 0 !== a ? a : 1022),
            o,
            l,
            c,
          ),
            (this.flipY = !1)
        }
        get images() {
          return this.image
        }
        set images(t) {
          this.image = t
        }
      }
      Ui.prototype.isCubeTexture = !0
      class ki extends It {
        constructor(t, e, i) {
          Number.isInteger(e) && (e = i),
            super(t, t, e),
            (e = e || {}),
            (this.texture = new Ui(
              void 0,
              e.mapping,
              e.wrapS,
              e.wrapT,
              e.magFilter,
              e.minFilter,
              e.format,
              e.type,
              e.anisotropy,
              e.encoding,
            )),
            (this.texture.isRenderTargetTexture = !0),
            (this.texture.generateMipmaps = void 0 !== e.generateMipmaps && e.generateMipmaps),
            (this.texture.minFilter = void 0 !== e.minFilter ? e.minFilter : 1006),
            (this.texture._needsFlipEnvMap = !1)
        }
        fromEquirectangularTexture(t, e) {
          ;(this.texture.type = e.type),
            (this.texture.format = 1023),
            (this.texture.encoding = e.encoding),
            (this.texture.generateMipmaps = e.generateMipmaps),
            (this.texture.minFilter = e.minFilter),
            (this.texture.magFilter = e.magFilter)
          const i = { tEquirect: { value: null } },
            n =
              '\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t',
            s =
              '\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t',
            r = new Ti(5, 5, 5),
            a = new Ri({
              name: 'CubemapFromEquirect',
              uniforms: Li(i),
              vertexShader: n,
              fragmentShader: s,
              side: 1,
              blending: 0,
            })
          a.uniforms.tEquirect.value = e
          const o = new Si(r, a),
            l = e.minFilter
          return (
            1008 === e.minFilter && (e.minFilter = 1006),
            new Fi(1, 10, this).update(t, o),
            (e.minFilter = l),
            o.geometry.dispose(),
            o.material.dispose(),
            this
          )
        }
        clear(t, e, i, n) {
          const s = t.getRenderTarget()
          for (let r = 0; r < 6; r++) t.setRenderTarget(this, r), t.clear(e, i, n)
          t.setRenderTarget(s)
        }
      }
      ki.prototype.isWebGLCubeRenderTarget = !0
      const Oi = new Et(),
        Gi = new Et(),
        zi = new mt()
      class Vi {
        constructor(t = new Et(1, 0, 0), e = 0) {
          ;(this.normal = t), (this.constant = e)
        }
        set(t, e) {
          return this.normal.copy(t), (this.constant = e), this
        }
        setComponents(t, e, i, n) {
          return this.normal.set(t, e, i), (this.constant = n), this
        }
        setFromNormalAndCoplanarPoint(t, e) {
          return this.normal.copy(t), (this.constant = -e.dot(this.normal)), this
        }
        setFromCoplanarPoints(t, e, i) {
          const n = Oi.subVectors(i, e).cross(Gi.subVectors(t, e)).normalize()
          return this.setFromNormalAndCoplanarPoint(n, t), this
        }
        copy(t) {
          return this.normal.copy(t.normal), (this.constant = t.constant), this
        }
        normalize() {
          const t = 1 / this.normal.length()
          return this.normal.multiplyScalar(t), (this.constant *= t), this
        }
        negate() {
          return (this.constant *= -1), this.normal.negate(), this
        }
        distanceToPoint(t) {
          return this.normal.dot(t) + this.constant
        }
        distanceToSphere(t) {
          return this.distanceToPoint(t.center) - t.radius
        }
        projectPoint(t, e) {
          return e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)
        }
        intersectLine(t, e) {
          const i = t.delta(Oi),
            n = this.normal.dot(i)
          if (0 === n) return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : null
          const s = -(t.start.dot(this.normal) + this.constant) / n
          return s < 0 || s > 1 ? null : e.copy(i).multiplyScalar(s).add(t.start)
        }
        intersectsLine(t) {
          const e = this.distanceToPoint(t.start),
            i = this.distanceToPoint(t.end)
          return (e < 0 && i > 0) || (i < 0 && e > 0)
        }
        intersectsBox(t) {
          return t.intersectsPlane(this)
        }
        intersectsSphere(t) {
          return t.intersectsPlane(this)
        }
        coplanarPoint(t) {
          return t.copy(this.normal).multiplyScalar(-this.constant)
        }
        applyMatrix4(t, e) {
          const i = e || zi.getNormalMatrix(t),
            n = this.coplanarPoint(Oi).applyMatrix4(t),
            s = this.normal.applyMatrix3(i).normalize()
          return (this.constant = -n.dot(s)), this
        }
        translate(t) {
          return (this.constant -= t.dot(this.normal)), this
        }
        equals(t) {
          return t.normal.equals(this.normal) && t.constant === this.constant
        }
        clone() {
          return new this.constructor().copy(this)
        }
      }
      Vi.prototype.isPlane = !0
      const Hi = new Yt(),
        Wi = new Et()
      class qi {
        constructor(t = new Vi(), e = new Vi(), i = new Vi(), n = new Vi(), s = new Vi(), r = new Vi()) {
          this.planes = [t, e, i, n, s, r]
        }
        set(t, e, i, n, s, r) {
          const a = this.planes
          return a[0].copy(t), a[1].copy(e), a[2].copy(i), a[3].copy(n), a[4].copy(s), a[5].copy(r), this
        }
        copy(t) {
          const e = this.planes
          for (let i = 0; i < 6; i++) e[i].copy(t.planes[i])
          return this
        }
        setFromProjectionMatrix(t) {
          const e = this.planes,
            i = t.elements,
            n = i[0],
            s = i[1],
            r = i[2],
            a = i[3],
            o = i[4],
            l = i[5],
            c = i[6],
            h = i[7],
            u = i[8],
            d = i[9],
            p = i[10],
            A = i[11],
            g = i[12],
            m = i[13],
            f = i[14],
            v = i[15]
          return (
            e[0].setComponents(a - n, h - o, A - u, v - g).normalize(),
            e[1].setComponents(a + n, h + o, A + u, v + g).normalize(),
            e[2].setComponents(a + s, h + l, A + d, v + m).normalize(),
            e[3].setComponents(a - s, h - l, A - d, v - m).normalize(),
            e[4].setComponents(a - r, h - c, A - p, v - f).normalize(),
            e[5].setComponents(a + r, h + c, A + p, v + f).normalize(),
            this
          )
        }
        intersectsObject(t) {
          const e = t.geometry
          return (
            null === e.boundingSphere && e.computeBoundingSphere(),
            Hi.copy(e.boundingSphere).applyMatrix4(t.matrixWorld),
            this.intersectsSphere(Hi)
          )
        }
        intersectsSprite(t) {
          return (
            Hi.center.set(0, 0, 0),
            (Hi.radius = 0.7071067811865476),
            Hi.applyMatrix4(t.matrixWorld),
            this.intersectsSphere(Hi)
          )
        }
        intersectsSphere(t) {
          const e = this.planes,
            i = t.center,
            n = -t.radius
          for (let s = 0; s < 6; s++) if (e[s].distanceToPoint(i) < n) return !1
          return !0
        }
        intersectsBox(t) {
          const e = this.planes
          for (let i = 0; i < 6; i++) {
            const n = e[i]
            if (
              ((Wi.x = n.normal.x > 0 ? t.max.x : t.min.x),
              (Wi.y = n.normal.y > 0 ? t.max.y : t.min.y),
              (Wi.z = n.normal.z > 0 ? t.max.z : t.min.z),
              n.distanceToPoint(Wi) < 0)
            )
              return !1
          }
          return !0
        }
        containsPoint(t) {
          const e = this.planes
          for (let i = 0; i < 6; i++) if (e[i].distanceToPoint(t) < 0) return !1
          return !0
        }
        clone() {
          return new this.constructor().copy(this)
        }
      }
      function ji() {
        let t = null,
          e = !1,
          i = null,
          n = null
        function s(e, r) {
          i(e, r), (n = t.requestAnimationFrame(s))
        }
        return {
          start: function () {
            !0 !== e && null !== i && ((n = t.requestAnimationFrame(s)), (e = !0))
          },
          stop: function () {
            t.cancelAnimationFrame(n), (e = !1)
          },
          setAnimationLoop: function (t) {
            i = t
          },
          setContext: function (e) {
            t = e
          },
        }
      }
      function Yi(t, e) {
        const i = e.isWebGL2,
          n = new WeakMap()
        return {
          get: function (t) {
            return t.isInterleavedBufferAttribute && (t = t.data), n.get(t)
          },
          remove: function (e) {
            e.isInterleavedBufferAttribute && (e = e.data)
            const i = n.get(e)
            i && (t.deleteBuffer(i.buffer), n.delete(e))
          },
          update: function (e, s) {
            if (e.isGLBufferAttribute) {
              const t = n.get(e)
              return void (
                (!t || t.version < e.version) &&
                n.set(e, { buffer: e.buffer, type: e.type, bytesPerElement: e.elementSize, version: e.version })
              )
            }
            e.isInterleavedBufferAttribute && (e = e.data)
            const r = n.get(e)
            void 0 === r
              ? n.set(
                  e,
                  (function (e, n) {
                    const s = e.array,
                      r = e.usage,
                      a = t.createBuffer()
                    t.bindBuffer(n, a), t.bufferData(n, s, r), e.onUploadCallback()
                    let o = 5126
                    return (
                      s instanceof Float32Array
                        ? (o = 5126)
                        : s instanceof Float64Array ||
                          (s instanceof Uint16Array
                            ? e.isFloat16BufferAttribute
                              ? i && (o = 5131)
                              : (o = 5123)
                            : s instanceof Int16Array
                            ? (o = 5122)
                            : s instanceof Uint32Array
                            ? (o = 5125)
                            : s instanceof Int32Array
                            ? (o = 5124)
                            : s instanceof Int8Array
                            ? (o = 5120)
                            : (s instanceof Uint8Array || s instanceof Uint8ClampedArray) && (o = 5121)),
                      { buffer: a, type: o, bytesPerElement: s.BYTES_PER_ELEMENT, version: e.version }
                    )
                  })(e, s),
                )
              : r.version < e.version &&
                ((function (e, n, s) {
                  const r = n.array,
                    a = n.updateRange
                  t.bindBuffer(s, e),
                    -1 === a.count
                      ? t.bufferSubData(s, 0, r)
                      : (i
                          ? t.bufferSubData(s, a.offset * r.BYTES_PER_ELEMENT, r, a.offset, a.count)
                          : t.bufferSubData(
                              s,
                              a.offset * r.BYTES_PER_ELEMENT,
                              r.subarray(a.offset, a.offset + a.count),
                            ),
                        (a.count = -1))
                })(r.buffer, e, s),
                (r.version = e.version))
          },
        }
      }
      class Ji extends hi {
        constructor(t = 1, e = 1, i = 1, n = 1) {
          super(),
            (this.type = 'PlaneGeometry'),
            (this.parameters = { width: t, height: e, widthSegments: i, heightSegments: n })
          const s = t / 2,
            r = e / 2,
            a = Math.floor(i),
            o = Math.floor(n),
            l = a + 1,
            c = o + 1,
            h = t / a,
            u = e / o,
            d = [],
            p = [],
            A = [],
            g = []
          for (let m = 0; m < c; m++) {
            const t = m * u - r
            for (let e = 0; e < l; e++) {
              const i = e * h - s
              p.push(i, -t, 0), A.push(0, 0, 1), g.push(e / a), g.push(1 - m / o)
            }
          }
          for (let m = 0; m < o; m++)
            for (let t = 0; t < a; t++) {
              const e = t + l * m,
                i = t + l * (m + 1),
                n = t + 1 + l * (m + 1),
                s = t + 1 + l * m
              d.push(e, i, s), d.push(i, n, s)
            }
          this.setIndex(d),
            this.setAttribute('position', new ei(p, 3)),
            this.setAttribute('normal', new ei(A, 3)),
            this.setAttribute('uv', new ei(g, 2))
        }
        static fromJSON(t) {
          return new Ji(t.width, t.height, t.widthSegments, t.heightSegments)
        }
      }
      const Xi = {
          alphamap_fragment: '#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif',
          alphamap_pars_fragment: '#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif',
          alphatest_fragment: '#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif',
          aomap_fragment:
            '#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif',
          aomap_pars_fragment: '#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif',
          begin_vertex: 'vec3 transformed = vec3( position );',
          beginnormal_vertex:
            'vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif',
          bsdfs:
            'vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in vec3 f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn ( f90 - f0 ) * fresnel + f0;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in vec3 f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, vec3( 1.0 ), dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif',
          bumpmap_pars_fragment:
            '#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif',
          clipping_planes_fragment:
            '#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif',
          clipping_planes_pars_fragment:
            '#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif',
          clipping_planes_pars_vertex: '#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif',
          clipping_planes_vertex: '#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif',
          color_fragment:
            '#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif',
          color_pars_fragment:
            '#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif',
          color_pars_vertex:
            '#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif',
          color_vertex:
            '#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif',
          common:
            '#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}',
          cube_uv_reflection_fragment:
            '#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif',
          defaultnormal_vertex:
            'vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif',
          displacementmap_pars_vertex:
            '#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif',
          displacementmap_vertex:
            '#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif',
          emissivemap_fragment:
            '#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif',
          emissivemap_pars_fragment: '#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif',
          encodings_fragment: 'gl_FragColor = linearToOutputTexel( gl_FragColor );',
          encodings_pars_fragment:
            '\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}',
          envmap_fragment:
            '#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif',
          envmap_common_pars_fragment:
            '#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif',
          envmap_pars_fragment:
            '#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif',
          envmap_pars_vertex:
            '#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif',
          envmap_physical_pars_fragment:
            '#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif',
          envmap_vertex:
            '#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif',
          fog_vertex: '#ifdef USE_FOG\n\tfogDepth = - mvPosition.z;\n#endif',
          fog_pars_vertex: '#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif',
          fog_fragment:
            '#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif',
          fog_pars_fragment:
            '#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif',
          gradientmap_pars_fragment:
            '#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}',
          lightmap_fragment:
            '#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif',
          lightmap_pars_fragment:
            '#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif',
          lights_lambert_vertex:
            'vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif',
          lights_pars_begin:
            'uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif',
          lights_toon_fragment: 'ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;',
          lights_toon_pars_fragment:
            'varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)',
          lights_phong_fragment:
            'BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;',
          lights_phong_pars_fragment:
            'varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)',
          lights_physical_fragment:
            'PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\t#ifdef SPECULAR\n\t\tvec3 specularIntensityFactor = vec3( specularIntensity );\n\t\tvec3 specularTintFactor = specularTint;\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\t\t#endif\n\t\t#ifdef USE_SPECULARTINTMAP\n\t\t\tspecularTintFactor *= specularTintMapTexelToLinear( texture2D( specularTintMap, vUv ) ).rgb;\n\t\t#endif\n\t\tmaterial.specularColorF90 = mix( specularIntensityFactor, vec3( 1.0 ), metalnessFactor );\n\t#else\n\t\tvec3 specularIntensityFactor = vec3( 1.0 );\n\t\tvec3 specularTintFactor = vec3( 1.0 );\n\t\tmaterial.specularColorF90 = vec3( 1.0 );\n\t#endif\n\tmaterial.specularColor = mix( min( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ) * specularTintFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularColorF90 = vec3( 1.0 );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif',
          lights_physical_pars_fragment:
            'struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat specularRoughness;\n\tvec3 specularColor;\n\tvec3 specularColorF90;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), vec3( 1.0 ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularColorF90, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}',
          lights_fragment_begin:
            '\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif',
          lights_fragment_maps:
            '#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif',
          lights_fragment_end:
            '#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif',
          logdepthbuf_fragment:
            '#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif',
          logdepthbuf_pars_fragment:
            '#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif',
          logdepthbuf_pars_vertex:
            '#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif',
          logdepthbuf_vertex:
            '#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif',
          map_fragment:
            '#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif',
          map_pars_fragment: '#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif',
          map_particle_fragment:
            '#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif',
          map_particle_pars_fragment:
            '#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif',
          metalnessmap_fragment:
            'float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif',
          metalnessmap_pars_fragment: '#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif',
          morphnormal_vertex:
            '#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif',
          morphtarget_pars_vertex:
            '#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\t\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\t\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif',
          morphtarget_vertex:
            '#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif',
          normal_fragment_begin:
            'float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;',
          normal_fragment_maps:
            '#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif',
          normalmap_pars_fragment:
            '#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif',
          clearcoat_normal_fragment_begin: '#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif',
          clearcoat_normal_fragment_maps:
            '#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif',
          clearcoat_pars_fragment:
            '#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif',
          packing:
            'vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}',
          premultiplied_alpha_fragment: '#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif',
          project_vertex:
            'vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;',
          dithering_fragment: '#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif',
          dithering_pars_fragment:
            '#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif',
          roughnessmap_fragment:
            'float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif',
          roughnessmap_pars_fragment: '#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif',
          shadowmap_pars_fragment:
            '#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif',
          shadowmap_pars_vertex:
            '#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif',
          shadowmap_vertex:
            '#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif',
          shadowmask_pars_fragment:
            'float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}',
          skinbase_vertex:
            '#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif',
          skinning_pars_vertex:
            '#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif',
          skinning_vertex:
            '#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif',
          skinnormal_vertex:
            '#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif',
          specularmap_fragment:
            'float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif',
          specularmap_pars_fragment: '#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif',
          tonemapping_fragment:
            '#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif',
          tonemapping_pars_fragment:
            '#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }',
          transmission_fragment:
            '#ifdef USE_TRANSMISSION\n\tfloat transmissionFactor = transmission;\n\tfloat thicknessFactor = thickness;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\ttransmissionFactor *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition.xyz / vWorldPosition.w;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tfloat ior = ( 1.0 + 0.4 * reflectivity ) / ( 1.0 - 0.4 * reflectivity );\n\tvec3 transmission = transmissionFactor * getIBLVolumeRefraction(\n\t\tn, v, roughnessFactor, material.diffuseColor, material.specularColor,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n\t\tattenuationTint, attenuationDistance );\n\ttotalDiffuse = mix( totalDiffuse, transmission, transmissionFactor );\n#endif',
          transmission_pars_fragment:
            '#ifdef USE_TRANSMISSION\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec4 vWorldPosition;\n\tvec3 getVolumeTransmissionRay(vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix) {\n\t\tvec3 refractionVector = refract(-v, normalize(n), 1.0 / ior);\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length(vec3(modelMatrix[0].xyz));\n\t\tmodelScale.y = length(vec3(modelMatrix[1].xyz));\n\t\tmodelScale.z = length(vec3(modelMatrix[2].xyz));\n\t\treturn normalize(refractionVector) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness(float roughness, float ior) {\n\t\treturn roughness * clamp(ior * 2.0 - 2.0, 0.0, 1.0);\n\t}\n\tvec3 getTransmissionSample(vec2 fragCoord, float roughness, float ior) {\n\t\tfloat framebufferLod = log2(transmissionSamplerSize.x) * applyIorToRoughness(roughness, ior);\n\t\treturn texture2DLodEXT(transmissionSamplerMap, fragCoord.xy, framebufferLod).rgb;\n\t}\n\tvec3 applyVolumeAttenuation(vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance) {\n\t\tif (attenuationDistance == 0.0) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log(attenuationColor) / attenuationDistance;\n\t\t\tvec3 transmittance = exp(-attenuationCoefficient * transmissionDistance);\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec3 getIBLVolumeRefraction(vec3 n, vec3 v, float perceptualRoughness, vec3 baseColor, vec3 specularColor,\n\t\tvec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness,\n\t\tvec3 attenuationColor, float attenuationDistance) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay(n, v, thickness, ior, modelMatrix);\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4(refractedRayExit, 1.0);\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec3 transmittedLight = getTransmissionSample(refractionCoords, perceptualRoughness, ior);\n\t\tvec3 attenuatedColor = applyVolumeAttenuation(transmittedLight, length(transmissionRay), attenuationColor, attenuationDistance);\n\t\treturn (1.0 - specularColor) * attenuatedColor * baseColor;\n\t}\n#endif',
          uv_pars_fragment: '#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif',
          uv_pars_vertex:
            '#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif',
          uv_vertex: '#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif',
          uv2_pars_fragment: '#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif',
          uv2_pars_vertex:
            '#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif',
          uv2_vertex:
            '#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif',
          worldpos_vertex:
            '#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif',
          background_frag:
            'uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}',
          background_vert:
            'varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}',
          cube_frag:
            '#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}',
          cube_vert:
            'varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}',
          depth_frag:
            '#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}',
          depth_vert:
            '#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}',
          distanceRGBA_frag:
            '#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}',
          distanceRGBA_vert:
            '#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}',
          equirect_frag:
            'uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}',
          equirect_vert:
            'varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}',
          linedashed_frag:
            'uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}',
          linedashed_vert:
            'uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}',
          meshbasic_frag:
            'uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}',
          meshbasic_vert:
            '#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}',
          meshlambert_frag:
            'uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}',
          meshlambert_vert:
            '#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}',
          meshmatcap_frag:
            '#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}',
          meshmatcap_vert:
            '#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t\t#ifdef USE_TANGENT\n\t\t\tvTangent = normalize( transformedTangent );\n\t\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t\t#endif\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}',
          meshtoon_frag:
            '#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}',
          meshtoon_vert:
            '#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}',
          meshphong_frag:
            '#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}',
          meshphong_vert:
            '#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}',
          meshphysical_frag:
            '#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationTint;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularTint;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARTINTMAP\n\t\tuniform sampler2D specularTintMap;\n\t#endif\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <transmission_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}',
          meshphysical_vert:
            '#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#ifdef USE_TRANSMISSION\n\tvarying vec4 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition;\n#endif\n}',
          normal_frag:
            '#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}',
          normal_vert:
            '#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}',
          points_frag:
            'uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}',
          points_vert:
            'uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}',
          shadow_frag:
            'uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}',
          shadow_vert:
            '#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}',
          sprite_frag:
            'uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}',
          sprite_vert:
            'uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}',
        },
        Ki = {
          common: {
            diffuse: { value: new Ye(16777215) },
            opacity: { value: 1 },
            map: { value: null },
            uvTransform: { value: new mt() },
            uv2Transform: { value: new mt() },
            alphaMap: { value: null },
          },
          specularmap: { specularMap: { value: null } },
          envmap: {
            envMap: { value: null },
            flipEnvMap: { value: -1 },
            reflectivity: { value: 1 },
            refractionRatio: { value: 0.98 },
            maxMipLevel: { value: 0 },
          },
          aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } },
          lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 } },
          emissivemap: { emissiveMap: { value: null } },
          bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } },
          normalmap: { normalMap: { value: null }, normalScale: { value: new gt(1, 1) } },
          displacementmap: {
            displacementMap: { value: null },
            displacementScale: { value: 1 },
            displacementBias: { value: 0 },
          },
          roughnessmap: { roughnessMap: { value: null } },
          metalnessmap: { metalnessMap: { value: null } },
          gradientmap: { gradientMap: { value: null } },
          fog: {
            fogDensity: { value: 25e-5 },
            fogNear: { value: 1 },
            fogFar: { value: 2e3 },
            fogColor: { value: new Ye(16777215) },
          },
          lights: {
            ambientLightColor: { value: [] },
            lightProbe: { value: [] },
            directionalLights: { value: [], properties: { direction: {}, color: {} } },
            directionalLightShadows: {
              value: [],
              properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} },
            },
            directionalShadowMap: { value: [] },
            directionalShadowMatrix: { value: [] },
            spotLights: {
              value: [],
              properties: {
                color: {},
                position: {},
                direction: {},
                distance: {},
                coneCos: {},
                penumbraCos: {},
                decay: {},
              },
            },
            spotLightShadows: {
              value: [],
              properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} },
            },
            spotShadowMap: { value: [] },
            spotShadowMatrix: { value: [] },
            pointLights: { value: [], properties: { color: {}, position: {}, decay: {}, distance: {} } },
            pointLightShadows: {
              value: [],
              properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
                shadowCameraNear: {},
                shadowCameraFar: {},
              },
            },
            pointShadowMap: { value: [] },
            pointShadowMatrix: { value: [] },
            hemisphereLights: { value: [], properties: { direction: {}, skyColor: {}, groundColor: {} } },
            rectAreaLights: { value: [], properties: { color: {}, position: {}, width: {}, height: {} } },
            ltc_1: { value: null },
            ltc_2: { value: null },
          },
          points: {
            diffuse: { value: new Ye(16777215) },
            opacity: { value: 1 },
            size: { value: 1 },
            scale: { value: 1 },
            map: { value: null },
            alphaMap: { value: null },
            uvTransform: { value: new mt() },
          },
          sprite: {
            diffuse: { value: new Ye(16777215) },
            opacity: { value: 1 },
            center: { value: new gt(0.5, 0.5) },
            rotation: { value: 0 },
            map: { value: null },
            alphaMap: { value: null },
            uvTransform: { value: new mt() },
          },
        },
        Zi = {
          basic: {
            uniforms: Di([Ki.common, Ki.specularmap, Ki.envmap, Ki.aomap, Ki.lightmap, Ki.fog]),
            vertexShader: Xi.meshbasic_vert,
            fragmentShader: Xi.meshbasic_frag,
          },
          lambert: {
            uniforms: Di([
              Ki.common,
              Ki.specularmap,
              Ki.envmap,
              Ki.aomap,
              Ki.lightmap,
              Ki.emissivemap,
              Ki.fog,
              Ki.lights,
              { emissive: { value: new Ye(0) } },
            ]),
            vertexShader: Xi.meshlambert_vert,
            fragmentShader: Xi.meshlambert_frag,
          },
          phong: {
            uniforms: Di([
              Ki.common,
              Ki.specularmap,
              Ki.envmap,
              Ki.aomap,
              Ki.lightmap,
              Ki.emissivemap,
              Ki.bumpmap,
              Ki.normalmap,
              Ki.displacementmap,
              Ki.fog,
              Ki.lights,
              { emissive: { value: new Ye(0) }, specular: { value: new Ye(1118481) }, shininess: { value: 30 } },
            ]),
            vertexShader: Xi.meshphong_vert,
            fragmentShader: Xi.meshphong_frag,
          },
          standard: {
            uniforms: Di([
              Ki.common,
              Ki.envmap,
              Ki.aomap,
              Ki.lightmap,
              Ki.emissivemap,
              Ki.bumpmap,
              Ki.normalmap,
              Ki.displacementmap,
              Ki.roughnessmap,
              Ki.metalnessmap,
              Ki.fog,
              Ki.lights,
              {
                emissive: { value: new Ye(0) },
                roughness: { value: 1 },
                metalness: { value: 0 },
                envMapIntensity: { value: 1 },
              },
            ]),
            vertexShader: Xi.meshphysical_vert,
            fragmentShader: Xi.meshphysical_frag,
          },
          toon: {
            uniforms: Di([
              Ki.common,
              Ki.aomap,
              Ki.lightmap,
              Ki.emissivemap,
              Ki.bumpmap,
              Ki.normalmap,
              Ki.displacementmap,
              Ki.gradientmap,
              Ki.fog,
              Ki.lights,
              { emissive: { value: new Ye(0) } },
            ]),
            vertexShader: Xi.meshtoon_vert,
            fragmentShader: Xi.meshtoon_frag,
          },
          matcap: {
            uniforms: Di([
              Ki.common,
              Ki.bumpmap,
              Ki.normalmap,
              Ki.displacementmap,
              Ki.fog,
              { matcap: { value: null } },
            ]),
            vertexShader: Xi.meshmatcap_vert,
            fragmentShader: Xi.meshmatcap_frag,
          },
          points: { uniforms: Di([Ki.points, Ki.fog]), vertexShader: Xi.points_vert, fragmentShader: Xi.points_frag },
          dashed: {
            uniforms: Di([Ki.common, Ki.fog, { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } }]),
            vertexShader: Xi.linedashed_vert,
            fragmentShader: Xi.linedashed_frag,
          },
          depth: {
            uniforms: Di([Ki.common, Ki.displacementmap]),
            vertexShader: Xi.depth_vert,
            fragmentShader: Xi.depth_frag,
          },
          normal: {
            uniforms: Di([Ki.common, Ki.bumpmap, Ki.normalmap, Ki.displacementmap, { opacity: { value: 1 } }]),
            vertexShader: Xi.normal_vert,
            fragmentShader: Xi.normal_frag,
          },
          sprite: { uniforms: Di([Ki.sprite, Ki.fog]), vertexShader: Xi.sprite_vert, fragmentShader: Xi.sprite_frag },
          background: {
            uniforms: { uvTransform: { value: new mt() }, t2D: { value: null } },
            vertexShader: Xi.background_vert,
            fragmentShader: Xi.background_frag,
          },
          cube: {
            uniforms: Di([Ki.envmap, { opacity: { value: 1 } }]),
            vertexShader: Xi.cube_vert,
            fragmentShader: Xi.cube_frag,
          },
          equirect: {
            uniforms: { tEquirect: { value: null } },
            vertexShader: Xi.equirect_vert,
            fragmentShader: Xi.equirect_frag,
          },
          distanceRGBA: {
            uniforms: Di([
              Ki.common,
              Ki.displacementmap,
              { referencePosition: { value: new Et() }, nearDistance: { value: 1 }, farDistance: { value: 1e3 } },
            ]),
            vertexShader: Xi.distanceRGBA_vert,
            fragmentShader: Xi.distanceRGBA_frag,
          },
          shadow: {
            uniforms: Di([Ki.lights, Ki.fog, { color: { value: new Ye(0) }, opacity: { value: 1 } }]),
            vertexShader: Xi.shadow_vert,
            fragmentShader: Xi.shadow_frag,
          },
        }
      function $i(t, e, i, n, s) {
        const r = new Ye(0)
        let a,
          o,
          l = 0,
          c = null,
          h = 0,
          u = null
        function d(t, e) {
          i.buffers.color.setClear(t.r, t.g, t.b, e, s)
        }
        return {
          getClearColor: function () {
            return r
          },
          setClearColor: function (t, e = 1) {
            r.set(t), (l = e), d(r, l)
          },
          getClearAlpha: function () {
            return l
          },
          setClearAlpha: function (t) {
            ;(l = t), d(r, l)
          },
          render: function (i, s) {
            let p = !1,
              A = !0 === s.isScene ? s.background : null
            A && A.isTexture && (A = e.get(A))
            const g = t.xr,
              m = g.getSession && g.getSession()
            m && 'additive' === m.environmentBlendMode && (A = null),
              null === A ? d(r, l) : A && A.isColor && (d(A, 1), (p = !0)),
              (t.autoClear || p) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil),
              A && (A.isCubeTexture || 306 === A.mapping)
                ? (void 0 === o &&
                    ((o = new Si(
                      new Ti(1, 1, 1),
                      new Ri({
                        name: 'BackgroundCubeMaterial',
                        uniforms: Li(Zi.cube.uniforms),
                        vertexShader: Zi.cube.vertexShader,
                        fragmentShader: Zi.cube.fragmentShader,
                        side: 1,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1,
                      }),
                    )),
                    o.geometry.deleteAttribute('normal'),
                    o.geometry.deleteAttribute('uv'),
                    (o.onBeforeRender = function (t, e, i) {
                      this.matrixWorld.copyPosition(i.matrixWorld)
                    }),
                    Object.defineProperty(o.material, 'envMap', {
                      get: function () {
                        return this.uniforms.envMap.value
                      },
                    }),
                    n.update(o)),
                  (o.material.uniforms.envMap.value = A),
                  (o.material.uniforms.flipEnvMap.value = A.isCubeTexture && !1 === A.isRenderTargetTexture ? -1 : 1),
                  (c === A && h === A.version && u === t.toneMapping) ||
                    ((o.material.needsUpdate = !0), (c = A), (h = A.version), (u = t.toneMapping)),
                  i.unshift(o, o.geometry, o.material, 0, 0, null))
                : A &&
                  A.isTexture &&
                  (void 0 === a &&
                    ((a = new Si(
                      new Ji(2, 2),
                      new Ri({
                        name: 'BackgroundMaterial',
                        uniforms: Li(Zi.background.uniforms),
                        vertexShader: Zi.background.vertexShader,
                        fragmentShader: Zi.background.fragmentShader,
                        side: 0,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1,
                      }),
                    )),
                    a.geometry.deleteAttribute('normal'),
                    Object.defineProperty(a.material, 'map', {
                      get: function () {
                        return this.uniforms.t2D.value
                      },
                    }),
                    n.update(a)),
                  (a.material.uniforms.t2D.value = A),
                  !0 === A.matrixAutoUpdate && A.updateMatrix(),
                  a.material.uniforms.uvTransform.value.copy(A.matrix),
                  (c === A && h === A.version && u === t.toneMapping) ||
                    ((a.material.needsUpdate = !0), (c = A), (h = A.version), (u = t.toneMapping)),
                  i.unshift(a, a.geometry, a.material, 0, 0, null))
          },
        }
      }
      function tn(t, e, i, n) {
        const s = t.getParameter(34921),
          r = n.isWebGL2 ? null : e.get('OES_vertex_array_object'),
          a = n.isWebGL2 || null !== r,
          o = {},
          l = d(null)
        let c = l
        function h(e) {
          return n.isWebGL2 ? t.bindVertexArray(e) : r.bindVertexArrayOES(e)
        }
        function u(e) {
          return n.isWebGL2 ? t.deleteVertexArray(e) : r.deleteVertexArrayOES(e)
        }
        function d(t) {
          const e = [],
            i = [],
            n = []
          for (let r = 0; r < s; r++) (e[r] = 0), (i[r] = 0), (n[r] = 0)
          return {
            geometry: null,
            program: null,
            wireframe: !1,
            newAttributes: e,
            enabledAttributes: i,
            attributeDivisors: n,
            object: t,
            attributes: {},
            index: null,
          }
        }
        function p() {
          const t = c.newAttributes
          for (let e = 0, i = t.length; e < i; e++) t[e] = 0
        }
        function A(t) {
          g(t, 0)
        }
        function g(i, s) {
          const r = c.newAttributes,
            a = c.enabledAttributes,
            o = c.attributeDivisors
          ;(r[i] = 1),
            0 === a[i] && (t.enableVertexAttribArray(i), (a[i] = 1)),
            o[i] !== s &&
              ((n.isWebGL2 ? t : e.get('ANGLE_instanced_arrays'))[
                n.isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE'
              ](i, s),
              (o[i] = s))
        }
        function m() {
          const e = c.newAttributes,
            i = c.enabledAttributes
          for (let n = 0, s = i.length; n < s; n++) i[n] !== e[n] && (t.disableVertexAttribArray(n), (i[n] = 0))
        }
        function f(e, i, s, r, a, o) {
          !0 !== n.isWebGL2 || (5124 !== s && 5125 !== s)
            ? t.vertexAttribPointer(e, i, s, r, a, o)
            : t.vertexAttribIPointer(e, i, s, a, o)
        }
        function v() {
          y(), c !== l && ((c = l), h(c.object))
        }
        function y() {
          ;(l.geometry = null), (l.program = null), (l.wireframe = !1)
        }
        return {
          setup: function (s, l, u, v, y) {
            let x = !1
            if (a) {
              const e = (function (e, i, s) {
                const a = !0 === s.wireframe
                let l = o[e.id]
                void 0 === l && ((l = {}), (o[e.id] = l))
                let c = l[i.id]
                void 0 === c && ((c = {}), (l[i.id] = c))
                let h = c[a]
                return (
                  void 0 === h && ((h = d(n.isWebGL2 ? t.createVertexArray() : r.createVertexArrayOES())), (c[a] = h)),
                  h
                )
              })(v, u, l)
              c !== e && ((c = e), h(c.object)),
                (x = (function (t, e) {
                  const i = c.attributes,
                    n = t.attributes
                  let s = 0
                  for (const r in n) {
                    const t = i[r],
                      e = n[r]
                    if (void 0 === t) return !0
                    if (t.attribute !== e) return !0
                    if (t.data !== e.data) return !0
                    s++
                  }
                  return c.attributesNum !== s || c.index !== e
                })(v, y)),
                x &&
                  (function (t, e) {
                    const i = {},
                      n = t.attributes
                    let s = 0
                    for (const r in n) {
                      const t = n[r],
                        e = {}
                      ;(e.attribute = t), t.data && (e.data = t.data), (i[r] = e), s++
                    }
                    ;(c.attributes = i), (c.attributesNum = s), (c.index = e)
                  })(v, y)
            } else {
              const t = !0 === l.wireframe
              ;(c.geometry === v.id && c.program === u.id && c.wireframe === t) ||
                ((c.geometry = v.id), (c.program = u.id), (c.wireframe = t), (x = !0))
            }
            !0 === s.isInstancedMesh && (x = !0),
              null !== y && i.update(y, 34963),
              x &&
                ((function (s, r, a, o) {
                  if (
                    !1 === n.isWebGL2 &&
                    (s.isInstancedMesh || o.isInstancedBufferGeometry) &&
                    null === e.get('ANGLE_instanced_arrays')
                  )
                    return
                  p()
                  const l = o.attributes,
                    c = a.getAttributes(),
                    h = r.defaultAttributeValues
                  for (const e in c) {
                    const n = c[e]
                    if (n >= 0) {
                      const r = l[e]
                      if (void 0 !== r) {
                        const e = r.normalized,
                          s = r.itemSize,
                          a = i.get(r)
                        if (void 0 === a) continue
                        const l = a.buffer,
                          c = a.type,
                          h = a.bytesPerElement
                        if (r.isInterleavedBufferAttribute) {
                          const i = r.data,
                            a = i.stride,
                            u = r.offset
                          i && i.isInstancedInterleavedBuffer
                            ? (g(n, i.meshPerAttribute),
                              void 0 === o._maxInstanceCount && (o._maxInstanceCount = i.meshPerAttribute * i.count))
                            : A(n),
                            t.bindBuffer(34962, l),
                            f(n, s, c, e, a * h, u * h)
                        } else
                          r.isInstancedBufferAttribute
                            ? (g(n, r.meshPerAttribute),
                              void 0 === o._maxInstanceCount && (o._maxInstanceCount = r.meshPerAttribute * r.count))
                            : A(n),
                            t.bindBuffer(34962, l),
                            f(n, s, c, e, 0, 0)
                      } else if ('instanceMatrix' === e) {
                        const e = i.get(s.instanceMatrix)
                        if (void 0 === e) continue
                        const r = e.buffer,
                          a = e.type
                        g(n + 0, 1),
                          g(n + 1, 1),
                          g(n + 2, 1),
                          g(n + 3, 1),
                          t.bindBuffer(34962, r),
                          t.vertexAttribPointer(n + 0, 4, a, !1, 64, 0),
                          t.vertexAttribPointer(n + 1, 4, a, !1, 64, 16),
                          t.vertexAttribPointer(n + 2, 4, a, !1, 64, 32),
                          t.vertexAttribPointer(n + 3, 4, a, !1, 64, 48)
                      } else if ('instanceColor' === e) {
                        const e = i.get(s.instanceColor)
                        if (void 0 === e) continue
                        const r = e.buffer,
                          a = e.type
                        g(n, 1), t.bindBuffer(34962, r), t.vertexAttribPointer(n, 3, a, !1, 12, 0)
                      } else if (void 0 !== h) {
                        const i = h[e]
                        if (void 0 !== i)
                          switch (i.length) {
                            case 2:
                              t.vertexAttrib2fv(n, i)
                              break
                            case 3:
                              t.vertexAttrib3fv(n, i)
                              break
                            case 4:
                              t.vertexAttrib4fv(n, i)
                              break
                            default:
                              t.vertexAttrib1fv(n, i)
                          }
                      }
                    }
                  }
                  m()
                })(s, l, u, v),
                null !== y && t.bindBuffer(34963, i.get(y).buffer))
          },
          reset: v,
          resetDefaultState: y,
          dispose: function () {
            v()
            for (const t in o) {
              const e = o[t]
              for (const t in e) {
                const i = e[t]
                for (const t in i) u(i[t].object), delete i[t]
                delete e[t]
              }
              delete o[t]
            }
          },
          releaseStatesOfGeometry: function (t) {
            if (void 0 === o[t.id]) return
            const e = o[t.id]
            for (const i in e) {
              const t = e[i]
              for (const e in t) u(t[e].object), delete t[e]
              delete e[i]
            }
            delete o[t.id]
          },
          releaseStatesOfProgram: function (t) {
            for (const e in o) {
              const i = o[e]
              if (void 0 === i[t.id]) continue
              const n = i[t.id]
              for (const t in n) u(n[t].object), delete n[t]
              delete i[t.id]
            }
          },
          initAttributes: p,
          enableAttribute: A,
          disableUnusedAttributes: m,
        }
      }
      function en(t, e, i, n) {
        const s = n.isWebGL2
        let r
        ;(this.setMode = function (t) {
          r = t
        }),
          (this.render = function (e, n) {
            t.drawArrays(r, e, n), i.update(n, r, 1)
          }),
          (this.renderInstances = function (n, a, o) {
            if (0 === o) return
            let l, c
            if (s) (l = t), (c = 'drawArraysInstanced')
            else if (((l = e.get('ANGLE_instanced_arrays')), (c = 'drawArraysInstancedANGLE'), null === l)) return
            l[c](r, n, a, o), i.update(a, r, o)
          })
      }
      function nn(t, e, i) {
        let n
        function s(e) {
          if ('highp' === e) {
            if (
              t.getShaderPrecisionFormat(35633, 36338).precision > 0 &&
              t.getShaderPrecisionFormat(35632, 36338).precision > 0
            )
              return 'highp'
            e = 'mediump'
          }
          return 'mediump' === e &&
            t.getShaderPrecisionFormat(35633, 36337).precision > 0 &&
            t.getShaderPrecisionFormat(35632, 36337).precision > 0
            ? 'mediump'
            : 'lowp'
        }
        const r =
          ('undefined' != typeof WebGL2RenderingContext && t instanceof WebGL2RenderingContext) ||
          ('undefined' != typeof WebGL2ComputeRenderingContext && t instanceof WebGL2ComputeRenderingContext)
        let a = void 0 !== i.precision ? i.precision : 'highp'
        const o = s(a)
        o !== a && (a = o)
        const l = r || e.has('WEBGL_draw_buffers'),
          c = !0 === i.logarithmicDepthBuffer,
          h = t.getParameter(34930),
          u = t.getParameter(35660),
          d = t.getParameter(3379),
          p = t.getParameter(34076),
          A = t.getParameter(34921),
          g = t.getParameter(36347),
          m = t.getParameter(36348),
          f = t.getParameter(36349),
          v = u > 0,
          y = r || e.has('OES_texture_float')
        return {
          isWebGL2: r,
          drawBuffers: l,
          getMaxAnisotropy: function () {
            if (void 0 !== n) return n
            if (!0 === e.has('EXT_texture_filter_anisotropic')) {
              const i = e.get('EXT_texture_filter_anisotropic')
              n = t.getParameter(i.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
            } else n = 0
            return n
          },
          getMaxPrecision: s,
          precision: a,
          logarithmicDepthBuffer: c,
          maxTextures: h,
          maxVertexTextures: u,
          maxTextureSize: d,
          maxCubemapSize: p,
          maxAttributes: A,
          maxVertexUniforms: g,
          maxVaryings: m,
          maxFragmentUniforms: f,
          vertexTextures: v,
          floatFragmentTextures: y,
          floatVertexTextures: v && y,
          maxSamples: r ? t.getParameter(36183) : 0,
        }
      }
      function sn(t) {
        const e = this
        let i = null,
          n = 0,
          s = !1,
          r = !1
        const a = new Vi(),
          o = new mt(),
          l = { value: null, needsUpdate: !1 }
        function c() {
          l.value !== i && ((l.value = i), (l.needsUpdate = n > 0)), (e.numPlanes = n), (e.numIntersection = 0)
        }
        function h(t, i, n, s) {
          const r = null !== t ? t.length : 0
          let c = null
          if (0 !== r) {
            if (((c = l.value), !0 !== s || null === c)) {
              const e = n + 4 * r,
                s = i.matrixWorldInverse
              o.getNormalMatrix(s), (null === c || c.length < e) && (c = new Float32Array(e))
              for (let i = 0, l = n; i !== r; ++i, l += 4)
                a.copy(t[i]).applyMatrix4(s, o), a.normal.toArray(c, l), (c[l + 3] = a.constant)
            }
            ;(l.value = c), (l.needsUpdate = !0)
          }
          return (e.numPlanes = r), (e.numIntersection = 0), c
        }
        ;(this.uniform = l),
          (this.numPlanes = 0),
          (this.numIntersection = 0),
          (this.init = function (t, e, r) {
            const a = 0 !== t.length || e || 0 !== n || s
            return (s = e), (i = h(t, r, 0)), (n = t.length), a
          }),
          (this.beginShadows = function () {
            ;(r = !0), h(null)
          }),
          (this.endShadows = function () {
            ;(r = !1), c()
          }),
          (this.setState = function (e, a, o) {
            const u = e.clippingPlanes,
              d = e.clipIntersection,
              p = e.clipShadows,
              A = t.get(e)
            if (!s || null === u || 0 === u.length || (r && !p)) r ? h(null) : c()
            else {
              const t = r ? 0 : n,
                e = 4 * t
              let s = A.clippingState || null
              ;(l.value = s), (s = h(u, a, e, o))
              for (let n = 0; n !== e; ++n) s[n] = i[n]
              ;(A.clippingState = s), (this.numIntersection = d ? this.numPlanes : 0), (this.numPlanes += t)
            }
          })
      }
      function rn(t) {
        let e = new WeakMap()
        function i(t, e) {
          return 303 === e ? (t.mapping = 301) : 304 === e && (t.mapping = 302), t
        }
        function n(t) {
          const i = t.target
          i.removeEventListener('dispose', n)
          const s = e.get(i)
          void 0 !== s && (e.delete(i), s.dispose())
        }
        return {
          get: function (s) {
            if (s && s.isTexture && !1 === s.isRenderTargetTexture) {
              const r = s.mapping
              if (303 === r || 304 === r) {
                if (e.has(s)) return i(e.get(s).texture, s.mapping)
                {
                  const r = s.image
                  if (r && r.height > 0) {
                    const a = t.getRenderTarget(),
                      o = new ki(r.height / 2)
                    return (
                      o.fromEquirectangularTexture(t, s),
                      e.set(s, o),
                      t.setRenderTarget(a),
                      s.addEventListener('dispose', n),
                      i(o.texture, s.mapping)
                    )
                  }
                  return null
                }
              }
            }
            return s
          },
          dispose: function () {
            e = new WeakMap()
          },
        }
      }
      Zi.physical = {
        uniforms: Di([
          Zi.standard.uniforms,
          {
            clearcoat: { value: 0 },
            clearcoatMap: { value: null },
            clearcoatRoughness: { value: 0 },
            clearcoatRoughnessMap: { value: null },
            clearcoatNormalScale: { value: new gt(1, 1) },
            clearcoatNormalMap: { value: null },
            sheen: { value: new Ye(0) },
            transmission: { value: 0 },
            transmissionMap: { value: null },
            transmissionSamplerSize: { value: new gt() },
            transmissionSamplerMap: { value: null },
            thickness: { value: 0 },
            thicknessMap: { value: null },
            attenuationDistance: { value: 0 },
            attenuationTint: { value: new Ye(0) },
            specularIntensity: { value: 0 },
            specularIntensityMap: { value: null },
            specularTint: { value: new Ye(1, 1, 1) },
            specularTintMap: { value: null },
          },
        ]),
        vertexShader: Xi.meshphysical_vert,
        fragmentShader: Xi.meshphysical_frag,
      }
      class an extends Pi {
        constructor(t = -1, e = 1, i = 1, n = -1, s = 0.1, r = 2e3) {
          super(),
            (this.type = 'OrthographicCamera'),
            (this.zoom = 1),
            (this.view = null),
            (this.left = t),
            (this.right = e),
            (this.top = i),
            (this.bottom = n),
            (this.near = s),
            (this.far = r),
            this.updateProjectionMatrix()
        }
        copy(t, e) {
          return (
            super.copy(t, e),
            (this.left = t.left),
            (this.right = t.right),
            (this.top = t.top),
            (this.bottom = t.bottom),
            (this.near = t.near),
            (this.far = t.far),
            (this.zoom = t.zoom),
            (this.view = null === t.view ? null : Object.assign({}, t.view)),
            this
          )
        }
        setViewOffset(t, e, i, n, s, r) {
          null === this.view &&
            (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }),
            (this.view.enabled = !0),
            (this.view.fullWidth = t),
            (this.view.fullHeight = e),
            (this.view.offsetX = i),
            (this.view.offsetY = n),
            (this.view.width = s),
            (this.view.height = r),
            this.updateProjectionMatrix()
        }
        clearViewOffset() {
          null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
        }
        updateProjectionMatrix() {
          const t = (this.right - this.left) / (2 * this.zoom),
            e = (this.top - this.bottom) / (2 * this.zoom),
            i = (this.right + this.left) / 2,
            n = (this.top + this.bottom) / 2
          let s = i - t,
            r = i + t,
            a = n + e,
            o = n - e
          if (null !== this.view && this.view.enabled) {
            const t = (this.right - this.left) / this.view.fullWidth / this.zoom,
              e = (this.top - this.bottom) / this.view.fullHeight / this.zoom
            ;(s += t * this.view.offsetX),
              (r = s + t * this.view.width),
              (a -= e * this.view.offsetY),
              (o = a - e * this.view.height)
          }
          this.projectionMatrix.makeOrthographic(s, r, a, o, this.near, this.far),
            this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
        }
        toJSON(t) {
          const e = super.toJSON(t)
          return (
            (e.object.zoom = this.zoom),
            (e.object.left = this.left),
            (e.object.right = this.right),
            (e.object.top = this.top),
            (e.object.bottom = this.bottom),
            (e.object.near = this.near),
            (e.object.far = this.far),
            null !== this.view && (e.object.view = Object.assign({}, this.view)),
            e
          )
        }
      }
      an.prototype.isOrthographicCamera = !0
      class on extends Ri {
        constructor(t) {
          super(t), (this.type = 'RawShaderMaterial')
        }
      }
      on.prototype.isRawShaderMaterial = !0
      const ln = Math.pow(2, 8),
        cn = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
        hn = 5 + cn.length,
        un = { 3e3: 0, 3001: 1, 3002: 2, 3004: 3, 3005: 4, 3006: 5, 3007: 6 },
        dn = new Je({ side: 1, depthWrite: !1, depthTest: !1 }),
        pn = new Si(new Ti(), dn),
        An = new an(),
        {
          _lodPlanes: gn,
          _sizeLods: mn,
          _sigmas: fn,
        } = (function () {
          const t = [],
            e = [],
            i = []
          let n = 8
          for (let s = 0; s < hn; s++) {
            const r = Math.pow(2, n)
            e.push(r)
            let a = 1 / r
            s > 4 ? (a = cn[s - 8 + 4 - 1]) : 0 == s && (a = 0), i.push(a)
            const o = 1 / (r - 1),
              l = -o / 2,
              c = 1 + o / 2,
              h = [l, l, c, l, c, c, l, l, c, c, l, c],
              u = 6,
              d = 6,
              p = 3,
              A = 2,
              g = 1,
              m = new Float32Array(p * d * u),
              f = new Float32Array(A * d * u),
              v = new Float32Array(g * d * u)
            for (let t = 0; t < u; t++) {
              const e = ((t % 3) * 2) / 3 - 1,
                i = t > 2 ? 0 : -1,
                n = [e, i, 0, e + 2 / 3, i, 0, e + 2 / 3, i + 1, 0, e, i, 0, e + 2 / 3, i + 1, 0, e, i + 1, 0]
              m.set(n, p * d * t), f.set(h, A * d * t)
              const s = [t, t, t, t, t, t]
              v.set(s, g * d * t)
            }
            const y = new hi()
            y.setAttribute('position', new Ze(m, p)),
              y.setAttribute('uv', new Ze(f, A)),
              y.setAttribute('faceIndex', new Ze(v, g)),
              t.push(y),
              n > 4 && n--
          }
          return { _lodPlanes: t, _sizeLods: e, _sigmas: i }
        })(),
        vn = new Ye()
      let yn = null
      const xn = (1 + Math.sqrt(5)) / 2,
        wn = 1 / xn,
        _n = [
          new Et(1, 1, 1),
          new Et(-1, 1, 1),
          new Et(1, 1, -1),
          new Et(-1, 1, -1),
          new Et(0, xn, wn),
          new Et(0, xn, -wn),
          new Et(wn, 0, xn),
          new Et(-wn, 0, xn),
          new Et(xn, wn, 0),
          new Et(-xn, wn, 0),
        ]
      function In(t) {
        const e = Math.max(t.r, t.g, t.b),
          i = Math.min(Math.max(Math.ceil(Math.log2(e)), -128), 127)
        return t.multiplyScalar(Math.pow(2, -i)), (i + 128) / 255
      }
      class Cn {
        constructor(t) {
          ;(this._renderer = t),
            (this._pingPongRenderTarget = null),
            (this._blurMaterial = (function (t) {
              const e = new Float32Array(20),
                i = new Et(0, 1, 0)
              return new on({
                name: 'SphericalGaussianBlur',
                defines: { n: 20 },
                uniforms: {
                  envMap: { value: null },
                  samples: { value: 1 },
                  weights: { value: e },
                  latitudinal: { value: !1 },
                  dTheta: { value: 0 },
                  mipInt: { value: 0 },
                  poleAxis: { value: i },
                  inputEncoding: { value: un[3e3] },
                  outputEncoding: { value: un[3e3] },
                },
                vertexShader:
                  '\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t',
                fragmentShader:
                  "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t",
                blending: 0,
                depthTest: !1,
                depthWrite: !1,
              })
            })()),
            (this._equirectShader = null),
            (this._cubemapShader = null),
            this._compileMaterial(this._blurMaterial)
        }
        fromScene(t, e = 0, i = 0.1, n = 100) {
          yn = this._renderer.getRenderTarget()
          const s = this._allocateTargets()
          return (
            this._sceneToCubeUV(t, i, n, s), e > 0 && this._blur(s, 0, 0, e), this._applyPMREM(s), this._cleanup(s), s
          )
        }
        fromEquirectangular(t) {
          return this._fromTexture(t)
        }
        fromCubemap(t) {
          return this._fromTexture(t)
        }
        compileCubemapShader() {
          null === this._cubemapShader && ((this._cubemapShader = Bn()), this._compileMaterial(this._cubemapShader))
        }
        compileEquirectangularShader() {
          null === this._equirectShader && ((this._equirectShader = Sn()), this._compileMaterial(this._equirectShader))
        }
        dispose() {
          this._blurMaterial.dispose(),
            null !== this._cubemapShader && this._cubemapShader.dispose(),
            null !== this._equirectShader && this._equirectShader.dispose()
          for (let t = 0; t < gn.length; t++) gn[t].dispose()
        }
        _cleanup(t) {
          this._pingPongRenderTarget.dispose(),
            this._renderer.setRenderTarget(yn),
            (t.scissorTest = !1),
            bn(t, 0, 0, t.width, t.height)
        }
        _fromTexture(t) {
          yn = this._renderer.getRenderTarget()
          const e = this._allocateTargets(t)
          return this._textureToCubeUV(t, e), this._applyPMREM(e), this._cleanup(e), e
        }
        _allocateTargets(t) {
          const e = {
              magFilter: 1003,
              minFilter: 1003,
              generateMipmaps: !1,
              type: 1009,
              format: 1023,
              encoding: Mn(t) ? t.encoding : 3002,
              depthBuffer: !1,
            },
            i = En(e)
          return (i.depthBuffer = !t), (this._pingPongRenderTarget = En(e)), i
        }
        _compileMaterial(t) {
          const e = new Si(gn[0], t)
          this._renderer.compile(e, An)
        }
        _sceneToCubeUV(t, e, i, n) {
          const s = new Ni(90, 1, e, i),
            r = [1, -1, 1, 1, 1, 1],
            a = [1, 1, 1, -1, -1, -1],
            o = this._renderer,
            l = o.autoClear,
            c = o.outputEncoding,
            h = o.toneMapping
          o.getClearColor(vn), (o.toneMapping = 0), (o.outputEncoding = 3e3), (o.autoClear = !1)
          let u = !1
          const d = t.background
          if (d) {
            if (d.isColor) {
              dn.color.copy(d).convertSRGBToLinear(), (t.background = null)
              const e = In(dn.color)
              ;(dn.opacity = e), (u = !0)
            }
          } else {
            dn.color.copy(vn).convertSRGBToLinear()
            const t = In(dn.color)
            ;(dn.opacity = t), (u = !0)
          }
          for (let p = 0; p < 6; p++) {
            const e = p % 3
            0 == e
              ? (s.up.set(0, r[p], 0), s.lookAt(a[p], 0, 0))
              : 1 == e
              ? (s.up.set(0, 0, r[p]), s.lookAt(0, a[p], 0))
              : (s.up.set(0, r[p], 0), s.lookAt(0, 0, a[p])),
              bn(n, e * ln, p > 2 ? ln : 0, ln, ln),
              o.setRenderTarget(n),
              u && o.render(pn, s),
              o.render(t, s)
          }
          ;(o.toneMapping = h), (o.outputEncoding = c), (o.autoClear = l)
        }
        _textureToCubeUV(t, e) {
          const i = this._renderer
          t.isCubeTexture
            ? null == this._cubemapShader && (this._cubemapShader = Bn())
            : null == this._equirectShader && (this._equirectShader = Sn())
          const n = t.isCubeTexture ? this._cubemapShader : this._equirectShader,
            s = new Si(gn[0], n),
            r = n.uniforms
          ;(r.envMap.value = t),
            t.isCubeTexture || r.texelSize.value.set(1 / t.image.width, 1 / t.image.height),
            (r.inputEncoding.value = un[t.encoding]),
            (r.outputEncoding.value = un[e.texture.encoding]),
            bn(e, 0, 0, 3 * ln, 2 * ln),
            i.setRenderTarget(e),
            i.render(s, An)
        }
        _applyPMREM(t) {
          const e = this._renderer,
            i = e.autoClear
          e.autoClear = !1
          for (let n = 1; n < hn; n++) {
            const e = Math.sqrt(fn[n] * fn[n] - fn[n - 1] * fn[n - 1]),
              i = _n[(n - 1) % _n.length]
            this._blur(t, n - 1, n, e, i)
          }
          e.autoClear = i
        }
        _blur(t, e, i, n, s) {
          const r = this._pingPongRenderTarget
          this._halfBlur(t, r, e, i, n, 'latitudinal', s), this._halfBlur(r, t, i, i, n, 'longitudinal', s)
        }
        _halfBlur(t, e, i, n, s, r, a) {
          const o = this._renderer,
            l = this._blurMaterial,
            c = new Si(gn[n], l),
            h = l.uniforms,
            u = mn[i] - 1,
            d = isFinite(s) ? Math.PI / (2 * u) : (2 * Math.PI) / 39,
            p = s / d,
            A = isFinite(s) ? 1 + Math.floor(3 * p) : 20,
            g = []
          let m = 0
          for (let v = 0; v < 20; ++v) {
            const t = v / p,
              e = Math.exp((-t * t) / 2)
            g.push(e), 0 == v ? (m += e) : v < A && (m += 2 * e)
          }
          for (let v = 0; v < g.length; v++) g[v] = g[v] / m
          ;(h.envMap.value = t.texture),
            (h.samples.value = A),
            (h.weights.value = g),
            (h.latitudinal.value = 'latitudinal' === r),
            a && (h.poleAxis.value = a),
            (h.dTheta.value = d),
            (h.mipInt.value = 8 - i),
            (h.inputEncoding.value = un[t.texture.encoding]),
            (h.outputEncoding.value = un[t.texture.encoding])
          const f = mn[n]
          bn(e, 3 * Math.max(0, ln - 2 * f), (0 === n ? 0 : 2 * ln) + 2 * f * (n > 4 ? n - 8 + 4 : 0), 3 * f, 2 * f),
            o.setRenderTarget(e),
            o.render(c, An)
        }
      }
      function Mn(t) {
        return void 0 !== t && 1009 === t.type && (3e3 === t.encoding || 3001 === t.encoding || 3007 === t.encoding)
      }
      function En(t) {
        const e = new It(3 * ln, 3 * ln, t)
        return (e.texture.mapping = 306), (e.texture.name = 'PMREM.cubeUv'), (e.scissorTest = !0), e
      }
      function bn(t, e, i, n, s) {
        t.viewport.set(e, i, n, s), t.scissor.set(e, i, n, s)
      }
      function Sn() {
        const t = new gt(1, 1)
        return new on({
          name: 'EquirectangularToCubeUV',
          uniforms: {
            envMap: { value: null },
            texelSize: { value: t },
            inputEncoding: { value: un[3e3] },
            outputEncoding: { value: un[3e3] },
          },
          vertexShader:
            '\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t',
          fragmentShader:
            '\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tvec2 f = fract( uv / texelSize - 0.5 );\n\t\t\t\tuv -= f * texelSize;\n\t\t\t\tvec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x += texelSize.x;\n\t\t\t\tvec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.y += texelSize.y;\n\t\t\t\tvec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x -= texelSize.x;\n\t\t\t\tvec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\n\t\t\t\tvec3 tm = mix( tl, tr, f.x );\n\t\t\t\tvec3 bm = mix( bl, br, f.x );\n\t\t\t\tgl_FragColor.rgb = mix( tm, bm, f.y );\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t',
          blending: 0,
          depthTest: !1,
          depthWrite: !1,
        })
      }
      function Bn() {
        return new on({
          name: 'CubemapToCubeUV',
          uniforms: { envMap: { value: null }, inputEncoding: { value: un[3e3] }, outputEncoding: { value: un[3e3] } },
          vertexShader:
            '\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t',
          fragmentShader:
            '\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\t\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t',
          blending: 0,
          depthTest: !1,
          depthWrite: !1,
        })
      }
      function Tn(t) {
        let e = new WeakMap(),
          i = null
        function n(t) {
          const i = t.target
          i.removeEventListener('dispose', n)
          const s = e.get(i)
          void 0 !== s && (s.delete(i), s.dispose())
        }
        return {
          get: function (s) {
            if (s && s.isTexture && !1 === s.isRenderTargetTexture) {
              const r = s.mapping,
                a = 303 === r || 304 === r,
                o = 301 === r || 302 === r
              if (a || o) {
                if (e.has(s)) return e.get(s).texture
                {
                  const r = s.image
                  if (
                    (a && r && r.height > 0) ||
                    (o &&
                      r &&
                      (function (t) {
                        let e = 0
                        for (let i = 0; i < 6; i++) void 0 !== t[i] && e++
                        return 6 === e
                      })(r))
                  ) {
                    const r = t.getRenderTarget()
                    null === i && (i = new Cn(t))
                    const o = a ? i.fromEquirectangular(s) : i.fromCubemap(s)
                    return e.set(s, o), t.setRenderTarget(r), s.addEventListener('dispose', n), o.texture
                  }
                  return null
                }
              }
            }
            return s
          },
          dispose: function () {
            ;(e = new WeakMap()), null !== i && (i.dispose(), (i = null))
          },
        }
      }
      function Ln(t) {
        const e = {}
        function i(i) {
          if (void 0 !== e[i]) return e[i]
          let n
          switch (i) {
            case 'WEBGL_depth_texture':
              n =
                t.getExtension('WEBGL_depth_texture') ||
                t.getExtension('MOZ_WEBGL_depth_texture') ||
                t.getExtension('WEBKIT_WEBGL_depth_texture')
              break
            case 'EXT_texture_filter_anisotropic':
              n =
                t.getExtension('EXT_texture_filter_anisotropic') ||
                t.getExtension('MOZ_EXT_texture_filter_anisotropic') ||
                t.getExtension('WEBKIT_EXT_texture_filter_anisotropic')
              break
            case 'WEBGL_compressed_texture_s3tc':
              n =
                t.getExtension('WEBGL_compressed_texture_s3tc') ||
                t.getExtension('MOZ_WEBGL_compressed_texture_s3tc') ||
                t.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc')
              break
            case 'WEBGL_compressed_texture_pvrtc':
              n =
                t.getExtension('WEBGL_compressed_texture_pvrtc') ||
                t.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc')
              break
            default:
              n = t.getExtension(i)
          }
          return (e[i] = n), n
        }
        return {
          has: function (t) {
            return null !== i(t)
          },
          init: function (t) {
            t.isWebGL2
              ? i('EXT_color_buffer_float')
              : (i('WEBGL_depth_texture'),
                i('OES_texture_float'),
                i('OES_texture_half_float'),
                i('OES_texture_half_float_linear'),
                i('OES_standard_derivatives'),
                i('OES_element_index_uint'),
                i('OES_vertex_array_object'),
                i('ANGLE_instanced_arrays')),
              i('OES_texture_float_linear'),
              i('EXT_color_buffer_half_float')
          },
          get: function (t) {
            const e = i(t)
            return e
          },
        }
      }
      function Dn(t, e, i, n) {
        const s = {},
          r = new WeakMap()
        function a(t) {
          const o = t.target
          null !== o.index && e.remove(o.index)
          for (const i in o.attributes) e.remove(o.attributes[i])
          o.removeEventListener('dispose', a), delete s[o.id]
          const l = r.get(o)
          l && (e.remove(l), r.delete(o)),
            n.releaseStatesOfGeometry(o),
            !0 === o.isInstancedBufferGeometry && delete o._maxInstanceCount,
            i.memory.geometries--
        }
        function o(t) {
          const i = [],
            n = t.index,
            s = t.attributes.position
          let a = 0
          if (null !== n) {
            const t = n.array
            a = n.version
            for (let e = 0, n = t.length; e < n; e += 3) {
              const n = t[e + 0],
                s = t[e + 1],
                r = t[e + 2]
              i.push(n, s, s, r, r, n)
            }
          } else {
            const t = s.array
            a = s.version
            for (let e = 0, n = t.length / 3 - 1; e < n; e += 3) {
              const t = e + 0,
                n = e + 1,
                s = e + 2
              i.push(t, n, n, s, s, t)
            }
          }
          const o = new (ii(i) > 65535 ? ti : $e)(i, 1)
          o.version = a
          const l = r.get(t)
          l && e.remove(l), r.set(t, o)
        }
        return {
          get: function (t, e) {
            return !0 === s[e.id] || (e.addEventListener('dispose', a), (s[e.id] = !0), i.memory.geometries++), e
          },
          update: function (t) {
            const i = t.attributes
            for (const s in i) e.update(i[s], 34962)
            const n = t.morphAttributes
            for (const s in n) {
              const t = n[s]
              for (let i = 0, n = t.length; i < n; i++) e.update(t[i], 34962)
            }
          },
          getWireframeAttribute: function (t) {
            const e = r.get(t)
            if (e) {
              const i = t.index
              null !== i && e.version < i.version && o(t)
            } else o(t)
            return r.get(t)
          },
        }
      }
      function Qn(t, e, i, n) {
        const s = n.isWebGL2
        let r, a, o
        ;(this.setMode = function (t) {
          r = t
        }),
          (this.setIndex = function (t) {
            ;(a = t.type), (o = t.bytesPerElement)
          }),
          (this.render = function (e, n) {
            t.drawElements(r, n, a, e * o), i.update(n, r, 1)
          }),
          (this.renderInstances = function (n, l, c) {
            if (0 === c) return
            let h, u
            if (s) (h = t), (u = 'drawElementsInstanced')
            else if (((h = e.get('ANGLE_instanced_arrays')), (u = 'drawElementsInstancedANGLE'), null === h)) return
            h[u](r, l, a, n * o, c), i.update(l, r, c)
          })
      }
      function Rn(t) {
        const e = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 }
        return {
          memory: { geometries: 0, textures: 0 },
          render: e,
          programs: null,
          autoReset: !0,
          reset: function () {
            e.frame++, (e.calls = 0), (e.triangles = 0), (e.points = 0), (e.lines = 0)
          },
          update: function (t, i, n) {
            switch ((e.calls++, i)) {
              case 4:
                e.triangles += n * (t / 3)
                break
              case 1:
                e.lines += n * (t / 2)
                break
              case 3:
                e.lines += n * (t - 1)
                break
              case 2:
                e.lines += n * t
                break
              case 0:
                e.points += n * t
            }
          },
        }
      }
      function Pn(t, e) {
        return t[0] - e[0]
      }
      function Nn(t, e) {
        return Math.abs(e[1]) - Math.abs(t[1])
      }
      function Fn(t) {
        const e = {},
          i = new Float32Array(8),
          n = []
        for (let s = 0; s < 8; s++) n[s] = [s, 0]
        return {
          update: function (s, r, a, o) {
            const l = s.morphTargetInfluences,
              c = void 0 === l ? 0 : l.length
            let h = e[r.id]
            if (void 0 === h || h.length !== c) {
              h = []
              for (let t = 0; t < c; t++) h[t] = [t, 0]
              e[r.id] = h
            }
            for (let t = 0; t < c; t++) {
              const e = h[t]
              ;(e[0] = t), (e[1] = l[t])
            }
            h.sort(Nn)
            for (let t = 0; t < 8; t++)
              t < c && h[t][1]
                ? ((n[t][0] = h[t][0]), (n[t][1] = h[t][1]))
                : ((n[t][0] = Number.MAX_SAFE_INTEGER), (n[t][1] = 0))
            n.sort(Pn)
            const u = r.morphAttributes.position,
              d = r.morphAttributes.normal
            let p = 0
            for (let t = 0; t < 8; t++) {
              const e = n[t],
                s = e[0],
                a = e[1]
              s !== Number.MAX_SAFE_INTEGER && a
                ? (u && r.getAttribute('morphTarget' + t) !== u[s] && r.setAttribute('morphTarget' + t, u[s]),
                  d && r.getAttribute('morphNormal' + t) !== d[s] && r.setAttribute('morphNormal' + t, d[s]),
                  (i[t] = a),
                  (p += a))
                : (u && !0 === r.hasAttribute('morphTarget' + t) && r.deleteAttribute('morphTarget' + t),
                  d && !0 === r.hasAttribute('morphNormal' + t) && r.deleteAttribute('morphNormal' + t),
                  (i[t] = 0))
            }
            const A = r.morphTargetsRelative ? 1 : 1 - p
            o.getUniforms().setValue(t, 'morphTargetBaseInfluence', A),
              o.getUniforms().setValue(t, 'morphTargetInfluences', i)
          },
        }
      }
      function Un(t, e, i, n) {
        let s = new WeakMap()
        function r(t) {
          const e = t.target
          e.removeEventListener('dispose', r),
            i.remove(e.instanceMatrix),
            null !== e.instanceColor && i.remove(e.instanceColor)
        }
        return {
          update: function (t) {
            const a = n.render.frame,
              o = t.geometry,
              l = e.get(t, o)
            return (
              s.get(l) !== a && (e.update(l), s.set(l, a)),
              t.isInstancedMesh &&
                (!1 === t.hasEventListener('dispose', r) && t.addEventListener('dispose', r),
                i.update(t.instanceMatrix, 34962),
                null !== t.instanceColor && i.update(t.instanceColor, 34962)),
              l
            )
          },
          dispose: function () {
            s = new WeakMap()
          },
        }
      }
      class kn extends xt {
        constructor(t = null, e = 1, i = 1, n = 1) {
          super(null),
            (this.image = { data: t, width: e, height: i, depth: n }),
            (this.magFilter = 1003),
            (this.minFilter = 1003),
            (this.wrapR = 1001),
            (this.generateMipmaps = !1),
            (this.flipY = !1),
            (this.unpackAlignment = 1),
            (this.needsUpdate = !0)
        }
      }
      kn.prototype.isDataTexture2DArray = !0
      class On extends xt {
        constructor(t = null, e = 1, i = 1, n = 1) {
          super(null),
            (this.image = { data: t, width: e, height: i, depth: n }),
            (this.magFilter = 1003),
            (this.minFilter = 1003),
            (this.wrapR = 1001),
            (this.generateMipmaps = !1),
            (this.flipY = !1),
            (this.unpackAlignment = 1),
            (this.needsUpdate = !0)
        }
      }
      On.prototype.isDataTexture3D = !0
      const Gn = new xt(),
        zn = new kn(),
        Vn = new On(),
        Hn = new Ui(),
        Wn = [],
        qn = [],
        jn = new Float32Array(16),
        Yn = new Float32Array(9),
        Jn = new Float32Array(4)
      function Xn(t, e, i) {
        const n = t[0]
        if (n <= 0 || n > 0) return t
        const s = e * i
        let r = Wn[s]
        if ((void 0 === r && ((r = new Float32Array(s)), (Wn[s] = r)), 0 !== e)) {
          n.toArray(r, 0)
          for (let n = 1, s = 0; n !== e; ++n) (s += i), t[n].toArray(r, s)
        }
        return r
      }
      function Kn(t, e) {
        if (t.length !== e.length) return !1
        for (let i = 0, n = t.length; i < n; i++) if (t[i] !== e[i]) return !1
        return !0
      }
      function Zn(t, e) {
        for (let i = 0, n = e.length; i < n; i++) t[i] = e[i]
      }
      function $n(t, e) {
        let i = qn[e]
        void 0 === i && ((i = new Int32Array(e)), (qn[e] = i))
        for (let n = 0; n !== e; ++n) i[n] = t.allocateTextureUnit()
        return i
      }
      function ts(t, e) {
        const i = this.cache
        i[0] !== e && (t.uniform1f(this.addr, e), (i[0] = e))
      }
      function es(t, e) {
        const i = this.cache
        if (void 0 !== e.x)
          (i[0] === e.x && i[1] === e.y) || (t.uniform2f(this.addr, e.x, e.y), (i[0] = e.x), (i[1] = e.y))
        else {
          if (Kn(i, e)) return
          t.uniform2fv(this.addr, e), Zn(i, e)
        }
      }
      function is(t, e) {
        const i = this.cache
        if (void 0 !== e.x)
          (i[0] === e.x && i[1] === e.y && i[2] === e.z) ||
            (t.uniform3f(this.addr, e.x, e.y, e.z), (i[0] = e.x), (i[1] = e.y), (i[2] = e.z))
        else if (void 0 !== e.r)
          (i[0] === e.r && i[1] === e.g && i[2] === e.b) ||
            (t.uniform3f(this.addr, e.r, e.g, e.b), (i[0] = e.r), (i[1] = e.g), (i[2] = e.b))
        else {
          if (Kn(i, e)) return
          t.uniform3fv(this.addr, e), Zn(i, e)
        }
      }
      function ns(t, e) {
        const i = this.cache
        if (void 0 !== e.x)
          (i[0] === e.x && i[1] === e.y && i[2] === e.z && i[3] === e.w) ||
            (t.uniform4f(this.addr, e.x, e.y, e.z, e.w), (i[0] = e.x), (i[1] = e.y), (i[2] = e.z), (i[3] = e.w))
        else {
          if (Kn(i, e)) return
          t.uniform4fv(this.addr, e), Zn(i, e)
        }
      }
      function ss(t, e) {
        const i = this.cache,
          n = e.elements
        if (void 0 === n) {
          if (Kn(i, e)) return
          t.uniformMatrix2fv(this.addr, !1, e), Zn(i, e)
        } else {
          if (Kn(i, n)) return
          Jn.set(n), t.uniformMatrix2fv(this.addr, !1, Jn), Zn(i, n)
        }
      }
      function rs(t, e) {
        const i = this.cache,
          n = e.elements
        if (void 0 === n) {
          if (Kn(i, e)) return
          t.uniformMatrix3fv(this.addr, !1, e), Zn(i, e)
        } else {
          if (Kn(i, n)) return
          Yn.set(n), t.uniformMatrix3fv(this.addr, !1, Yn), Zn(i, n)
        }
      }
      function as(t, e) {
        const i = this.cache,
          n = e.elements
        if (void 0 === n) {
          if (Kn(i, e)) return
          t.uniformMatrix4fv(this.addr, !1, e), Zn(i, e)
        } else {
          if (Kn(i, n)) return
          jn.set(n), t.uniformMatrix4fv(this.addr, !1, jn), Zn(i, n)
        }
      }
      function os(t, e) {
        const i = this.cache
        i[0] !== e && (t.uniform1i(this.addr, e), (i[0] = e))
      }
      function ls(t, e) {
        const i = this.cache
        Kn(i, e) || (t.uniform2iv(this.addr, e), Zn(i, e))
      }
      function cs(t, e) {
        const i = this.cache
        Kn(i, e) || (t.uniform3iv(this.addr, e), Zn(i, e))
      }
      function hs(t, e) {
        const i = this.cache
        Kn(i, e) || (t.uniform4iv(this.addr, e), Zn(i, e))
      }
      function us(t, e) {
        const i = this.cache
        i[0] !== e && (t.uniform1ui(this.addr, e), (i[0] = e))
      }
      function ds(t, e) {
        const i = this.cache
        Kn(i, e) || (t.uniform2uiv(this.addr, e), Zn(i, e))
      }
      function ps(t, e) {
        const i = this.cache
        Kn(i, e) || (t.uniform3uiv(this.addr, e), Zn(i, e))
      }
      function As(t, e) {
        const i = this.cache
        Kn(i, e) || (t.uniform4uiv(this.addr, e), Zn(i, e))
      }
      function gs(t, e, i) {
        const n = this.cache,
          s = i.allocateTextureUnit()
        n[0] !== s && (t.uniform1i(this.addr, s), (n[0] = s)), i.safeSetTexture2D(e || Gn, s)
      }
      function ms(t, e, i) {
        const n = this.cache,
          s = i.allocateTextureUnit()
        n[0] !== s && (t.uniform1i(this.addr, s), (n[0] = s)), i.setTexture3D(e || Vn, s)
      }
      function fs(t, e, i) {
        const n = this.cache,
          s = i.allocateTextureUnit()
        n[0] !== s && (t.uniform1i(this.addr, s), (n[0] = s)), i.safeSetTextureCube(e || Hn, s)
      }
      function vs(t, e, i) {
        const n = this.cache,
          s = i.allocateTextureUnit()
        n[0] !== s && (t.uniform1i(this.addr, s), (n[0] = s)), i.setTexture2DArray(e || zn, s)
      }
      function ys(t, e) {
        t.uniform1fv(this.addr, e)
      }
      function xs(t, e) {
        const i = Xn(e, this.size, 2)
        t.uniform2fv(this.addr, i)
      }
      function ws(t, e) {
        const i = Xn(e, this.size, 3)
        t.uniform3fv(this.addr, i)
      }
      function _s(t, e) {
        const i = Xn(e, this.size, 4)
        t.uniform4fv(this.addr, i)
      }
      function Is(t, e) {
        const i = Xn(e, this.size, 4)
        t.uniformMatrix2fv(this.addr, !1, i)
      }
      function Cs(t, e) {
        const i = Xn(e, this.size, 9)
        t.uniformMatrix3fv(this.addr, !1, i)
      }
      function Ms(t, e) {
        const i = Xn(e, this.size, 16)
        t.uniformMatrix4fv(this.addr, !1, i)
      }
      function Es(t, e) {
        t.uniform1iv(this.addr, e)
      }
      function bs(t, e) {
        t.uniform2iv(this.addr, e)
      }
      function Ss(t, e) {
        t.uniform3iv(this.addr, e)
      }
      function Bs(t, e) {
        t.uniform4iv(this.addr, e)
      }
      function Ts(t, e) {
        t.uniform1uiv(this.addr, e)
      }
      function Ls(t, e) {
        t.uniform2uiv(this.addr, e)
      }
      function Ds(t, e) {
        t.uniform3uiv(this.addr, e)
      }
      function Qs(t, e) {
        t.uniform4uiv(this.addr, e)
      }
      function Rs(t, e, i) {
        const n = e.length,
          s = $n(i, n)
        t.uniform1iv(this.addr, s)
        for (let r = 0; r !== n; ++r) i.safeSetTexture2D(e[r] || Gn, s[r])
      }
      function Ps(t, e, i) {
        const n = e.length,
          s = $n(i, n)
        t.uniform1iv(this.addr, s)
        for (let r = 0; r !== n; ++r) i.safeSetTextureCube(e[r] || Hn, s[r])
      }
      function Ns(t, e, i) {
        ;(this.id = t),
          (this.addr = i),
          (this.cache = []),
          (this.setValue = (function (t) {
            switch (t) {
              case 5126:
                return ts
              case 35664:
                return es
              case 35665:
                return is
              case 35666:
                return ns
              case 35674:
                return ss
              case 35675:
                return rs
              case 35676:
                return as
              case 5124:
              case 35670:
                return os
              case 35667:
              case 35671:
                return ls
              case 35668:
              case 35672:
                return cs
              case 35669:
              case 35673:
                return hs
              case 5125:
                return us
              case 36294:
                return ds
              case 36295:
                return ps
              case 36296:
                return As
              case 35678:
              case 36198:
              case 36298:
              case 36306:
              case 35682:
                return gs
              case 35679:
              case 36299:
              case 36307:
                return ms
              case 35680:
              case 36300:
              case 36308:
              case 36293:
                return fs
              case 36289:
              case 36303:
              case 36311:
              case 36292:
                return vs
            }
          })(e.type))
      }
      function Fs(t, e, i) {
        ;(this.id = t),
          (this.addr = i),
          (this.cache = []),
          (this.size = e.size),
          (this.setValue = (function (t) {
            switch (t) {
              case 5126:
                return ys
              case 35664:
                return xs
              case 35665:
                return ws
              case 35666:
                return _s
              case 35674:
                return Is
              case 35675:
                return Cs
              case 35676:
                return Ms
              case 5124:
              case 35670:
                return Es
              case 35667:
              case 35671:
                return bs
              case 35668:
              case 35672:
                return Ss
              case 35669:
              case 35673:
                return Bs
              case 5125:
                return Ts
              case 36294:
                return Ls
              case 36295:
                return Ds
              case 36296:
                return Qs
              case 35678:
              case 36198:
              case 36298:
              case 36306:
              case 35682:
                return Rs
              case 35680:
              case 36300:
              case 36308:
              case 36293:
                return Ps
            }
          })(e.type))
      }
      function Us(t) {
        ;(this.id = t), (this.seq = []), (this.map = {})
      }
      ;(Fs.prototype.updateCache = function (t) {
        const e = this.cache
        t instanceof Float32Array && e.length !== t.length && (this.cache = new Float32Array(t.length)), Zn(e, t)
      }),
        (Us.prototype.setValue = function (t, e, i) {
          const n = this.seq
          for (let s = 0, r = n.length; s !== r; ++s) {
            const r = n[s]
            r.setValue(t, e[r.id], i)
          }
        })
      const ks = /(\w+)(\])?(\[|\.)?/g
      function Os(t, e) {
        t.seq.push(e), (t.map[e.id] = e)
      }
      function Gs(t, e, i) {
        const n = t.name,
          s = n.length
        for (ks.lastIndex = 0; ; ) {
          const r = ks.exec(n),
            a = ks.lastIndex
          let o = r[1]
          const l = ']' === r[2],
            c = r[3]
          if ((l && (o |= 0), void 0 === c || ('[' === c && a + 2 === s))) {
            Os(i, void 0 === c ? new Ns(o, t, e) : new Fs(o, t, e))
            break
          }
          {
            let t = i.map[o]
            void 0 === t && ((t = new Us(o)), Os(i, t)), (i = t)
          }
        }
      }
      function zs(t, e) {
        ;(this.seq = []), (this.map = {})
        const i = t.getProgramParameter(e, 35718)
        for (let n = 0; n < i; ++n) {
          const i = t.getActiveUniform(e, n)
          Gs(i, t.getUniformLocation(e, i.name), this)
        }
      }
      function Vs(t, e, i) {
        const n = t.createShader(e)
        return t.shaderSource(n, i), t.compileShader(n), n
      }
      ;(zs.prototype.setValue = function (t, e, i, n) {
        const s = this.map[e]
        void 0 !== s && s.setValue(t, i, n)
      }),
        (zs.prototype.setOptional = function (t, e, i) {
          const n = e[i]
          void 0 !== n && this.setValue(t, i, n)
        }),
        (zs.upload = function (t, e, i, n) {
          for (let s = 0, r = e.length; s !== r; ++s) {
            const r = e[s],
              a = i[r.id]
            !1 !== a.needsUpdate && r.setValue(t, a.value, n)
          }
        }),
        (zs.seqWithValue = function (t, e) {
          const i = []
          for (let n = 0, s = t.length; n !== s; ++n) {
            const s = t[n]
            s.id in e && i.push(s)
          }
          return i
        })
      let Hs = 0
      function Ws(t) {
        switch (t) {
          case 3e3:
            return ['Linear', '( value )']
          case 3001:
            return ['sRGB', '( value )']
          case 3002:
            return ['RGBE', '( value )']
          case 3004:
            return ['RGBM', '( value, 7.0 )']
          case 3005:
            return ['RGBM', '( value, 16.0 )']
          case 3006:
            return ['RGBD', '( value, 256.0 )']
          case 3007:
            return ['Gamma', '( value, float( GAMMA_FACTOR ) )']
          case 3003:
            return ['LogLuv', '( value )']
          default:
            return ['Linear', '( value )']
        }
      }
      function qs(t, e, i) {
        const n = t.getShaderParameter(e, 35713),
          s = t.getShaderInfoLog(e).trim()
        return n && '' === s
          ? ''
          : 'THREE.WebGLShader: gl.getShaderInfoLog() ' +
              i +
              '\n' +
              s +
              (function (t) {
                const e = t.split('\n')
                for (let i = 0; i < e.length; i++) e[i] = i + 1 + ': ' + e[i]
                return e.join('\n')
              })(t.getShaderSource(e))
      }
      function js(t, e) {
        const i = Ws(e)
        return 'vec4 ' + t + '( vec4 value ) { return ' + i[0] + 'ToLinear' + i[1] + '; }'
      }
      function Ys(t, e) {
        const i = Ws(e)
        return 'vec4 ' + t + '( vec4 value ) { return LinearTo' + i[0] + i[1] + '; }'
      }
      function Js(t, e) {
        let i
        switch (e) {
          case 1:
            i = 'Linear'
            break
          case 2:
            i = 'Reinhard'
            break
          case 3:
            i = 'OptimizedCineon'
            break
          case 4:
            i = 'ACESFilmic'
            break
          case 5:
            i = 'Custom'
            break
          default:
            i = 'Linear'
        }
        return 'vec3 ' + t + '( vec3 color ) { return ' + i + 'ToneMapping( color ); }'
      }
      function Xs(t) {
        return '' !== t
      }
      function Ks(t, e) {
        return t
          .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
          .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
          .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
          .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
          .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
          .replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
          .replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
          .replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
      }
      function Zs(t, e) {
        return t
          .replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
          .replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
      }
      const $s = /^[ \t]*#include +<([\w\d./]+)>/gm
      function tr(t) {
        return t.replace($s, er)
      }
      function er(t, e) {
        const i = Xi[e]
        if (void 0 === i) throw new Error('Can not resolve #include <' + e + '>')
        return tr(i)
      }
      const ir = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
        nr =
          /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g
      function sr(t) {
        return t.replace(nr, ar).replace(ir, rr)
      }
      function rr(t, e, i, n) {
        return ar(t, e, i, n)
      }
      function ar(t, e, i, n) {
        let s = ''
        for (let r = parseInt(e); r < parseInt(i); r++)
          s += n.replace(/\[\s*i\s*\]/g, '[ ' + r + ' ]').replace(/UNROLLED_LOOP_INDEX/g, r)
        return s
      }
      function or(t) {
        let e = 'precision ' + t.precision + ' float;\nprecision ' + t.precision + ' int;'
        return (
          'highp' === t.precision
            ? (e += '\n#define HIGH_PRECISION')
            : 'mediump' === t.precision
            ? (e += '\n#define MEDIUM_PRECISION')
            : 'lowp' === t.precision && (e += '\n#define LOW_PRECISION'),
          e
        )
      }
      function lr(t, e, i, n) {
        const s = t.getContext(),
          r = i.defines
        let a = i.vertexShader,
          o = i.fragmentShader
        const l = (function (t) {
            let e = 'SHADOWMAP_TYPE_BASIC'
            return (
              1 === t.shadowMapType
                ? (e = 'SHADOWMAP_TYPE_PCF')
                : 2 === t.shadowMapType
                ? (e = 'SHADOWMAP_TYPE_PCF_SOFT')
                : 3 === t.shadowMapType && (e = 'SHADOWMAP_TYPE_VSM'),
              e
            )
          })(i),
          c = (function (t) {
            let e = 'ENVMAP_TYPE_CUBE'
            if (t.envMap)
              switch (t.envMapMode) {
                case 301:
                case 302:
                  e = 'ENVMAP_TYPE_CUBE'
                  break
                case 306:
                case 307:
                  e = 'ENVMAP_TYPE_CUBE_UV'
              }
            return e
          })(i),
          h = (function (t) {
            let e = 'ENVMAP_MODE_REFLECTION'
            if (t.envMap)
              switch (t.envMapMode) {
                case 302:
                case 307:
                  e = 'ENVMAP_MODE_REFRACTION'
              }
            return e
          })(i),
          u = (function (t) {
            let e = 'ENVMAP_BLENDING_NONE'
            if (t.envMap)
              switch (t.combine) {
                case 0:
                  e = 'ENVMAP_BLENDING_MULTIPLY'
                  break
                case 1:
                  e = 'ENVMAP_BLENDING_MIX'
                  break
                case 2:
                  e = 'ENVMAP_BLENDING_ADD'
              }
            return e
          })(i),
          d = t.gammaFactor > 0 ? t.gammaFactor : 1,
          p = i.isWebGL2
            ? ''
            : (function (t) {
                return [
                  t.extensionDerivatives ||
                  t.envMapCubeUV ||
                  t.bumpMap ||
                  t.tangentSpaceNormalMap ||
                  t.clearcoatNormalMap ||
                  t.flatShading ||
                  'physical' === t.shaderID
                    ? '#extension GL_OES_standard_derivatives : enable'
                    : '',
                  (t.extensionFragDepth || t.logarithmicDepthBuffer) && t.rendererExtensionFragDepth
                    ? '#extension GL_EXT_frag_depth : enable'
                    : '',
                  t.extensionDrawBuffers && t.rendererExtensionDrawBuffers
                    ? '#extension GL_EXT_draw_buffers : require'
                    : '',
                  (t.extensionShaderTextureLOD || t.envMap || t.transmission > 0) && t.rendererExtensionShaderTextureLod
                    ? '#extension GL_EXT_shader_texture_lod : enable'
                    : '',
                ]
                  .filter(Xs)
                  .join('\n')
              })(i),
          A = (function (t) {
            const e = []
            for (const i in t) {
              const n = t[i]
              !1 !== n && e.push('#define ' + i + ' ' + n)
            }
            return e.join('\n')
          })(r),
          g = s.createProgram()
        let m,
          f,
          v = i.glslVersion ? '#version ' + i.glslVersion + '\n' : ''
        i.isRawShaderMaterial
          ? ((m = [A].filter(Xs).join('\n')),
            m.length > 0 && (m += '\n'),
            (f = [p, A].filter(Xs).join('\n')),
            f.length > 0 && (f += '\n'))
          : ((m = [
              or(i),
              '#define SHADER_NAME ' + i.shaderName,
              A,
              i.instancing ? '#define USE_INSTANCING' : '',
              i.instancingColor ? '#define USE_INSTANCING_COLOR' : '',
              i.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',
              '#define GAMMA_FACTOR ' + d,
              '#define MAX_BONES ' + i.maxBones,
              i.useFog && i.fog ? '#define USE_FOG' : '',
              i.useFog && i.fogExp2 ? '#define FOG_EXP2' : '',
              i.map ? '#define USE_MAP' : '',
              i.envMap ? '#define USE_ENVMAP' : '',
              i.envMap ? '#define ' + h : '',
              i.lightMap ? '#define USE_LIGHTMAP' : '',
              i.aoMap ? '#define USE_AOMAP' : '',
              i.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
              i.bumpMap ? '#define USE_BUMPMAP' : '',
              i.normalMap ? '#define USE_NORMALMAP' : '',
              i.normalMap && i.objectSpaceNormalMap ? '#define OBJECTSPACE_NORMALMAP' : '',
              i.normalMap && i.tangentSpaceNormalMap ? '#define TANGENTSPACE_NORMALMAP' : '',
              i.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
              i.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
              i.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
              i.displacementMap && i.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',
              i.specularMap ? '#define USE_SPECULARMAP' : '',
              i.specularIntensityMap ? '#define USE_SPECULARINTENSITYMAP' : '',
              i.specularTintMap ? '#define USE_SPECULARTINTMAP' : '',
              i.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
              i.metalnessMap ? '#define USE_METALNESSMAP' : '',
              i.alphaMap ? '#define USE_ALPHAMAP' : '',
              i.transmission ? '#define USE_TRANSMISSION' : '',
              i.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
              i.thicknessMap ? '#define USE_THICKNESSMAP' : '',
              i.vertexTangents ? '#define USE_TANGENT' : '',
              i.vertexColors ? '#define USE_COLOR' : '',
              i.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
              i.vertexUvs ? '#define USE_UV' : '',
              i.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',
              i.flatShading ? '#define FLAT_SHADED' : '',
              i.skinning ? '#define USE_SKINNING' : '',
              i.useVertexTexture ? '#define BONE_TEXTURE' : '',
              i.morphTargets ? '#define USE_MORPHTARGETS' : '',
              i.morphNormals && !1 === i.flatShading ? '#define USE_MORPHNORMALS' : '',
              i.doubleSided ? '#define DOUBLE_SIDED' : '',
              i.flipSided ? '#define FLIP_SIDED' : '',
              i.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
              i.shadowMapEnabled ? '#define ' + l : '',
              i.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',
              i.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
              i.logarithmicDepthBuffer && i.rendererExtensionFragDepth ? '#define USE_LOGDEPTHBUF_EXT' : '',
              'uniform mat4 modelMatrix;',
              'uniform mat4 modelViewMatrix;',
              'uniform mat4 projectionMatrix;',
              'uniform mat4 viewMatrix;',
              'uniform mat3 normalMatrix;',
              'uniform vec3 cameraPosition;',
              'uniform bool isOrthographic;',
              '#ifdef USE_INSTANCING',
              '\tattribute mat4 instanceMatrix;',
              '#endif',
              '#ifdef USE_INSTANCING_COLOR',
              '\tattribute vec3 instanceColor;',
              '#endif',
              'attribute vec3 position;',
              'attribute vec3 normal;',
              'attribute vec2 uv;',
              '#ifdef USE_TANGENT',
              '\tattribute vec4 tangent;',
              '#endif',
              '#if defined( USE_COLOR_ALPHA )',
              '\tattribute vec4 color;',
              '#elif defined( USE_COLOR )',
              '\tattribute vec3 color;',
              '#endif',
              '#ifdef USE_MORPHTARGETS',
              '\tattribute vec3 morphTarget0;',
              '\tattribute vec3 morphTarget1;',
              '\tattribute vec3 morphTarget2;',
              '\tattribute vec3 morphTarget3;',
              '\t#ifdef USE_MORPHNORMALS',
              '\t\tattribute vec3 morphNormal0;',
              '\t\tattribute vec3 morphNormal1;',
              '\t\tattribute vec3 morphNormal2;',
              '\t\tattribute vec3 morphNormal3;',
              '\t#else',
              '\t\tattribute vec3 morphTarget4;',
              '\t\tattribute vec3 morphTarget5;',
              '\t\tattribute vec3 morphTarget6;',
              '\t\tattribute vec3 morphTarget7;',
              '\t#endif',
              '#endif',
              '#ifdef USE_SKINNING',
              '\tattribute vec4 skinIndex;',
              '\tattribute vec4 skinWeight;',
              '#endif',
              '\n',
            ]
              .filter(Xs)
              .join('\n')),
            (f = [
              p,
              or(i),
              '#define SHADER_NAME ' + i.shaderName,
              A,
              i.alphaTest ? '#define ALPHATEST ' + i.alphaTest + (i.alphaTest % 1 ? '' : '.0') : '',
              '#define GAMMA_FACTOR ' + d,
              i.useFog && i.fog ? '#define USE_FOG' : '',
              i.useFog && i.fogExp2 ? '#define FOG_EXP2' : '',
              i.map ? '#define USE_MAP' : '',
              i.matcap ? '#define USE_MATCAP' : '',
              i.envMap ? '#define USE_ENVMAP' : '',
              i.envMap ? '#define ' + c : '',
              i.envMap ? '#define ' + h : '',
              i.envMap ? '#define ' + u : '',
              i.lightMap ? '#define USE_LIGHTMAP' : '',
              i.aoMap ? '#define USE_AOMAP' : '',
              i.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
              i.bumpMap ? '#define USE_BUMPMAP' : '',
              i.normalMap ? '#define USE_NORMALMAP' : '',
              i.normalMap && i.objectSpaceNormalMap ? '#define OBJECTSPACE_NORMALMAP' : '',
              i.normalMap && i.tangentSpaceNormalMap ? '#define TANGENTSPACE_NORMALMAP' : '',
              i.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
              i.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
              i.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
              i.specularMap ? '#define USE_SPECULARMAP' : '',
              i.specularIntensityMap ? '#define USE_SPECULARINTENSITYMAP' : '',
              i.specularTintMap ? '#define USE_SPECULARTINTMAP' : '',
              i.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
              i.metalnessMap ? '#define USE_METALNESSMAP' : '',
              i.alphaMap ? '#define USE_ALPHAMAP' : '',
              i.sheen ? '#define USE_SHEEN' : '',
              i.transmission ? '#define USE_TRANSMISSION' : '',
              i.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
              i.thicknessMap ? '#define USE_THICKNESSMAP' : '',
              i.vertexTangents ? '#define USE_TANGENT' : '',
              i.vertexColors || i.instancingColor ? '#define USE_COLOR' : '',
              i.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
              i.vertexUvs ? '#define USE_UV' : '',
              i.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',
              i.gradientMap ? '#define USE_GRADIENTMAP' : '',
              i.flatShading ? '#define FLAT_SHADED' : '',
              i.doubleSided ? '#define DOUBLE_SIDED' : '',
              i.flipSided ? '#define FLIP_SIDED' : '',
              i.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
              i.shadowMapEnabled ? '#define ' + l : '',
              i.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',
              i.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '',
              i.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
              i.logarithmicDepthBuffer && i.rendererExtensionFragDepth ? '#define USE_LOGDEPTHBUF_EXT' : '',
              (i.extensionShaderTextureLOD || i.envMap) && i.rendererExtensionShaderTextureLod
                ? '#define TEXTURE_LOD_EXT'
                : '',
              'uniform mat4 viewMatrix;',
              'uniform vec3 cameraPosition;',
              'uniform bool isOrthographic;',
              0 !== i.toneMapping ? '#define TONE_MAPPING' : '',
              0 !== i.toneMapping ? Xi.tonemapping_pars_fragment : '',
              0 !== i.toneMapping ? Js('toneMapping', i.toneMapping) : '',
              i.dithering ? '#define DITHERING' : '',
              Xi.encodings_pars_fragment,
              i.map ? js('mapTexelToLinear', i.mapEncoding) : '',
              i.matcap ? js('matcapTexelToLinear', i.matcapEncoding) : '',
              i.envMap ? js('envMapTexelToLinear', i.envMapEncoding) : '',
              i.emissiveMap ? js('emissiveMapTexelToLinear', i.emissiveMapEncoding) : '',
              i.specularTintMap ? js('specularTintMapTexelToLinear', i.specularTintMapEncoding) : '',
              i.lightMap ? js('lightMapTexelToLinear', i.lightMapEncoding) : '',
              Ys('linearToOutputTexel', i.outputEncoding),
              i.depthPacking ? '#define DEPTH_PACKING ' + i.depthPacking : '',
              '\n',
            ]
              .filter(Xs)
              .join('\n'))),
          (a = tr(a)),
          (a = Ks(a, i)),
          (a = Zs(a, i)),
          (o = tr(o)),
          (o = Ks(o, i)),
          (o = Zs(o, i)),
          (a = sr(a)),
          (o = sr(o)),
          i.isWebGL2 &&
            !0 !== i.isRawShaderMaterial &&
            ((v = '#version 300 es\n'),
            (m = ['#define attribute in', '#define varying out', '#define texture2D texture'].join('\n') + '\n' + m),
            (f =
              [
                '#define varying in',
                '300 es' === i.glslVersion ? '' : 'out highp vec4 pc_fragColor;',
                '300 es' === i.glslVersion ? '' : '#define gl_FragColor pc_fragColor',
                '#define gl_FragDepthEXT gl_FragDepth',
                '#define texture2D texture',
                '#define textureCube texture',
                '#define texture2DProj textureProj',
                '#define texture2DLodEXT textureLod',
                '#define texture2DProjLodEXT textureProjLod',
                '#define textureCubeLodEXT textureLod',
                '#define texture2DGradEXT textureGrad',
                '#define texture2DProjGradEXT textureProjGrad',
                '#define textureCubeGradEXT textureGrad',
              ].join('\n') +
              '\n' +
              f))
        const y = v + f + o,
          x = Vs(s, 35633, v + m + a),
          w = Vs(s, 35632, y)
        if (
          (s.attachShader(g, x),
          s.attachShader(g, w),
          void 0 !== i.index0AttributeName
            ? s.bindAttribLocation(g, 0, i.index0AttributeName)
            : !0 === i.morphTargets && s.bindAttribLocation(g, 0, 'position'),
          s.linkProgram(g),
          t.debug.checkShaderErrors)
        ) {
          const t = s.getProgramInfoLog(g).trim(),
            e = s.getShaderInfoLog(x).trim(),
            i = s.getShaderInfoLog(w).trim()
          let n = !0,
            r = !0
          if (!1 === s.getProgramParameter(g, 35714)) {
            n = !1
            qs(s, x, 'vertex'), qs(s, w, 'fragment')
          } else '' !== t || ('' !== e && '' !== i) || (r = !1)
          r &&
            (this.diagnostics = {
              runnable: n,
              programLog: t,
              vertexShader: { log: e, prefix: m },
              fragmentShader: { log: i, prefix: f },
            })
        }
        let _, I
        return (
          s.deleteShader(x),
          s.deleteShader(w),
          (this.getUniforms = function () {
            return void 0 === _ && (_ = new zs(s, g)), _
          }),
          (this.getAttributes = function () {
            return (
              void 0 === I &&
                (I = (function (t, e) {
                  const i = {},
                    n = t.getProgramParameter(e, 35721)
                  for (let s = 0; s < n; s++) {
                    const n = t.getActiveAttrib(e, s).name
                    i[n] = t.getAttribLocation(e, n)
                  }
                  return i
                })(s, g)),
              I
            )
          }),
          (this.destroy = function () {
            n.releaseStatesOfProgram(this), s.deleteProgram(g), (this.program = void 0)
          }),
          (this.name = i.shaderName),
          (this.id = Hs++),
          (this.cacheKey = e),
          (this.usedTimes = 1),
          (this.program = g),
          (this.vertexShader = x),
          (this.fragmentShader = w),
          this
        )
      }
      function cr(t, e, i, n, s, r, a) {
        const o = [],
          l = s.isWebGL2,
          c = s.logarithmicDepthBuffer,
          h = s.floatVertexTextures,
          u = s.maxVertexUniforms,
          d = s.vertexTextures
        let p = s.precision
        const A = {
            MeshDepthMaterial: 'depth',
            MeshDistanceMaterial: 'distanceRGBA',
            MeshNormalMaterial: 'normal',
            MeshBasicMaterial: 'basic',
            MeshLambertMaterial: 'lambert',
            MeshPhongMaterial: 'phong',
            MeshToonMaterial: 'toon',
            MeshStandardMaterial: 'physical',
            MeshPhysicalMaterial: 'physical',
            MeshMatcapMaterial: 'matcap',
            LineBasicMaterial: 'basic',
            LineDashedMaterial: 'dashed',
            PointsMaterial: 'points',
            ShadowMaterial: 'shadow',
            SpriteMaterial: 'sprite',
          },
          g = [
            'precision',
            'isWebGL2',
            'supportsVertexTextures',
            'outputEncoding',
            'instancing',
            'instancingColor',
            'map',
            'mapEncoding',
            'matcap',
            'matcapEncoding',
            'envMap',
            'envMapMode',
            'envMapEncoding',
            'envMapCubeUV',
            'lightMap',
            'lightMapEncoding',
            'aoMap',
            'emissiveMap',
            'emissiveMapEncoding',
            'bumpMap',
            'normalMap',
            'objectSpaceNormalMap',
            'tangentSpaceNormalMap',
            'clearcoatMap',
            'clearcoatRoughnessMap',
            'clearcoatNormalMap',
            'displacementMap',
            'specularMap',
            'specularIntensityMap',
            'specularTintMap',
            'specularTintMapEncoding',
            'roughnessMap',
            'metalnessMap',
            'gradientMap',
            'alphaMap',
            'combine',
            'vertexColors',
            'vertexAlphas',
            'vertexTangents',
            'vertexUvs',
            'uvsVertexOnly',
            'fog',
            'useFog',
            'fogExp2',
            'flatShading',
            'sizeAttenuation',
            'logarithmicDepthBuffer',
            'skinning',
            'maxBones',
            'useVertexTexture',
            'morphTargets',
            'morphNormals',
            'premultipliedAlpha',
            'numDirLights',
            'numPointLights',
            'numSpotLights',
            'numHemiLights',
            'numRectAreaLights',
            'numDirLightShadows',
            'numPointLightShadows',
            'numSpotLightShadows',
            'shadowMapEnabled',
            'shadowMapType',
            'toneMapping',
            'physicallyCorrectLights',
            'alphaTest',
            'doubleSided',
            'flipSided',
            'numClippingPlanes',
            'numClipIntersection',
            'depthPacking',
            'dithering',
            'sheen',
            'transmission',
            'transmissionMap',
            'thicknessMap',
          ]
        function m(t) {
          let e
          return (e = t && t.isTexture ? t.encoding : t && t.isWebGLRenderTarget ? t.texture.encoding : 3e3), e
        }
        return {
          getParameters: function (r, o, g, f, v) {
            const y = f.fog,
              x = r.isMeshStandardMaterial ? f.environment : null,
              w = (r.isMeshStandardMaterial ? i : e).get(r.envMap || x),
              _ = A[r.type],
              I = v.isSkinnedMesh
                ? (function (t) {
                    const e = t.skeleton.bones
                    if (h) return 1024
                    {
                      const t = u,
                        i = Math.floor((t - 20) / 4),
                        n = Math.min(i, e.length)
                      return n < e.length ? 0 : n
                    }
                  })(v)
                : 0
            let C, M
            if ((null !== r.precision && ((p = s.getMaxPrecision(r.precision)), r.precision), _)) {
              const t = Zi[_]
              ;(C = t.vertexShader), (M = t.fragmentShader)
            } else (C = r.vertexShader), (M = r.fragmentShader)
            const E = t.getRenderTarget()
            return {
              isWebGL2: l,
              shaderID: _,
              shaderName: r.type,
              vertexShader: C,
              fragmentShader: M,
              defines: r.defines,
              isRawShaderMaterial: !0 === r.isRawShaderMaterial,
              glslVersion: r.glslVersion,
              precision: p,
              instancing: !0 === v.isInstancedMesh,
              instancingColor: !0 === v.isInstancedMesh && null !== v.instanceColor,
              supportsVertexTextures: d,
              outputEncoding: null !== E ? m(E.texture) : t.outputEncoding,
              map: !!r.map,
              mapEncoding: m(r.map),
              matcap: !!r.matcap,
              matcapEncoding: m(r.matcap),
              envMap: !!w,
              envMapMode: w && w.mapping,
              envMapEncoding: m(w),
              envMapCubeUV: !!w && (306 === w.mapping || 307 === w.mapping),
              lightMap: !!r.lightMap,
              lightMapEncoding: m(r.lightMap),
              aoMap: !!r.aoMap,
              emissiveMap: !!r.emissiveMap,
              emissiveMapEncoding: m(r.emissiveMap),
              bumpMap: !!r.bumpMap,
              normalMap: !!r.normalMap,
              objectSpaceNormalMap: 1 === r.normalMapType,
              tangentSpaceNormalMap: 0 === r.normalMapType,
              clearcoatMap: !!r.clearcoatMap,
              clearcoatRoughnessMap: !!r.clearcoatRoughnessMap,
              clearcoatNormalMap: !!r.clearcoatNormalMap,
              displacementMap: !!r.displacementMap,
              roughnessMap: !!r.roughnessMap,
              metalnessMap: !!r.metalnessMap,
              specularMap: !!r.specularMap,
              specularIntensityMap: !!r.specularIntensityMap,
              specularTintMap: !!r.specularTintMap,
              specularTintMapEncoding: m(r.specularTintMap),
              alphaMap: !!r.alphaMap,
              gradientMap: !!r.gradientMap,
              sheen: !!r.sheen,
              transmission: !!r.transmission,
              transmissionMap: !!r.transmissionMap,
              thicknessMap: !!r.thicknessMap,
              combine: r.combine,
              vertexTangents: !!r.normalMap && !!v.geometry && !!v.geometry.attributes.tangent,
              vertexColors: r.vertexColors,
              vertexAlphas:
                !0 === r.vertexColors &&
                !!v.geometry &&
                !!v.geometry.attributes.color &&
                4 === v.geometry.attributes.color.itemSize,
              vertexUvs: !!(
                r.map ||
                r.bumpMap ||
                r.normalMap ||
                r.specularMap ||
                r.alphaMap ||
                r.emissiveMap ||
                r.roughnessMap ||
                r.metalnessMap ||
                r.clearcoatMap ||
                r.clearcoatRoughnessMap ||
                r.clearcoatNormalMap ||
                r.displacementMap ||
                r.transmissionMap ||
                r.thicknessMap ||
                r.specularIntensityMap ||
                r.specularTintMap
              ),
              uvsVertexOnly: !(
                r.map ||
                r.bumpMap ||
                r.normalMap ||
                r.specularMap ||
                r.alphaMap ||
                r.emissiveMap ||
                r.roughnessMap ||
                r.metalnessMap ||
                r.clearcoatNormalMap ||
                r.transmission ||
                r.transmissionMap ||
                r.thicknessMap ||
                r.specularIntensityMap ||
                r.specularTintMap ||
                !r.displacementMap
              ),
              fog: !!y,
              useFog: r.fog,
              fogExp2: y && y.isFogExp2,
              flatShading: !!r.flatShading,
              sizeAttenuation: r.sizeAttenuation,
              logarithmicDepthBuffer: c,
              skinning: !0 === v.isSkinnedMesh && I > 0,
              maxBones: I,
              useVertexTexture: h,
              morphTargets: !!v.geometry && !!v.geometry.morphAttributes.position,
              morphNormals: !!v.geometry && !!v.geometry.morphAttributes.normal,
              numDirLights: o.directional.length,
              numPointLights: o.point.length,
              numSpotLights: o.spot.length,
              numRectAreaLights: o.rectArea.length,
              numHemiLights: o.hemi.length,
              numDirLightShadows: o.directionalShadowMap.length,
              numPointLightShadows: o.pointShadowMap.length,
              numSpotLightShadows: o.spotShadowMap.length,
              numClippingPlanes: a.numPlanes,
              numClipIntersection: a.numIntersection,
              dithering: r.dithering,
              shadowMapEnabled: t.shadowMap.enabled && g.length > 0,
              shadowMapType: t.shadowMap.type,
              toneMapping: r.toneMapped ? t.toneMapping : 0,
              physicallyCorrectLights: t.physicallyCorrectLights,
              premultipliedAlpha: r.premultipliedAlpha,
              alphaTest: r.alphaTest,
              doubleSided: 2 === r.side,
              flipSided: 1 === r.side,
              depthPacking: void 0 !== r.depthPacking && r.depthPacking,
              index0AttributeName: r.index0AttributeName,
              extensionDerivatives: r.extensions && r.extensions.derivatives,
              extensionFragDepth: r.extensions && r.extensions.fragDepth,
              extensionDrawBuffers: r.extensions && r.extensions.drawBuffers,
              extensionShaderTextureLOD: r.extensions && r.extensions.shaderTextureLOD,
              rendererExtensionFragDepth: l || n.has('EXT_frag_depth'),
              rendererExtensionDrawBuffers: l || n.has('WEBGL_draw_buffers'),
              rendererExtensionShaderTextureLod: l || n.has('EXT_shader_texture_lod'),
              customProgramCacheKey: r.customProgramCacheKey(),
            }
          },
          getProgramCacheKey: function (e) {
            const i = []
            if (
              (e.shaderID ? i.push(e.shaderID) : (i.push(e.fragmentShader), i.push(e.vertexShader)),
              void 0 !== e.defines)
            )
              for (const t in e.defines) i.push(t), i.push(e.defines[t])
            if (!1 === e.isRawShaderMaterial) {
              for (let t = 0; t < g.length; t++) i.push(e[g[t]])
              i.push(t.outputEncoding), i.push(t.gammaFactor)
            }
            return i.push(e.customProgramCacheKey), i.join()
          },
          getUniforms: function (t) {
            const e = A[t.type]
            let i
            if (e) {
              const t = Zi[e]
              i = Qi.clone(t.uniforms)
            } else i = t.uniforms
            return i
          },
          acquireProgram: function (e, i) {
            let n
            for (let t = 0, s = o.length; t < s; t++) {
              const e = o[t]
              if (e.cacheKey === i) {
                ;(n = e), ++n.usedTimes
                break
              }
            }
            return void 0 === n && ((n = new lr(t, i, e, r)), o.push(n)), n
          },
          releaseProgram: function (t) {
            if (0 == --t.usedTimes) {
              const e = o.indexOf(t)
              ;(o[e] = o[o.length - 1]), o.pop(), t.destroy()
            }
          },
          programs: o,
        }
      }
      function hr() {
        let t = new WeakMap()
        return {
          get: function (e) {
            let i = t.get(e)
            return void 0 === i && ((i = {}), t.set(e, i)), i
          },
          remove: function (e) {
            t.delete(e)
          },
          update: function (e, i, n) {
            t.get(e)[i] = n
          },
          dispose: function () {
            t = new WeakMap()
          },
        }
      }
      function ur(t, e) {
        return t.groupOrder !== e.groupOrder
          ? t.groupOrder - e.groupOrder
          : t.renderOrder !== e.renderOrder
          ? t.renderOrder - e.renderOrder
          : t.program !== e.program
          ? t.program.id - e.program.id
          : t.material.id !== e.material.id
          ? t.material.id - e.material.id
          : t.z !== e.z
          ? t.z - e.z
          : t.id - e.id
      }
      function dr(t, e) {
        return t.groupOrder !== e.groupOrder
          ? t.groupOrder - e.groupOrder
          : t.renderOrder !== e.renderOrder
          ? t.renderOrder - e.renderOrder
          : t.z !== e.z
          ? e.z - t.z
          : t.id - e.id
      }
      function pr(t) {
        const e = []
        let i = 0
        const n = [],
          s = [],
          r = [],
          a = { id: -1 }
        function o(n, s, r, o, l, c) {
          let h = e[i]
          const u = t.get(r)
          return (
            void 0 === h
              ? ((h = {
                  id: n.id,
                  object: n,
                  geometry: s,
                  material: r,
                  program: u.program || a,
                  groupOrder: o,
                  renderOrder: n.renderOrder,
                  z: l,
                  group: c,
                }),
                (e[i] = h))
              : ((h.id = n.id),
                (h.object = n),
                (h.geometry = s),
                (h.material = r),
                (h.program = u.program || a),
                (h.groupOrder = o),
                (h.renderOrder = n.renderOrder),
                (h.z = l),
                (h.group = c)),
            i++,
            h
          )
        }
        return {
          opaque: n,
          transmissive: s,
          transparent: r,
          init: function () {
            ;(i = 0), (n.length = 0), (s.length = 0), (r.length = 0)
          },
          push: function (t, e, i, a, l, c) {
            const h = o(t, e, i, a, l, c)
            i.transmission > 0 ? s.push(h) : !0 === i.transparent ? r.push(h) : n.push(h)
          },
          unshift: function (t, e, i, a, l, c) {
            const h = o(t, e, i, a, l, c)
            i.transmission > 0 ? s.unshift(h) : !0 === i.transparent ? r.unshift(h) : n.unshift(h)
          },
          finish: function () {
            for (let t = i, n = e.length; t < n; t++) {
              const i = e[t]
              if (null === i.id) break
              ;(i.id = null),
                (i.object = null),
                (i.geometry = null),
                (i.material = null),
                (i.program = null),
                (i.group = null)
            }
          },
          sort: function (t, e) {
            n.length > 1 && n.sort(t || ur), s.length > 1 && s.sort(e || dr), r.length > 1 && r.sort(e || dr)
          },
        }
      }
      function Ar(t) {
        let e = new WeakMap()
        return {
          get: function (i, n) {
            let s
            return (
              !1 === e.has(i)
                ? ((s = new pr(t)), e.set(i, [s]))
                : n >= e.get(i).length
                ? ((s = new pr(t)), e.get(i).push(s))
                : (s = e.get(i)[n]),
              s
            )
          },
          dispose: function () {
            e = new WeakMap()
          },
        }
      }
      function gr() {
        const t = {}
        return {
          get: function (e) {
            if (void 0 !== t[e.id]) return t[e.id]
            let i
            switch (e.type) {
              case 'DirectionalLight':
                i = { direction: new Et(), color: new Ye() }
                break
              case 'SpotLight':
                i = {
                  position: new Et(),
                  direction: new Et(),
                  color: new Ye(),
                  distance: 0,
                  coneCos: 0,
                  penumbraCos: 0,
                  decay: 0,
                }
                break
              case 'PointLight':
                i = { position: new Et(), color: new Ye(), distance: 0, decay: 0 }
                break
              case 'HemisphereLight':
                i = { direction: new Et(), skyColor: new Ye(), groundColor: new Ye() }
                break
              case 'RectAreaLight':
                i = { color: new Ye(), position: new Et(), halfWidth: new Et(), halfHeight: new Et() }
            }
            return (t[e.id] = i), i
          },
        }
      }
      let mr = 0
      function fr(t, e) {
        return (e.castShadow ? 1 : 0) - (t.castShadow ? 1 : 0)
      }
      function vr(t, e) {
        const i = new gr(),
          n = (function () {
            const t = {}
            return {
              get: function (e) {
                if (void 0 !== t[e.id]) return t[e.id]
                let i
                switch (e.type) {
                  case 'DirectionalLight':
                  case 'SpotLight':
                    i = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new gt() }
                    break
                  case 'PointLight':
                    i = {
                      shadowBias: 0,
                      shadowNormalBias: 0,
                      shadowRadius: 1,
                      shadowMapSize: new gt(),
                      shadowCameraNear: 1,
                      shadowCameraFar: 1e3,
                    }
                }
                return (t[e.id] = i), i
              },
            }
          })(),
          s = {
            version: 0,
            hash: {
              directionalLength: -1,
              pointLength: -1,
              spotLength: -1,
              rectAreaLength: -1,
              hemiLength: -1,
              numDirectionalShadows: -1,
              numPointShadows: -1,
              numSpotShadows: -1,
            },
            ambient: [0, 0, 0],
            probe: [],
            directional: [],
            directionalShadow: [],
            directionalShadowMap: [],
            directionalShadowMatrix: [],
            spot: [],
            spotShadow: [],
            spotShadowMap: [],
            spotShadowMatrix: [],
            rectArea: [],
            rectAreaLTC1: null,
            rectAreaLTC2: null,
            point: [],
            pointShadow: [],
            pointShadowMap: [],
            pointShadowMatrix: [],
            hemi: [],
          }
        for (let l = 0; l < 9; l++) s.probe.push(new Et())
        const r = new Et(),
          a = new ne(),
          o = new ne()
        return {
          setup: function (r) {
            let a = 0,
              o = 0,
              l = 0
            for (let t = 0; t < 9; t++) s.probe[t].set(0, 0, 0)
            let c = 0,
              h = 0,
              u = 0,
              d = 0,
              p = 0,
              A = 0,
              g = 0,
              m = 0
            r.sort(fr)
            for (let t = 0, e = r.length; t < e; t++) {
              const e = r[t],
                f = e.color,
                v = e.intensity,
                y = e.distance,
                x = e.shadow && e.shadow.map ? e.shadow.map.texture : null
              if (e.isAmbientLight) (a += f.r * v), (o += f.g * v), (l += f.b * v)
              else if (e.isLightProbe) for (let t = 0; t < 9; t++) s.probe[t].addScaledVector(e.sh.coefficients[t], v)
              else if (e.isDirectionalLight) {
                const t = i.get(e)
                if ((t.color.copy(e.color).multiplyScalar(e.intensity), e.castShadow)) {
                  const t = e.shadow,
                    i = n.get(e)
                  ;(i.shadowBias = t.bias),
                    (i.shadowNormalBias = t.normalBias),
                    (i.shadowRadius = t.radius),
                    (i.shadowMapSize = t.mapSize),
                    (s.directionalShadow[c] = i),
                    (s.directionalShadowMap[c] = x),
                    (s.directionalShadowMatrix[c] = e.shadow.matrix),
                    A++
                }
                ;(s.directional[c] = t), c++
              } else if (e.isSpotLight) {
                const t = i.get(e)
                if (
                  (t.position.setFromMatrixPosition(e.matrixWorld),
                  t.color.copy(f).multiplyScalar(v),
                  (t.distance = y),
                  (t.coneCos = Math.cos(e.angle)),
                  (t.penumbraCos = Math.cos(e.angle * (1 - e.penumbra))),
                  (t.decay = e.decay),
                  e.castShadow)
                ) {
                  const t = e.shadow,
                    i = n.get(e)
                  ;(i.shadowBias = t.bias),
                    (i.shadowNormalBias = t.normalBias),
                    (i.shadowRadius = t.radius),
                    (i.shadowMapSize = t.mapSize),
                    (s.spotShadow[u] = i),
                    (s.spotShadowMap[u] = x),
                    (s.spotShadowMatrix[u] = e.shadow.matrix),
                    m++
                }
                ;(s.spot[u] = t), u++
              } else if (e.isRectAreaLight) {
                const t = i.get(e)
                t.color.copy(f).multiplyScalar(v),
                  t.halfWidth.set(0.5 * e.width, 0, 0),
                  t.halfHeight.set(0, 0.5 * e.height, 0),
                  (s.rectArea[d] = t),
                  d++
              } else if (e.isPointLight) {
                const t = i.get(e)
                if (
                  (t.color.copy(e.color).multiplyScalar(e.intensity),
                  (t.distance = e.distance),
                  (t.decay = e.decay),
                  e.castShadow)
                ) {
                  const t = e.shadow,
                    i = n.get(e)
                  ;(i.shadowBias = t.bias),
                    (i.shadowNormalBias = t.normalBias),
                    (i.shadowRadius = t.radius),
                    (i.shadowMapSize = t.mapSize),
                    (i.shadowCameraNear = t.camera.near),
                    (i.shadowCameraFar = t.camera.far),
                    (s.pointShadow[h] = i),
                    (s.pointShadowMap[h] = x),
                    (s.pointShadowMatrix[h] = e.shadow.matrix),
                    g++
                }
                ;(s.point[h] = t), h++
              } else if (e.isHemisphereLight) {
                const t = i.get(e)
                t.skyColor.copy(e.color).multiplyScalar(v),
                  t.groundColor.copy(e.groundColor).multiplyScalar(v),
                  (s.hemi[p] = t),
                  p++
              }
            }
            d > 0 &&
              (e.isWebGL2 || !0 === t.has('OES_texture_float_linear')
                ? ((s.rectAreaLTC1 = Ki.LTC_FLOAT_1), (s.rectAreaLTC2 = Ki.LTC_FLOAT_2))
                : !0 === t.has('OES_texture_half_float_linear') &&
                  ((s.rectAreaLTC1 = Ki.LTC_HALF_1), (s.rectAreaLTC2 = Ki.LTC_HALF_2))),
              (s.ambient[0] = a),
              (s.ambient[1] = o),
              (s.ambient[2] = l)
            const f = s.hash
            ;(f.directionalLength === c &&
              f.pointLength === h &&
              f.spotLength === u &&
              f.rectAreaLength === d &&
              f.hemiLength === p &&
              f.numDirectionalShadows === A &&
              f.numPointShadows === g &&
              f.numSpotShadows === m) ||
              ((s.directional.length = c),
              (s.spot.length = u),
              (s.rectArea.length = d),
              (s.point.length = h),
              (s.hemi.length = p),
              (s.directionalShadow.length = A),
              (s.directionalShadowMap.length = A),
              (s.pointShadow.length = g),
              (s.pointShadowMap.length = g),
              (s.spotShadow.length = m),
              (s.spotShadowMap.length = m),
              (s.directionalShadowMatrix.length = A),
              (s.pointShadowMatrix.length = g),
              (s.spotShadowMatrix.length = m),
              (f.directionalLength = c),
              (f.pointLength = h),
              (f.spotLength = u),
              (f.rectAreaLength = d),
              (f.hemiLength = p),
              (f.numDirectionalShadows = A),
              (f.numPointShadows = g),
              (f.numSpotShadows = m),
              (s.version = mr++))
          },
          setupView: function (t, e) {
            let i = 0,
              n = 0,
              l = 0,
              c = 0,
              h = 0
            const u = e.matrixWorldInverse
            for (let d = 0, p = t.length; d < p; d++) {
              const e = t[d]
              if (e.isDirectionalLight) {
                const t = s.directional[i]
                t.direction.setFromMatrixPosition(e.matrixWorld),
                  r.setFromMatrixPosition(e.target.matrixWorld),
                  t.direction.sub(r),
                  t.direction.transformDirection(u),
                  i++
              } else if (e.isSpotLight) {
                const t = s.spot[l]
                t.position.setFromMatrixPosition(e.matrixWorld),
                  t.position.applyMatrix4(u),
                  t.direction.setFromMatrixPosition(e.matrixWorld),
                  r.setFromMatrixPosition(e.target.matrixWorld),
                  t.direction.sub(r),
                  t.direction.transformDirection(u),
                  l++
              } else if (e.isRectAreaLight) {
                const t = s.rectArea[c]
                t.position.setFromMatrixPosition(e.matrixWorld),
                  t.position.applyMatrix4(u),
                  o.identity(),
                  a.copy(e.matrixWorld),
                  a.premultiply(u),
                  o.extractRotation(a),
                  t.halfWidth.set(0.5 * e.width, 0, 0),
                  t.halfHeight.set(0, 0.5 * e.height, 0),
                  t.halfWidth.applyMatrix4(o),
                  t.halfHeight.applyMatrix4(o),
                  c++
              } else if (e.isPointLight) {
                const t = s.point[n]
                t.position.setFromMatrixPosition(e.matrixWorld), t.position.applyMatrix4(u), n++
              } else if (e.isHemisphereLight) {
                const t = s.hemi[h]
                t.direction.setFromMatrixPosition(e.matrixWorld),
                  t.direction.transformDirection(u),
                  t.direction.normalize(),
                  h++
              }
            }
          },
          state: s,
        }
      }
      function yr(t, e) {
        const i = new vr(t, e),
          n = [],
          s = []
        return {
          init: function () {
            ;(n.length = 0), (s.length = 0)
          },
          state: { lightsArray: n, shadowsArray: s, lights: i },
          setupLights: function () {
            i.setup(n)
          },
          setupLightsView: function (t) {
            i.setupView(n, t)
          },
          pushLight: function (t) {
            n.push(t)
          },
          pushShadow: function (t) {
            s.push(t)
          },
        }
      }
      function xr(t, e) {
        let i = new WeakMap()
        return {
          get: function (n, s = 0) {
            let r
            return (
              !1 === i.has(n)
                ? ((r = new yr(t, e)), i.set(n, [r]))
                : s >= i.get(n).length
                ? ((r = new yr(t, e)), i.get(n).push(r))
                : (r = i.get(n)[s]),
              r
            )
          },
          dispose: function () {
            i = new WeakMap()
          },
        }
      }
      class wr extends Ge {
        constructor(t) {
          super(),
            (this.type = 'MeshDepthMaterial'),
            (this.depthPacking = 3200),
            (this.map = null),
            (this.alphaMap = null),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.fog = !1),
            this.setValues(t)
        }
        copy(t) {
          return (
            super.copy(t),
            (this.depthPacking = t.depthPacking),
            (this.map = t.map),
            (this.alphaMap = t.alphaMap),
            (this.displacementMap = t.displacementMap),
            (this.displacementScale = t.displacementScale),
            (this.displacementBias = t.displacementBias),
            (this.wireframe = t.wireframe),
            (this.wireframeLinewidth = t.wireframeLinewidth),
            this
          )
        }
      }
      wr.prototype.isMeshDepthMaterial = !0
      class _r extends Ge {
        constructor(t) {
          super(),
            (this.type = 'MeshDistanceMaterial'),
            (this.referencePosition = new Et()),
            (this.nearDistance = 1),
            (this.farDistance = 1e3),
            (this.map = null),
            (this.alphaMap = null),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.fog = !1),
            this.setValues(t)
        }
        copy(t) {
          return (
            super.copy(t),
            this.referencePosition.copy(t.referencePosition),
            (this.nearDistance = t.nearDistance),
            (this.farDistance = t.farDistance),
            (this.map = t.map),
            (this.alphaMap = t.alphaMap),
            (this.displacementMap = t.displacementMap),
            (this.displacementScale = t.displacementScale),
            (this.displacementBias = t.displacementBias),
            this
          )
        }
      }
      function Ir(t, e, i) {
        let n = new qi()
        const s = new gt(),
          r = new gt(),
          a = new _t(),
          o = new wr({ depthPacking: 3201 }),
          l = new _r(),
          c = {},
          h = i.maxTextureSize,
          u = { 0: 1, 1: 0, 2: 2 },
          d = new Ri({
            defines: { SAMPLE_RATE: 2 / 8, HALF_SAMPLE_RATE: 1 / 8 },
            uniforms: { shadow_pass: { value: null }, resolution: { value: new gt() }, radius: { value: 4 } },
            vertexShader: 'void main() {\n\tgl_Position = vec4( position, 1.0 );\n}',
            fragmentShader:
              'uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n\tfor ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean * HALF_SAMPLE_RATE;\n\tsquared_mean = squared_mean * HALF_SAMPLE_RATE;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}',
          }),
          p = d.clone()
        p.defines.HORIZONTAL_PASS = 1
        const A = new hi()
        A.setAttribute('position', new Ze(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3))
        const g = new Si(A, d),
          m = this
        function f(i, n) {
          const s = e.update(g)
          ;(d.uniforms.shadow_pass.value = i.map.texture),
            (d.uniforms.resolution.value = i.mapSize),
            (d.uniforms.radius.value = i.radius),
            t.setRenderTarget(i.mapPass),
            t.clear(),
            t.renderBufferDirect(n, null, s, d, g, null),
            (p.uniforms.shadow_pass.value = i.mapPass.texture),
            (p.uniforms.resolution.value = i.mapSize),
            (p.uniforms.radius.value = i.radius),
            t.setRenderTarget(i.map),
            t.clear(),
            t.renderBufferDirect(n, null, s, p, g, null)
        }
        function v(e, i, n, s, r, a, h) {
          let d = null
          const p = !0 === s.isPointLight ? e.customDistanceMaterial : e.customDepthMaterial
          if (
            ((d = void 0 !== p ? p : !0 === s.isPointLight ? l : o),
            t.localClippingEnabled && !0 === n.clipShadows && 0 !== n.clippingPlanes.length)
          ) {
            const t = d.uuid,
              e = n.uuid
            let i = c[t]
            void 0 === i && ((i = {}), (c[t] = i))
            let s = i[e]
            void 0 === s && ((s = d.clone()), (i[e] = s)), (d = s)
          }
          return (
            (d.visible = n.visible),
            (d.wireframe = n.wireframe),
            (d.side =
              3 === h
                ? null !== n.shadowSide
                  ? n.shadowSide
                  : n.side
                : null !== n.shadowSide
                ? n.shadowSide
                : u[n.side]),
            (d.clipShadows = n.clipShadows),
            (d.clippingPlanes = n.clippingPlanes),
            (d.clipIntersection = n.clipIntersection),
            (d.wireframeLinewidth = n.wireframeLinewidth),
            (d.linewidth = n.linewidth),
            !0 === s.isPointLight &&
              !0 === d.isMeshDistanceMaterial &&
              (d.referencePosition.setFromMatrixPosition(s.matrixWorld), (d.nearDistance = r), (d.farDistance = a)),
            d
          )
        }
        function y(i, s, r, a, o) {
          if (!1 === i.visible) return
          if (
            i.layers.test(s.layers) &&
            (i.isMesh || i.isLine || i.isPoints) &&
            (i.castShadow || (i.receiveShadow && 3 === o)) &&
            (!i.frustumCulled || n.intersectsObject(i))
          ) {
            i.modelViewMatrix.multiplyMatrices(r.matrixWorldInverse, i.matrixWorld)
            const n = e.update(i),
              s = i.material
            if (Array.isArray(s)) {
              const e = n.groups
              for (let l = 0, c = e.length; l < c; l++) {
                const c = e[l],
                  h = s[c.materialIndex]
                if (h && h.visible) {
                  const e = v(i, 0, h, a, r.near, r.far, o)
                  t.renderBufferDirect(r, null, n, e, i, c)
                }
              }
            } else if (s.visible) {
              const e = v(i, 0, s, a, r.near, r.far, o)
              t.renderBufferDirect(r, null, n, e, i, null)
            }
          }
          const l = i.children
          for (let t = 0, e = l.length; t < e; t++) y(l[t], s, r, a, o)
        }
        ;(this.enabled = !1),
          (this.autoUpdate = !0),
          (this.needsUpdate = !1),
          (this.type = 1),
          (this.render = function (e, i, o) {
            if (!1 === m.enabled) return
            if (!1 === m.autoUpdate && !1 === m.needsUpdate) return
            if (0 === e.length) return
            const l = t.getRenderTarget(),
              c = t.getActiveCubeFace(),
              u = t.getActiveMipmapLevel(),
              d = t.state
            d.setBlending(0), d.buffers.color.setClear(1, 1, 1, 1), d.buffers.depth.setTest(!0), d.setScissorTest(!1)
            for (let p = 0, A = e.length; p < A; p++) {
              const l = e[p],
                c = l.shadow
              if (void 0 === c) continue
              if (!1 === c.autoUpdate && !1 === c.needsUpdate) continue
              s.copy(c.mapSize)
              const u = c.getFrameExtents()
              if (
                (s.multiply(u),
                r.copy(c.mapSize),
                (s.x > h || s.y > h) &&
                  (s.x > h && ((r.x = Math.floor(h / u.x)), (s.x = r.x * u.x), (c.mapSize.x = r.x)),
                  s.y > h && ((r.y = Math.floor(h / u.y)), (s.y = r.y * u.y), (c.mapSize.y = r.y))),
                null === c.map && !c.isPointLightShadow && 3 === this.type)
              ) {
                const t = { minFilter: 1006, magFilter: 1006, format: 1023 }
                ;(c.map = new It(s.x, s.y, t)),
                  (c.map.texture.name = l.name + '.shadowMap'),
                  (c.mapPass = new It(s.x, s.y, t)),
                  c.camera.updateProjectionMatrix()
              }
              if (null === c.map) {
                const t = { minFilter: 1003, magFilter: 1003, format: 1023 }
                ;(c.map = new It(s.x, s.y, t)),
                  (c.map.texture.name = l.name + '.shadowMap'),
                  c.camera.updateProjectionMatrix()
              }
              t.setRenderTarget(c.map), t.clear()
              const A = c.getViewportCount()
              for (let t = 0; t < A; t++) {
                const e = c.getViewport(t)
                a.set(r.x * e.x, r.y * e.y, r.x * e.z, r.y * e.w),
                  d.viewport(a),
                  c.updateMatrices(l, t),
                  (n = c.getFrustum()),
                  y(i, o, c.camera, l, this.type)
              }
              c.isPointLightShadow || 3 !== this.type || f(c, o), (c.needsUpdate = !1)
            }
            ;(m.needsUpdate = !1), t.setRenderTarget(l, c, u)
          })
      }
      function Cr(t, e, i) {
        const n = i.isWebGL2,
          s = new (function () {
            let e = !1
            const i = new _t()
            let n = null
            const s = new _t(0, 0, 0, 0)
            return {
              setMask: function (i) {
                n === i || e || (t.colorMask(i, i, i, i), (n = i))
              },
              setLocked: function (t) {
                e = t
              },
              setClear: function (e, n, r, a, o) {
                !0 === o && ((e *= a), (n *= a), (r *= a)),
                  i.set(e, n, r, a),
                  !1 === s.equals(i) && (t.clearColor(e, n, r, a), s.copy(i))
              },
              reset: function () {
                ;(e = !1), (n = null), s.set(-1, 0, 0, 0)
              },
            }
          })(),
          r = new (function () {
            let e = !1,
              i = null,
              n = null,
              s = null
            return {
              setTest: function (t) {
                t ? F(2929) : U(2929)
              },
              setMask: function (n) {
                i === n || e || (t.depthMask(n), (i = n))
              },
              setFunc: function (e) {
                if (n !== e) {
                  if (e)
                    switch (e) {
                      case 0:
                        t.depthFunc(512)
                        break
                      case 1:
                        t.depthFunc(519)
                        break
                      case 2:
                        t.depthFunc(513)
                        break
                      case 3:
                        t.depthFunc(515)
                        break
                      case 4:
                        t.depthFunc(514)
                        break
                      case 5:
                        t.depthFunc(518)
                        break
                      case 6:
                        t.depthFunc(516)
                        break
                      case 7:
                        t.depthFunc(517)
                        break
                      default:
                        t.depthFunc(515)
                    }
                  else t.depthFunc(515)
                  n = e
                }
              },
              setLocked: function (t) {
                e = t
              },
              setClear: function (e) {
                s !== e && (t.clearDepth(e), (s = e))
              },
              reset: function () {
                ;(e = !1), (i = null), (n = null), (s = null)
              },
            }
          })(),
          a = new (function () {
            let e = !1,
              i = null,
              n = null,
              s = null,
              r = null,
              a = null,
              o = null,
              l = null,
              c = null
            return {
              setTest: function (t) {
                e || (t ? F(2960) : U(2960))
              },
              setMask: function (n) {
                i === n || e || (t.stencilMask(n), (i = n))
              },
              setFunc: function (e, i, a) {
                ;(n === e && s === i && r === a) || (t.stencilFunc(e, i, a), (n = e), (s = i), (r = a))
              },
              setOp: function (e, i, n) {
                ;(a === e && o === i && l === n) || (t.stencilOp(e, i, n), (a = e), (o = i), (l = n))
              },
              setLocked: function (t) {
                e = t
              },
              setClear: function (e) {
                c !== e && (t.clearStencil(e), (c = e))
              },
              reset: function () {
                ;(e = !1),
                  (i = null),
                  (n = null),
                  (s = null),
                  (r = null),
                  (a = null),
                  (o = null),
                  (l = null),
                  (c = null)
              },
            }
          })()
        let o = {},
          l = null,
          c = {},
          h = null,
          u = !1,
          d = null,
          p = null,
          A = null,
          g = null,
          m = null,
          f = null,
          v = null,
          y = !1,
          x = null,
          w = null,
          _ = null,
          I = null,
          C = null
        const M = t.getParameter(35661)
        let E = !1,
          b = 0
        const S = t.getParameter(7938)
        ;-1 !== S.indexOf('WebGL')
          ? ((b = parseFloat(/^WebGL (\d)/.exec(S)[1])), (E = b >= 1))
          : -1 !== S.indexOf('OpenGL ES') && ((b = parseFloat(/^OpenGL ES (\d)/.exec(S)[1])), (E = b >= 2))
        let B = null,
          T = {}
        const L = t.getParameter(3088),
          D = t.getParameter(2978),
          Q = new _t().fromArray(L),
          R = new _t().fromArray(D)
        function P(e, i, n) {
          const s = new Uint8Array(4),
            r = t.createTexture()
          t.bindTexture(e, r), t.texParameteri(e, 10241, 9728), t.texParameteri(e, 10240, 9728)
          for (let a = 0; a < n; a++) t.texImage2D(i + a, 0, 6408, 1, 1, 0, 6408, 5121, s)
          return r
        }
        const N = {}
        function F(e) {
          !0 !== o[e] && (t.enable(e), (o[e] = !0))
        }
        function U(e) {
          !1 !== o[e] && (t.disable(e), (o[e] = !1))
        }
        ;(N[3553] = P(3553, 3553, 1)),
          (N[34067] = P(34067, 34069, 6)),
          s.setClear(0, 0, 0, 1),
          r.setClear(1),
          a.setClear(0),
          F(2929),
          r.setFunc(3),
          z(!1),
          V(1),
          F(2884),
          G(0)
        const k = { 100: 32774, 101: 32778, 102: 32779 }
        if (n) (k[103] = 32775), (k[104] = 32776)
        else {
          const t = e.get('EXT_blend_minmax')
          null !== t && ((k[103] = t.MIN_EXT), (k[104] = t.MAX_EXT))
        }
        const O = {
          200: 0,
          201: 1,
          202: 768,
          204: 770,
          210: 776,
          208: 774,
          206: 772,
          203: 769,
          205: 771,
          209: 775,
          207: 773,
        }
        function G(e, i, n, s, r, a, o, l) {
          if (0 !== e) {
            if ((!1 === u && (F(3042), (u = !0)), 5 === e))
              (r = r || i),
                (a = a || n),
                (o = o || s),
                (i === p && r === m) || (t.blendEquationSeparate(k[i], k[r]), (p = i), (m = r)),
                (n === A && s === g && a === f && o === v) ||
                  (t.blendFuncSeparate(O[n], O[s], O[a], O[o]), (A = n), (g = s), (f = a), (v = o)),
                (d = e),
                (y = null)
            else if (e !== d || l !== y) {
              if (((100 === p && 100 === m) || (t.blendEquation(32774), (p = 100), (m = 100)), l))
                switch (e) {
                  case 1:
                    t.blendFuncSeparate(1, 771, 1, 771)
                    break
                  case 2:
                    t.blendFunc(1, 1)
                    break
                  case 3:
                    t.blendFuncSeparate(0, 0, 769, 771)
                    break
                  case 4:
                    t.blendFuncSeparate(0, 768, 0, 770)
                }
              else
                switch (e) {
                  case 1:
                    t.blendFuncSeparate(770, 771, 1, 771)
                    break
                  case 2:
                    t.blendFunc(770, 1)
                    break
                  case 3:
                    t.blendFunc(0, 769)
                    break
                  case 4:
                    t.blendFunc(0, 768)
                }
              ;(A = null), (g = null), (f = null), (v = null), (d = e), (y = l)
            }
          } else !0 === u && (U(3042), (u = !1))
        }
        function z(e) {
          x !== e && (e ? t.frontFace(2304) : t.frontFace(2305), (x = e))
        }
        function V(e) {
          0 !== e
            ? (F(2884), e !== w && (1 === e ? t.cullFace(1029) : 2 === e ? t.cullFace(1028) : t.cullFace(1032)))
            : U(2884),
            (w = e)
        }
        function H(e, i, n) {
          e ? (F(32823), (I === i && C === n) || (t.polygonOffset(i, n), (I = i), (C = n))) : U(32823)
        }
        function W(e) {
          void 0 === e && (e = 33984 + M - 1), B !== e && (t.activeTexture(e), (B = e))
        }
        return {
          buffers: { color: s, depth: r, stencil: a },
          enable: F,
          disable: U,
          bindFramebuffer: function (e, i) {
            return (
              null === i && null !== l && (i = l),
              c[e] !== i &&
                (t.bindFramebuffer(e, i),
                (c[e] = i),
                n && (36009 === e && (c[36160] = i), 36160 === e && (c[36009] = i)),
                !0)
            )
          },
          bindXRFramebuffer: function (e) {
            e !== l && (t.bindFramebuffer(36160, e), (l = e))
          },
          useProgram: function (e) {
            return h !== e && (t.useProgram(e), (h = e), !0)
          },
          setBlending: G,
          setMaterial: function (t, e) {
            2 === t.side ? U(2884) : F(2884)
            let i = 1 === t.side
            e && (i = !i),
              z(i),
              1 === t.blending && !1 === t.transparent
                ? G(0)
                : G(
                    t.blending,
                    t.blendEquation,
                    t.blendSrc,
                    t.blendDst,
                    t.blendEquationAlpha,
                    t.blendSrcAlpha,
                    t.blendDstAlpha,
                    t.premultipliedAlpha,
                  ),
              r.setFunc(t.depthFunc),
              r.setTest(t.depthTest),
              r.setMask(t.depthWrite),
              s.setMask(t.colorWrite)
            const n = t.stencilWrite
            a.setTest(n),
              n &&
                (a.setMask(t.stencilWriteMask),
                a.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask),
                a.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)),
              H(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits),
              !0 === t.alphaToCoverage ? F(32926) : U(32926)
          },
          setFlipSided: z,
          setCullFace: V,
          setLineWidth: function (e) {
            e !== _ && (E && t.lineWidth(e), (_ = e))
          },
          setPolygonOffset: H,
          setScissorTest: function (t) {
            t ? F(3089) : U(3089)
          },
          activeTexture: W,
          bindTexture: function (e, i) {
            null === B && W()
            let n = T[B]
            void 0 === n && ((n = { type: void 0, texture: void 0 }), (T[B] = n)),
              (n.type === e && n.texture === i) || (t.bindTexture(e, i || N[e]), (n.type = e), (n.texture = i))
          },
          unbindTexture: function () {
            const e = T[B]
            void 0 !== e && void 0 !== e.type && (t.bindTexture(e.type, null), (e.type = void 0), (e.texture = void 0))
          },
          compressedTexImage2D: function () {
            try {
              t.compressedTexImage2D.apply(t, arguments)
            } catch (t) {}
          },
          texImage2D: function () {
            try {
              t.texImage2D.apply(t, arguments)
            } catch (t) {}
          },
          texImage3D: function () {
            try {
              t.texImage3D.apply(t, arguments)
            } catch (t) {}
          },
          scissor: function (e) {
            !1 === Q.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), Q.copy(e))
          },
          viewport: function (e) {
            !1 === R.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), R.copy(e))
          },
          reset: function () {
            t.disable(3042),
              t.disable(2884),
              t.disable(2929),
              t.disable(32823),
              t.disable(3089),
              t.disable(2960),
              t.disable(32926),
              t.blendEquation(32774),
              t.blendFunc(1, 0),
              t.blendFuncSeparate(1, 0, 1, 0),
              t.colorMask(!0, !0, !0, !0),
              t.clearColor(0, 0, 0, 0),
              t.depthMask(!0),
              t.depthFunc(513),
              t.clearDepth(1),
              t.stencilMask(4294967295),
              t.stencilFunc(519, 0, 4294967295),
              t.stencilOp(7680, 7680, 7680),
              t.clearStencil(0),
              t.cullFace(1029),
              t.frontFace(2305),
              t.polygonOffset(0, 0),
              t.activeTexture(33984),
              t.bindFramebuffer(36160, null),
              !0 === n && (t.bindFramebuffer(36009, null), t.bindFramebuffer(36008, null)),
              t.useProgram(null),
              t.lineWidth(1),
              t.scissor(0, 0, t.canvas.width, t.canvas.height),
              t.viewport(0, 0, t.canvas.width, t.canvas.height),
              (o = {}),
              (B = null),
              (T = {}),
              (l = null),
              (c = {}),
              (h = null),
              (u = !1),
              (d = null),
              (p = null),
              (A = null),
              (g = null),
              (m = null),
              (f = null),
              (v = null),
              (y = !1),
              (x = null),
              (w = null),
              (_ = null),
              (I = null),
              (C = null),
              Q.set(0, 0, t.canvas.width, t.canvas.height),
              R.set(0, 0, t.canvas.width, t.canvas.height),
              s.reset(),
              r.reset(),
              a.reset()
          },
        }
      }
      function Mr(t, e, i, n, s, r, a) {
        const o = s.isWebGL2,
          l = (s.maxTextures, s.maxCubemapSize),
          c = s.maxTextureSize,
          h = s.maxSamples,
          u = new WeakMap()
        let d,
          p = !1
        try {
          p = 'undefined' != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext('2d')
        } catch (t) {}
        function A(t, e) {
          return p ? new OffscreenCanvas(t, e) : document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas')
        }
        function g(t, e, i, n) {
          let s = 1
          if (((t.width > n || t.height > n) && (s = n / Math.max(t.width, t.height)), s < 1 || !0 === e)) {
            if (
              ('undefined' != typeof HTMLImageElement && t instanceof HTMLImageElement) ||
              ('undefined' != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement) ||
              ('undefined' != typeof ImageBitmap && t instanceof ImageBitmap)
            ) {
              const n = e ? pt : Math.floor,
                r = n(s * t.width),
                a = n(s * t.height)
              void 0 === d && (d = A(r, a))
              const o = i ? A(r, a) : d
              return (o.width = r), (o.height = a), o.getContext('2d').drawImage(t, 0, 0, r, a), o
            }
            return t
          }
          return t
        }
        function m(t) {
          return ut(t.width) && ut(t.height)
        }
        function f(t, e) {
          return t.generateMipmaps && e && 1003 !== t.minFilter && 1006 !== t.minFilter
        }
        function v(e, i, s, r, a = 1) {
          t.generateMipmap(e), (n.get(i).__maxMipLevel = Math.log2(Math.max(s, r, a)))
        }
        function y(i, n, s) {
          if (!1 === o) return n
          if (null !== i && void 0 !== t[i]) return t[i]
          let r = n
          return (
            6403 === n && (5126 === s && (r = 33326), 5131 === s && (r = 33325), 5121 === s && (r = 33321)),
            6407 === n && (5126 === s && (r = 34837), 5131 === s && (r = 34843), 5121 === s && (r = 32849)),
            6408 === n && (5126 === s && (r = 34836), 5131 === s && (r = 34842), 5121 === s && (r = 32856)),
            (33325 !== r && 33326 !== r && 34842 !== r && 34836 !== r) || e.get('EXT_color_buffer_float'),
            r
          )
        }
        function x(t) {
          return 1003 === t || 1004 === t || 1005 === t ? 9728 : 9729
        }
        function w(e) {
          const i = e.target
          i.removeEventListener('dispose', w),
            (function (e) {
              const i = n.get(e)
              void 0 !== i.__webglInit && (t.deleteTexture(i.__webglTexture), n.remove(e))
            })(i),
            i.isVideoTexture && u.delete(i),
            a.memory.textures--
        }
        function _(e) {
          const i = e.target
          i.removeEventListener('dispose', _),
            (function (e) {
              const i = e.texture,
                s = n.get(e),
                r = n.get(i)
              if (e) {
                if (
                  (void 0 !== r.__webglTexture && (t.deleteTexture(r.__webglTexture), a.memory.textures--),
                  e.depthTexture && e.depthTexture.dispose(),
                  e.isWebGLCubeRenderTarget)
                )
                  for (let e = 0; e < 6; e++)
                    t.deleteFramebuffer(s.__webglFramebuffer[e]),
                      s.__webglDepthbuffer && t.deleteRenderbuffer(s.__webglDepthbuffer[e])
                else
                  t.deleteFramebuffer(s.__webglFramebuffer),
                    s.__webglDepthbuffer && t.deleteRenderbuffer(s.__webglDepthbuffer),
                    s.__webglMultisampledFramebuffer && t.deleteFramebuffer(s.__webglMultisampledFramebuffer),
                    s.__webglColorRenderbuffer && t.deleteRenderbuffer(s.__webglColorRenderbuffer),
                    s.__webglDepthRenderbuffer && t.deleteRenderbuffer(s.__webglDepthRenderbuffer)
                if (e.isWebGLMultipleRenderTargets)
                  for (let e = 0, s = i.length; e < s; e++) {
                    const s = n.get(i[e])
                    s.__webglTexture && (t.deleteTexture(s.__webglTexture), a.memory.textures--), n.remove(i[e])
                  }
                n.remove(i), n.remove(e)
              }
            })(i)
        }
        let I = 0
        function C(t, e) {
          const s = n.get(t)
          if (
            (t.isVideoTexture &&
              (function (t) {
                const e = a.render.frame
                u.get(t) !== e && (u.set(t, e), t.update())
              })(t),
            t.version > 0 && s.__version !== t.version)
          ) {
            const i = t.image
            if (void 0 === i);
            else if (!1 !== i.complete) return void T(s, t, e)
          }
          i.activeTexture(33984 + e), i.bindTexture(3553, s.__webglTexture)
        }
        function M(e, s) {
          const a = n.get(e)
          e.version > 0 && a.__version !== e.version
            ? (function (e, n, s) {
                if (6 !== n.image.length) return
                B(e, n),
                  i.activeTexture(33984 + s),
                  i.bindTexture(34067, e.__webglTexture),
                  t.pixelStorei(37440, n.flipY),
                  t.pixelStorei(37441, n.premultiplyAlpha),
                  t.pixelStorei(3317, n.unpackAlignment),
                  t.pixelStorei(37443, 0)
                const a = n && (n.isCompressedTexture || n.image[0].isCompressedTexture),
                  c = n.image[0] && n.image[0].isDataTexture,
                  h = []
                for (let t = 0; t < 6; t++)
                  h[t] = a || c ? (c ? n.image[t].image : n.image[t]) : g(n.image[t], !1, !0, l)
                const u = h[0],
                  d = m(u) || o,
                  p = r.convert(n.format),
                  A = r.convert(n.type),
                  x = y(n.internalFormat, p, A)
                let w
                if ((S(34067, n, d), a)) {
                  for (let t = 0; t < 6; t++) {
                    w = h[t].mipmaps
                    for (let e = 0; e < w.length; e++) {
                      const s = w[e]
                      1023 !== n.format && 1022 !== n.format
                        ? null !== p && i.compressedTexImage2D(34069 + t, e, x, s.width, s.height, 0, s.data)
                        : i.texImage2D(34069 + t, e, x, s.width, s.height, 0, p, A, s.data)
                    }
                  }
                  e.__maxMipLevel = w.length - 1
                } else {
                  w = n.mipmaps
                  for (let t = 0; t < 6; t++)
                    if (c) {
                      i.texImage2D(34069 + t, 0, x, h[t].width, h[t].height, 0, p, A, h[t].data)
                      for (let e = 0; e < w.length; e++) {
                        const n = w[e].image[t].image
                        i.texImage2D(34069 + t, e + 1, x, n.width, n.height, 0, p, A, n.data)
                      }
                    } else {
                      i.texImage2D(34069 + t, 0, x, p, A, h[t])
                      for (let e = 0; e < w.length; e++) {
                        const n = w[e]
                        i.texImage2D(34069 + t, e + 1, x, p, A, n.image[t])
                      }
                    }
                  e.__maxMipLevel = w.length
                }
                f(n, d) && v(34067, n, u.width, u.height), (e.__version = n.version), n.onUpdate && n.onUpdate(n)
              })(a, e, s)
            : (i.activeTexture(33984 + s), i.bindTexture(34067, a.__webglTexture))
        }
        const E = { 1e3: 10497, 1001: 33071, 1002: 33648 },
          b = { 1003: 9728, 1004: 9984, 1005: 9986, 1006: 9729, 1007: 9985, 1008: 9987 }
        function S(i, r, a) {
          if (
            (a
              ? (t.texParameteri(i, 10242, E[r.wrapS]),
                t.texParameteri(i, 10243, E[r.wrapT]),
                (32879 !== i && 35866 !== i) || t.texParameteri(i, 32882, E[r.wrapR]),
                t.texParameteri(i, 10240, b[r.magFilter]),
                t.texParameteri(i, 10241, b[r.minFilter]))
              : (t.texParameteri(i, 10242, 33071),
                t.texParameteri(i, 10243, 33071),
                (32879 !== i && 35866 !== i) || t.texParameteri(i, 32882, 33071),
                1001 === r.wrapS && r.wrapT,
                t.texParameteri(i, 10240, x(r.magFilter)),
                t.texParameteri(i, 10241, x(r.minFilter)),
                1003 !== r.minFilter && r.minFilter),
            !0 === e.has('EXT_texture_filter_anisotropic'))
          ) {
            const a = e.get('EXT_texture_filter_anisotropic')
            if (1015 === r.type && !1 === e.has('OES_texture_float_linear')) return
            if (!1 === o && 1016 === r.type && !1 === e.has('OES_texture_half_float_linear')) return
            ;(r.anisotropy > 1 || n.get(r).__currentAnisotropy) &&
              (t.texParameterf(i, a.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(r.anisotropy, s.getMaxAnisotropy())),
              (n.get(r).__currentAnisotropy = r.anisotropy))
          }
        }
        function B(e, i) {
          void 0 === e.__webglInit &&
            ((e.__webglInit = !0),
            i.addEventListener('dispose', w),
            (e.__webglTexture = t.createTexture()),
            a.memory.textures++)
        }
        function T(e, n, s) {
          let a = 3553
          n.isDataTexture2DArray && (a = 35866),
            n.isDataTexture3D && (a = 32879),
            B(e, n),
            i.activeTexture(33984 + s),
            i.bindTexture(a, e.__webglTexture),
            t.pixelStorei(37440, n.flipY),
            t.pixelStorei(37441, n.premultiplyAlpha),
            t.pixelStorei(3317, n.unpackAlignment),
            t.pixelStorei(37443, 0)
          const l =
              (function (t) {
                return !o && (1001 !== t.wrapS || 1001 !== t.wrapT || (1003 !== t.minFilter && 1006 !== t.minFilter))
              })(n) && !1 === m(n.image),
            h = g(n.image, l, !1, c),
            u = m(h) || o,
            d = r.convert(n.format)
          let p,
            A = r.convert(n.type),
            x = y(n.internalFormat, d, A)
          S(a, n, u)
          const w = n.mipmaps
          if (n.isDepthTexture)
            (x = 6402),
              o ? (x = 1015 === n.type ? 36012 : 1014 === n.type ? 33190 : 1020 === n.type ? 35056 : 33189) : n.type,
              1026 === n.format &&
                6402 === x &&
                1012 !== n.type &&
                1014 !== n.type &&
                ((n.type = 1012), (A = r.convert(n.type))),
              1027 === n.format &&
                6402 === x &&
                ((x = 34041), 1020 !== n.type && ((n.type = 1020), (A = r.convert(n.type)))),
              i.texImage2D(3553, 0, x, h.width, h.height, 0, d, A, null)
          else if (n.isDataTexture)
            if (w.length > 0 && u) {
              for (let t = 0, e = w.length; t < e; t++)
                (p = w[t]), i.texImage2D(3553, t, x, p.width, p.height, 0, d, A, p.data)
              ;(n.generateMipmaps = !1), (e.__maxMipLevel = w.length - 1)
            } else i.texImage2D(3553, 0, x, h.width, h.height, 0, d, A, h.data), (e.__maxMipLevel = 0)
          else if (n.isCompressedTexture) {
            for (let t = 0, e = w.length; t < e; t++)
              (p = w[t]),
                1023 !== n.format && 1022 !== n.format
                  ? null !== d && i.compressedTexImage2D(3553, t, x, p.width, p.height, 0, p.data)
                  : i.texImage2D(3553, t, x, p.width, p.height, 0, d, A, p.data)
            e.__maxMipLevel = w.length - 1
          } else if (n.isDataTexture2DArray)
            i.texImage3D(35866, 0, x, h.width, h.height, h.depth, 0, d, A, h.data), (e.__maxMipLevel = 0)
          else if (n.isDataTexture3D)
            i.texImage3D(32879, 0, x, h.width, h.height, h.depth, 0, d, A, h.data), (e.__maxMipLevel = 0)
          else if (w.length > 0 && u) {
            for (let t = 0, e = w.length; t < e; t++) (p = w[t]), i.texImage2D(3553, t, x, d, A, p)
            ;(n.generateMipmaps = !1), (e.__maxMipLevel = w.length - 1)
          } else i.texImage2D(3553, 0, x, d, A, h), (e.__maxMipLevel = 0)
          f(n, u) && v(a, n, h.width, h.height), (e.__version = n.version), n.onUpdate && n.onUpdate(n)
        }
        function L(e, s, a, o, l) {
          const c = r.convert(a.format),
            h = r.convert(a.type),
            u = y(a.internalFormat, c, h)
          32879 === l || 35866 === l
            ? i.texImage3D(l, 0, u, s.width, s.height, s.depth, 0, c, h, null)
            : i.texImage2D(l, 0, u, s.width, s.height, 0, c, h, null),
            i.bindFramebuffer(36160, e),
            t.framebufferTexture2D(36160, o, l, n.get(a).__webglTexture, 0),
            i.bindFramebuffer(36160, null)
        }
        function D(e, i, n) {
          if ((t.bindRenderbuffer(36161, e), i.depthBuffer && !i.stencilBuffer)) {
            let s = 33189
            if (n) {
              const e = i.depthTexture
              e && e.isDepthTexture && (1015 === e.type ? (s = 36012) : 1014 === e.type && (s = 33190))
              const n = Q(i)
              t.renderbufferStorageMultisample(36161, n, s, i.width, i.height)
            } else t.renderbufferStorage(36161, s, i.width, i.height)
            t.framebufferRenderbuffer(36160, 36096, 36161, e)
          } else if (i.depthBuffer && i.stencilBuffer) {
            if (n) {
              const e = Q(i)
              t.renderbufferStorageMultisample(36161, e, 35056, i.width, i.height)
            } else t.renderbufferStorage(36161, 34041, i.width, i.height)
            t.framebufferRenderbuffer(36160, 33306, 36161, e)
          } else {
            const e = !0 === i.isWebGLMultipleRenderTargets ? i.texture[0] : i.texture,
              s = r.convert(e.format),
              a = r.convert(e.type),
              o = y(e.internalFormat, s, a)
            if (n) {
              const e = Q(i)
              t.renderbufferStorageMultisample(36161, e, o, i.width, i.height)
            } else t.renderbufferStorage(36161, o, i.width, i.height)
          }
          t.bindRenderbuffer(36161, null)
        }
        function Q(t) {
          return o && t.isWebGLMultisampleRenderTarget ? Math.min(h, t.samples) : 0
        }
        let R = !1,
          P = !1
        ;(this.allocateTextureUnit = function () {
          const t = I
          return (I += 1), t
        }),
          (this.resetTextureUnits = function () {
            I = 0
          }),
          (this.setTexture2D = C),
          (this.setTexture2DArray = function (t, e) {
            const s = n.get(t)
            t.version > 0 && s.__version !== t.version
              ? T(s, t, e)
              : (i.activeTexture(33984 + e), i.bindTexture(35866, s.__webglTexture))
          }),
          (this.setTexture3D = function (t, e) {
            const s = n.get(t)
            t.version > 0 && s.__version !== t.version
              ? T(s, t, e)
              : (i.activeTexture(33984 + e), i.bindTexture(32879, s.__webglTexture))
          }),
          (this.setTextureCube = M),
          (this.setupRenderTarget = function (e) {
            const l = e.texture,
              c = n.get(e),
              h = n.get(l)
            e.addEventListener('dispose', _),
              !0 !== e.isWebGLMultipleRenderTargets &&
                ((h.__webglTexture = t.createTexture()), (h.__version = l.version), a.memory.textures++)
            const u = !0 === e.isWebGLCubeRenderTarget,
              d = !0 === e.isWebGLMultipleRenderTargets,
              p = !0 === e.isWebGLMultisampleRenderTarget,
              A = l.isDataTexture3D || l.isDataTexture2DArray,
              g = m(e) || o
            if ((!o || 1022 !== l.format || (1015 !== l.type && 1016 !== l.type) || (l.format = 1023), u)) {
              c.__webglFramebuffer = []
              for (let e = 0; e < 6; e++) c.__webglFramebuffer[e] = t.createFramebuffer()
            } else if (((c.__webglFramebuffer = t.createFramebuffer()), d)) {
              if (s.drawBuffers) {
                const i = e.texture
                for (let e = 0, s = i.length; e < s; e++) {
                  const s = n.get(i[e])
                  void 0 === s.__webglTexture && ((s.__webglTexture = t.createTexture()), a.memory.textures++)
                }
              }
            } else if (p && o) {
              ;(c.__webglMultisampledFramebuffer = t.createFramebuffer()),
                (c.__webglColorRenderbuffer = t.createRenderbuffer()),
                t.bindRenderbuffer(36161, c.__webglColorRenderbuffer)
              const n = r.convert(l.format),
                s = r.convert(l.type),
                a = y(l.internalFormat, n, s),
                o = Q(e)
              t.renderbufferStorageMultisample(36161, o, a, e.width, e.height),
                i.bindFramebuffer(36160, c.__webglMultisampledFramebuffer),
                t.framebufferRenderbuffer(36160, 36064, 36161, c.__webglColorRenderbuffer),
                t.bindRenderbuffer(36161, null),
                e.depthBuffer &&
                  ((c.__webglDepthRenderbuffer = t.createRenderbuffer()), D(c.__webglDepthRenderbuffer, e, !0)),
                i.bindFramebuffer(36160, null)
            }
            if (u) {
              i.bindTexture(34067, h.__webglTexture), S(34067, l, g)
              for (let t = 0; t < 6; t++) L(c.__webglFramebuffer[t], e, l, 36064, 34069 + t)
              f(l, g) && v(34067, l, e.width, e.height), i.bindTexture(34067, null)
            } else if (d) {
              const t = e.texture
              for (let s = 0, r = t.length; s < r; s++) {
                const r = t[s],
                  a = n.get(r)
                i.bindTexture(3553, a.__webglTexture),
                  S(3553, r, g),
                  L(c.__webglFramebuffer, e, r, 36064 + s, 3553),
                  f(r, g) && v(3553, r, e.width, e.height)
              }
              i.bindTexture(3553, null)
            } else {
              let t = 3553
              A && o && (t = l.isDataTexture3D ? 32879 : 35866),
                i.bindTexture(t, h.__webglTexture),
                S(t, l, g),
                L(c.__webglFramebuffer, e, l, 36064, t),
                f(l, g) && v(t, l, e.width, e.height, e.depth),
                i.bindTexture(t, null)
            }
            e.depthBuffer &&
              (function (e) {
                const s = n.get(e),
                  r = !0 === e.isWebGLCubeRenderTarget
                if (e.depthTexture) {
                  if (r) throw new Error('target.depthTexture not supported in Cube render targets')
                  !(function (e, s) {
                    if (s && s.isWebGLCubeRenderTarget)
                      throw new Error('Depth Texture with cube render targets is not supported')
                    if ((i.bindFramebuffer(36160, e), !s.depthTexture || !s.depthTexture.isDepthTexture))
                      throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture')
                    ;(n.get(s.depthTexture).__webglTexture &&
                      s.depthTexture.image.width === s.width &&
                      s.depthTexture.image.height === s.height) ||
                      ((s.depthTexture.image.width = s.width),
                      (s.depthTexture.image.height = s.height),
                      (s.depthTexture.needsUpdate = !0)),
                      C(s.depthTexture, 0)
                    const r = n.get(s.depthTexture).__webglTexture
                    if (1026 === s.depthTexture.format) t.framebufferTexture2D(36160, 36096, 3553, r, 0)
                    else {
                      if (1027 !== s.depthTexture.format) throw new Error('Unknown depthTexture format')
                      t.framebufferTexture2D(36160, 33306, 3553, r, 0)
                    }
                  })(s.__webglFramebuffer, e)
                } else if (r) {
                  s.__webglDepthbuffer = []
                  for (let n = 0; n < 6; n++)
                    i.bindFramebuffer(36160, s.__webglFramebuffer[n]),
                      (s.__webglDepthbuffer[n] = t.createRenderbuffer()),
                      D(s.__webglDepthbuffer[n], e, !1)
                } else
                  i.bindFramebuffer(36160, s.__webglFramebuffer),
                    (s.__webglDepthbuffer = t.createRenderbuffer()),
                    D(s.__webglDepthbuffer, e, !1)
                i.bindFramebuffer(36160, null)
              })(e)
          }),
          (this.updateRenderTargetMipmap = function (t) {
            const e = m(t) || o,
              s = !0 === t.isWebGLMultipleRenderTargets ? t.texture : [t.texture]
            for (let r = 0, a = s.length; r < a; r++) {
              const a = s[r]
              if (f(a, e)) {
                const e = t.isWebGLCubeRenderTarget ? 34067 : 3553,
                  s = n.get(a).__webglTexture
                i.bindTexture(e, s), v(e, a, t.width, t.height), i.bindTexture(e, null)
              }
            }
          }),
          (this.updateMultisampleRenderTarget = function (e) {
            if (e.isWebGLMultisampleRenderTarget && o) {
              const s = e.width,
                r = e.height
              let a = 16384
              e.depthBuffer && (a |= 256), e.stencilBuffer && (a |= 1024)
              const o = n.get(e)
              i.bindFramebuffer(36008, o.__webglMultisampledFramebuffer),
                i.bindFramebuffer(36009, o.__webglFramebuffer),
                t.blitFramebuffer(0, 0, s, r, 0, 0, s, r, a, 9728),
                i.bindFramebuffer(36008, null),
                i.bindFramebuffer(36009, o.__webglMultisampledFramebuffer)
            }
          }),
          (this.safeSetTexture2D = function (t, e) {
            t && t.isWebGLRenderTarget && (!1 === R && (R = !0), (t = t.texture)), C(t, e)
          }),
          (this.safeSetTextureCube = function (t, e) {
            t && t.isWebGLCubeRenderTarget && (!1 === P && (P = !0), (t = t.texture)), M(t, e)
          })
      }
      function Er(t, e, i) {
        const n = i.isWebGL2
        return {
          convert: function (t) {
            let i
            if (1009 === t) return 5121
            if (1017 === t) return 32819
            if (1018 === t) return 32820
            if (1019 === t) return 33635
            if (1010 === t) return 5120
            if (1011 === t) return 5122
            if (1012 === t) return 5123
            if (1013 === t) return 5124
            if (1014 === t) return 5125
            if (1015 === t) return 5126
            if (1016 === t)
              return n ? 5131 : ((i = e.get('OES_texture_half_float')), null !== i ? i.HALF_FLOAT_OES : null)
            if (1021 === t) return 6406
            if (1022 === t) return 6407
            if (1023 === t) return 6408
            if (1024 === t) return 6409
            if (1025 === t) return 6410
            if (1026 === t) return 6402
            if (1027 === t) return 34041
            if (1028 === t) return 6403
            if (1029 === t) return 36244
            if (1030 === t) return 33319
            if (1031 === t) return 33320
            if (1032 === t) return 36248
            if (1033 === t) return 36249
            if (33776 === t || 33777 === t || 33778 === t || 33779 === t) {
              if (((i = e.get('WEBGL_compressed_texture_s3tc')), null === i)) return null
              if (33776 === t) return i.COMPRESSED_RGB_S3TC_DXT1_EXT
              if (33777 === t) return i.COMPRESSED_RGBA_S3TC_DXT1_EXT
              if (33778 === t) return i.COMPRESSED_RGBA_S3TC_DXT3_EXT
              if (33779 === t) return i.COMPRESSED_RGBA_S3TC_DXT5_EXT
            }
            if (35840 === t || 35841 === t || 35842 === t || 35843 === t) {
              if (((i = e.get('WEBGL_compressed_texture_pvrtc')), null === i)) return null
              if (35840 === t) return i.COMPRESSED_RGB_PVRTC_4BPPV1_IMG
              if (35841 === t) return i.COMPRESSED_RGB_PVRTC_2BPPV1_IMG
              if (35842 === t) return i.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG
              if (35843 === t) return i.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
            }
            if (36196 === t)
              return (i = e.get('WEBGL_compressed_texture_etc1')), null !== i ? i.COMPRESSED_RGB_ETC1_WEBGL : null
            if ((37492 === t || 37496 === t) && ((i = e.get('WEBGL_compressed_texture_etc')), null !== i)) {
              if (37492 === t) return i.COMPRESSED_RGB8_ETC2
              if (37496 === t) return i.COMPRESSED_RGBA8_ETC2_EAC
            }
            return 37808 === t ||
              37809 === t ||
              37810 === t ||
              37811 === t ||
              37812 === t ||
              37813 === t ||
              37814 === t ||
              37815 === t ||
              37816 === t ||
              37817 === t ||
              37818 === t ||
              37819 === t ||
              37820 === t ||
              37821 === t ||
              37840 === t ||
              37841 === t ||
              37842 === t ||
              37843 === t ||
              37844 === t ||
              37845 === t ||
              37846 === t ||
              37847 === t ||
              37848 === t ||
              37849 === t ||
              37850 === t ||
              37851 === t ||
              37852 === t ||
              37853 === t
              ? ((i = e.get('WEBGL_compressed_texture_astc')), null !== i ? t : null)
              : 36492 === t
              ? ((i = e.get('EXT_texture_compression_bptc')), null !== i ? t : null)
              : 1020 === t
              ? n
                ? 34042
                : ((i = e.get('WEBGL_depth_texture')), null !== i ? i.UNSIGNED_INT_24_8_WEBGL : null)
              : void 0
          },
        }
      }
      _r.prototype.isMeshDistanceMaterial = !0
      class br extends Ni {
        constructor(t = []) {
          super(), (this.cameras = t)
        }
      }
      br.prototype.isArrayCamera = !0
      class Sr extends Se {
        constructor() {
          super(), (this.type = 'Group')
        }
      }
      Sr.prototype.isGroup = !0
      const Br = { type: 'move' }
      class Tr {
        constructor() {
          ;(this._targetRay = null), (this._grip = null), (this._hand = null)
        }
        getHandSpace() {
          return (
            null === this._hand &&
              ((this._hand = new Sr()),
              (this._hand.matrixAutoUpdate = !1),
              (this._hand.visible = !1),
              (this._hand.joints = {}),
              (this._hand.inputState = { pinching: !1 })),
            this._hand
          )
        }
        getTargetRaySpace() {
          return (
            null === this._targetRay &&
              ((this._targetRay = new Sr()),
              (this._targetRay.matrixAutoUpdate = !1),
              (this._targetRay.visible = !1),
              (this._targetRay.hasLinearVelocity = !1),
              (this._targetRay.linearVelocity = new Et()),
              (this._targetRay.hasAngularVelocity = !1),
              (this._targetRay.angularVelocity = new Et())),
            this._targetRay
          )
        }
        getGripSpace() {
          return (
            null === this._grip &&
              ((this._grip = new Sr()),
              (this._grip.matrixAutoUpdate = !1),
              (this._grip.visible = !1),
              (this._grip.hasLinearVelocity = !1),
              (this._grip.linearVelocity = new Et()),
              (this._grip.hasAngularVelocity = !1),
              (this._grip.angularVelocity = new Et())),
            this._grip
          )
        }
        dispatchEvent(t) {
          return (
            null !== this._targetRay && this._targetRay.dispatchEvent(t),
            null !== this._grip && this._grip.dispatchEvent(t),
            null !== this._hand && this._hand.dispatchEvent(t),
            this
          )
        }
        disconnect(t) {
          return (
            this.dispatchEvent({ type: 'disconnected', data: t }),
            null !== this._targetRay && (this._targetRay.visible = !1),
            null !== this._grip && (this._grip.visible = !1),
            null !== this._hand && (this._hand.visible = !1),
            this
          )
        }
        update(t, e, i) {
          let n = null,
            s = null,
            r = null
          const a = this._targetRay,
            o = this._grip,
            l = this._hand
          if (t && 'visible-blurred' !== e.session.visibilityState)
            if (
              (null !== a &&
                ((n = e.getPose(t.targetRaySpace, i)),
                null !== n &&
                  (a.matrix.fromArray(n.transform.matrix),
                  a.matrix.decompose(a.position, a.rotation, a.scale),
                  n.linearVelocity
                    ? ((a.hasLinearVelocity = !0), a.linearVelocity.copy(n.linearVelocity))
                    : (a.hasLinearVelocity = !1),
                  n.angularVelocity
                    ? ((a.hasAngularVelocity = !0), a.angularVelocity.copy(n.angularVelocity))
                    : (a.hasAngularVelocity = !1),
                  this.dispatchEvent(Br))),
              l && t.hand)
            ) {
              r = !0
              for (const r of t.hand.values()) {
                const t = e.getJointPose(r, i)
                if (void 0 === l.joints[r.jointName]) {
                  const t = new Sr()
                  ;(t.matrixAutoUpdate = !1), (t.visible = !1), (l.joints[r.jointName] = t), l.add(t)
                }
                const n = l.joints[r.jointName]
                null !== t &&
                  (n.matrix.fromArray(t.transform.matrix),
                  n.matrix.decompose(n.position, n.rotation, n.scale),
                  (n.jointRadius = t.radius)),
                  (n.visible = null !== t)
              }
              const n = l.joints['index-finger-tip'],
                s = l.joints['thumb-tip'],
                a = n.position.distanceTo(s.position),
                o = 0.02,
                c = 0.005
              l.inputState.pinching && a > o + c
                ? ((l.inputState.pinching = !1),
                  this.dispatchEvent({ type: 'pinchend', handedness: t.handedness, target: this }))
                : !l.inputState.pinching &&
                  a <= o - c &&
                  ((l.inputState.pinching = !0),
                  this.dispatchEvent({ type: 'pinchstart', handedness: t.handedness, target: this }))
            } else
              null !== o &&
                t.gripSpace &&
                ((s = e.getPose(t.gripSpace, i)),
                null !== s &&
                  (o.matrix.fromArray(s.transform.matrix),
                  o.matrix.decompose(o.position, o.rotation, o.scale),
                  s.linearVelocity
                    ? ((o.hasLinearVelocity = !0), o.linearVelocity.copy(s.linearVelocity))
                    : (o.hasLinearVelocity = !1),
                  s.angularVelocity
                    ? ((o.hasAngularVelocity = !0), o.angularVelocity.copy(s.angularVelocity))
                    : (o.hasAngularVelocity = !1)))
          return (
            null !== a && (a.visible = null !== n),
            null !== o && (o.visible = null !== s),
            null !== l && (l.visible = null !== r),
            this
          )
        }
      }
      class Lr extends it {
        constructor(t, e) {
          super()
          const i = this,
            n = t.state
          let s = null,
            r = 1,
            a = null,
            o = 'local-floor',
            l = null,
            c = null,
            h = null,
            u = null,
            d = null
          const p = [],
            A = new Map(),
            g = new Ni()
          g.layers.enable(1), (g.viewport = new _t())
          const m = new Ni()
          m.layers.enable(2), (m.viewport = new _t())
          const f = [g, m],
            v = new br()
          v.layers.enable(1), v.layers.enable(2)
          let y = null,
            x = null
          function w(t) {
            const e = A.get(t.inputSource)
            e && e.dispatchEvent({ type: t.type, data: t.inputSource })
          }
          function _() {
            A.forEach(function (t, e) {
              t.disconnect(e)
            }),
              A.clear(),
              (y = null),
              (x = null),
              n.bindXRFramebuffer(null),
              t.setRenderTarget(t.getRenderTarget()),
              S.stop(),
              (i.isPresenting = !1),
              i.dispatchEvent({ type: 'sessionend' })
          }
          function I(t) {
            const e = s.inputSources
            for (let i = 0; i < p.length; i++) A.set(e[i], p[i])
            for (let i = 0; i < t.removed.length; i++) {
              const e = t.removed[i],
                n = A.get(e)
              n && (n.dispatchEvent({ type: 'disconnected', data: e }), A.delete(e))
            }
            for (let i = 0; i < t.added.length; i++) {
              const e = t.added[i],
                n = A.get(e)
              n && n.dispatchEvent({ type: 'connected', data: e })
            }
          }
          ;(this.cameraAutoUpdate = !0),
            (this.enabled = !1),
            (this.isPresenting = !1),
            (this.getController = function (t) {
              let e = p[t]
              return void 0 === e && ((e = new Tr()), (p[t] = e)), e.getTargetRaySpace()
            }),
            (this.getControllerGrip = function (t) {
              let e = p[t]
              return void 0 === e && ((e = new Tr()), (p[t] = e)), e.getGripSpace()
            }),
            (this.getHand = function (t) {
              let e = p[t]
              return void 0 === e && ((e = new Tr()), (p[t] = e)), e.getHandSpace()
            }),
            (this.setFramebufferScaleFactor = function (t) {
              ;(r = t), i.isPresenting
            }),
            (this.setReferenceSpaceType = function (t) {
              ;(o = t), i.isPresenting
            }),
            (this.getReferenceSpace = function () {
              return a
            }),
            (this.getSession = function () {
              return s
            }),
            (this.setSession = async function (t) {
              if (((s = t), null !== s)) {
                s.addEventListener('select', w),
                  s.addEventListener('selectstart', w),
                  s.addEventListener('selectend', w),
                  s.addEventListener('squeeze', w),
                  s.addEventListener('squeezestart', w),
                  s.addEventListener('squeezeend', w),
                  s.addEventListener('end', _),
                  s.addEventListener('inputsourceschange', I)
                const t = e.getContextAttributes()
                if ((!0 !== t.xrCompatible && (await e.makeXRCompatible()), void 0 === s.renderState.layers)) {
                  const i = {
                    antialias: t.antialias,
                    alpha: t.alpha,
                    depth: t.depth,
                    stencil: t.stencil,
                    framebufferScaleFactor: r,
                  }
                  ;(d = new XRWebGLLayer(s, e, i)), s.updateRenderState({ baseLayer: d })
                } else {
                  let i = 0
                  if (t.antialias) {
                    const i = {
                      antialias: !0,
                      alpha: t.alpha,
                      depth: t.depth,
                      stencil: t.stencil,
                      framebufferScaleFactor: r,
                    }
                    ;(d = new XRWebGLLayer(s, e, i)), s.updateRenderState({ layers: [d] })
                  } else {
                    t.depth && (i = t.stencil ? 34041 : 6402)
                    const n = { colorFormat: t.alpha ? 6408 : 6407, depthFormat: i, scaleFactor: r }
                    ;(c = new XRWebGLBinding(s, e)),
                      (u = c.createProjectionLayer(n)),
                      (h = e.createFramebuffer()),
                      s.updateRenderState({ layers: [u] })
                  }
                }
                ;(a = await s.requestReferenceSpace(o)),
                  S.setContext(s),
                  S.start(),
                  (i.isPresenting = !0),
                  i.dispatchEvent({ type: 'sessionstart' })
              }
            })
          const C = new Et(),
            M = new Et()
          function E(t, e) {
            null === e ? t.matrixWorld.copy(t.matrix) : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix),
              t.matrixWorldInverse.copy(t.matrixWorld).invert()
          }
          ;(this.updateCamera = function (t) {
            if (null === s) return
            ;(v.near = m.near = g.near = t.near),
              (v.far = m.far = g.far = t.far),
              (y === v.near && x === v.far) ||
                (s.updateRenderState({ depthNear: v.near, depthFar: v.far }), (y = v.near), (x = v.far))
            const e = t.parent,
              i = v.cameras
            E(v, e)
            for (let s = 0; s < i.length; s++) E(i[s], e)
            v.matrixWorld.decompose(v.position, v.quaternion, v.scale),
              t.position.copy(v.position),
              t.quaternion.copy(v.quaternion),
              t.scale.copy(v.scale),
              t.matrix.copy(v.matrix),
              t.matrixWorld.copy(v.matrixWorld)
            const n = t.children
            for (let s = 0, r = n.length; s < r; s++) n[s].updateMatrixWorld(!0)
            2 === i.length
              ? (function (t, e, i) {
                  C.setFromMatrixPosition(e.matrixWorld), M.setFromMatrixPosition(i.matrixWorld)
                  const n = C.distanceTo(M),
                    s = e.projectionMatrix.elements,
                    r = i.projectionMatrix.elements,
                    a = s[14] / (s[10] - 1),
                    o = s[14] / (s[10] + 1),
                    l = (s[9] + 1) / s[5],
                    c = (s[9] - 1) / s[5],
                    h = (s[8] - 1) / s[0],
                    u = (r[8] + 1) / r[0],
                    d = a * h,
                    p = a * u,
                    A = n / (-h + u),
                    g = A * -h
                  e.matrixWorld.decompose(t.position, t.quaternion, t.scale),
                    t.translateX(g),
                    t.translateZ(A),
                    t.matrixWorld.compose(t.position, t.quaternion, t.scale),
                    t.matrixWorldInverse.copy(t.matrixWorld).invert()
                  const m = a + A,
                    f = o + A,
                    v = d - g,
                    y = p + (n - g),
                    x = ((l * o) / f) * m,
                    w = ((c * o) / f) * m
                  t.projectionMatrix.makePerspective(v, y, x, w, m, f)
                })(v, g, m)
              : v.projectionMatrix.copy(g.projectionMatrix)
          }),
            (this.getCamera = function () {
              return v
            }),
            (this.getFoveation = function () {
              return null !== u ? u.fixedFoveation : null !== d ? d.fixedFoveation : void 0
            }),
            (this.setFoveation = function (t) {
              null !== u && (u.fixedFoveation = t), null !== d && void 0 !== d.fixedFoveation && (d.fixedFoveation = t)
            })
          let b = null
          const S = new ji()
          S.setAnimationLoop(function (t, i) {
            if (((l = i.getViewerPose(a)), null !== l)) {
              const t = l.views
              null !== d && n.bindXRFramebuffer(d.framebuffer)
              let i = !1
              t.length !== v.cameras.length && ((v.cameras.length = 0), (i = !0))
              for (let s = 0; s < t.length; s++) {
                const r = t[s]
                let a = null
                if (null !== d) a = d.getViewport(r)
                else {
                  const t = c.getViewSubImage(u, r)
                  n.bindXRFramebuffer(h),
                    void 0 !== t.depthStencilTexture &&
                      e.framebufferTexture2D(36160, 36096, 3553, t.depthStencilTexture, 0),
                    e.framebufferTexture2D(36160, 36064, 3553, t.colorTexture, 0),
                    (a = t.viewport)
                }
                const o = f[s]
                o.matrix.fromArray(r.transform.matrix),
                  o.projectionMatrix.fromArray(r.projectionMatrix),
                  o.viewport.set(a.x, a.y, a.width, a.height),
                  0 === s && v.matrix.copy(o.matrix),
                  !0 === i && v.cameras.push(o)
              }
            }
            const r = s.inputSources
            for (let e = 0; e < p.length; e++) {
              const t = p[e],
                n = r[e]
              t.update(n, i, a)
            }
            b && b(t, i)
          }),
            (this.setAnimationLoop = function (t) {
              b = t
            }),
            (this.dispose = function () {})
        }
      }
      function Dr(t) {
        function e(e, i) {
          ;(e.opacity.value = i.opacity),
            i.color && e.diffuse.value.copy(i.color),
            i.emissive && e.emissive.value.copy(i.emissive).multiplyScalar(i.emissiveIntensity),
            i.map && (e.map.value = i.map),
            i.alphaMap && (e.alphaMap.value = i.alphaMap),
            i.specularMap && (e.specularMap.value = i.specularMap)
          const n = t.get(i).envMap
          if (n) {
            ;(e.envMap.value = n),
              (e.flipEnvMap.value = n.isCubeTexture && !1 === n.isRenderTargetTexture ? -1 : 1),
              (e.reflectivity.value = i.reflectivity),
              (e.refractionRatio.value = i.refractionRatio)
            const s = t.get(n).__maxMipLevel
            void 0 !== s && (e.maxMipLevel.value = s)
          }
          let s, r
          i.lightMap && ((e.lightMap.value = i.lightMap), (e.lightMapIntensity.value = i.lightMapIntensity)),
            i.aoMap && ((e.aoMap.value = i.aoMap), (e.aoMapIntensity.value = i.aoMapIntensity)),
            i.map
              ? (s = i.map)
              : i.specularMap
              ? (s = i.specularMap)
              : i.displacementMap
              ? (s = i.displacementMap)
              : i.normalMap
              ? (s = i.normalMap)
              : i.bumpMap
              ? (s = i.bumpMap)
              : i.roughnessMap
              ? (s = i.roughnessMap)
              : i.metalnessMap
              ? (s = i.metalnessMap)
              : i.alphaMap
              ? (s = i.alphaMap)
              : i.emissiveMap
              ? (s = i.emissiveMap)
              : i.clearcoatMap
              ? (s = i.clearcoatMap)
              : i.clearcoatNormalMap
              ? (s = i.clearcoatNormalMap)
              : i.clearcoatRoughnessMap
              ? (s = i.clearcoatRoughnessMap)
              : i.specularIntensityMap
              ? (s = i.specularIntensityMap)
              : i.specularTintMap && (s = i.specularTintMap),
            void 0 !== s &&
              (s.isWebGLRenderTarget && (s = s.texture),
              !0 === s.matrixAutoUpdate && s.updateMatrix(),
              e.uvTransform.value.copy(s.matrix)),
            i.aoMap ? (r = i.aoMap) : i.lightMap && (r = i.lightMap),
            void 0 !== r &&
              (r.isWebGLRenderTarget && (r = r.texture),
              !0 === r.matrixAutoUpdate && r.updateMatrix(),
              e.uv2Transform.value.copy(r.matrix))
        }
        function i(e, i) {
          ;(e.roughness.value = i.roughness),
            (e.metalness.value = i.metalness),
            i.roughnessMap && (e.roughnessMap.value = i.roughnessMap),
            i.metalnessMap && (e.metalnessMap.value = i.metalnessMap),
            i.emissiveMap && (e.emissiveMap.value = i.emissiveMap),
            i.bumpMap &&
              ((e.bumpMap.value = i.bumpMap),
              (e.bumpScale.value = i.bumpScale),
              1 === i.side && (e.bumpScale.value *= -1)),
            i.normalMap &&
              ((e.normalMap.value = i.normalMap),
              e.normalScale.value.copy(i.normalScale),
              1 === i.side && e.normalScale.value.negate()),
            i.displacementMap &&
              ((e.displacementMap.value = i.displacementMap),
              (e.displacementScale.value = i.displacementScale),
              (e.displacementBias.value = i.displacementBias)),
            t.get(i).envMap && (e.envMapIntensity.value = i.envMapIntensity)
        }
        return {
          refreshFogUniforms: function (t, e) {
            t.fogColor.value.copy(e.color),
              e.isFog
                ? ((t.fogNear.value = e.near), (t.fogFar.value = e.far))
                : e.isFogExp2 && (t.fogDensity.value = e.density)
          },
          refreshMaterialUniforms: function (t, n, s, r, a) {
            n.isMeshBasicMaterial
              ? e(t, n)
              : n.isMeshLambertMaterial
              ? (e(t, n),
                (function (t, e) {
                  e.emissiveMap && (t.emissiveMap.value = e.emissiveMap)
                })(t, n))
              : n.isMeshToonMaterial
              ? (e(t, n),
                (function (t, e) {
                  e.gradientMap && (t.gradientMap.value = e.gradientMap),
                    e.emissiveMap && (t.emissiveMap.value = e.emissiveMap),
                    e.bumpMap &&
                      ((t.bumpMap.value = e.bumpMap),
                      (t.bumpScale.value = e.bumpScale),
                      1 === e.side && (t.bumpScale.value *= -1)),
                    e.normalMap &&
                      ((t.normalMap.value = e.normalMap),
                      t.normalScale.value.copy(e.normalScale),
                      1 === e.side && t.normalScale.value.negate()),
                    e.displacementMap &&
                      ((t.displacementMap.value = e.displacementMap),
                      (t.displacementScale.value = e.displacementScale),
                      (t.displacementBias.value = e.displacementBias))
                })(t, n))
              : n.isMeshPhongMaterial
              ? (e(t, n),
                (function (t, e) {
                  t.specular.value.copy(e.specular),
                    (t.shininess.value = Math.max(e.shininess, 1e-4)),
                    e.emissiveMap && (t.emissiveMap.value = e.emissiveMap),
                    e.bumpMap &&
                      ((t.bumpMap.value = e.bumpMap),
                      (t.bumpScale.value = e.bumpScale),
                      1 === e.side && (t.bumpScale.value *= -1)),
                    e.normalMap &&
                      ((t.normalMap.value = e.normalMap),
                      t.normalScale.value.copy(e.normalScale),
                      1 === e.side && t.normalScale.value.negate()),
                    e.displacementMap &&
                      ((t.displacementMap.value = e.displacementMap),
                      (t.displacementScale.value = e.displacementScale),
                      (t.displacementBias.value = e.displacementBias))
                })(t, n))
              : n.isMeshStandardMaterial
              ? (e(t, n),
                n.isMeshPhysicalMaterial
                  ? (function (t, e, n) {
                      i(t, e),
                        (t.reflectivity.value = e.reflectivity),
                        (t.clearcoat.value = e.clearcoat),
                        (t.clearcoatRoughness.value = e.clearcoatRoughness),
                        e.sheen && t.sheen.value.copy(e.sheen),
                        e.clearcoatMap && (t.clearcoatMap.value = e.clearcoatMap),
                        e.clearcoatRoughnessMap && (t.clearcoatRoughnessMap.value = e.clearcoatRoughnessMap),
                        e.clearcoatNormalMap &&
                          (t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale),
                          (t.clearcoatNormalMap.value = e.clearcoatNormalMap),
                          1 === e.side && t.clearcoatNormalScale.value.negate()),
                        (t.transmission.value = e.transmission),
                        e.transmissionMap && (t.transmissionMap.value = e.transmissionMap),
                        e.transmission > 0 &&
                          ((t.transmissionSamplerMap.value = n.texture),
                          t.transmissionSamplerSize.value.set(n.width, n.height)),
                        (t.thickness.value = e.thickness),
                        e.thicknessMap && (t.thicknessMap.value = e.thicknessMap),
                        (t.attenuationDistance.value = e.attenuationDistance),
                        t.attenuationTint.value.copy(e.attenuationTint),
                        (t.specularIntensity.value = e.specularIntensity),
                        t.specularTint.value.copy(e.specularTint),
                        e.specularIntensityMap && (t.specularIntensityMap.value = e.specularIntensityMap),
                        e.specularTintMap && (t.specularTintMap.value = e.specularTintMap)
                    })(t, n, a)
                  : i(t, n))
              : n.isMeshMatcapMaterial
              ? (e(t, n),
                (function (t, e) {
                  e.matcap && (t.matcap.value = e.matcap),
                    e.bumpMap &&
                      ((t.bumpMap.value = e.bumpMap),
                      (t.bumpScale.value = e.bumpScale),
                      1 === e.side && (t.bumpScale.value *= -1)),
                    e.normalMap &&
                      ((t.normalMap.value = e.normalMap),
                      t.normalScale.value.copy(e.normalScale),
                      1 === e.side && t.normalScale.value.negate()),
                    e.displacementMap &&
                      ((t.displacementMap.value = e.displacementMap),
                      (t.displacementScale.value = e.displacementScale),
                      (t.displacementBias.value = e.displacementBias))
                })(t, n))
              : n.isMeshDepthMaterial
              ? (e(t, n),
                (function (t, e) {
                  e.displacementMap &&
                    ((t.displacementMap.value = e.displacementMap),
                    (t.displacementScale.value = e.displacementScale),
                    (t.displacementBias.value = e.displacementBias))
                })(t, n))
              : n.isMeshDistanceMaterial
              ? (e(t, n),
                (function (t, e) {
                  e.displacementMap &&
                    ((t.displacementMap.value = e.displacementMap),
                    (t.displacementScale.value = e.displacementScale),
                    (t.displacementBias.value = e.displacementBias)),
                    t.referencePosition.value.copy(e.referencePosition),
                    (t.nearDistance.value = e.nearDistance),
                    (t.farDistance.value = e.farDistance)
                })(t, n))
              : n.isMeshNormalMaterial
              ? (e(t, n),
                (function (t, e) {
                  e.bumpMap &&
                    ((t.bumpMap.value = e.bumpMap),
                    (t.bumpScale.value = e.bumpScale),
                    1 === e.side && (t.bumpScale.value *= -1)),
                    e.normalMap &&
                      ((t.normalMap.value = e.normalMap),
                      t.normalScale.value.copy(e.normalScale),
                      1 === e.side && t.normalScale.value.negate()),
                    e.displacementMap &&
                      ((t.displacementMap.value = e.displacementMap),
                      (t.displacementScale.value = e.displacementScale),
                      (t.displacementBias.value = e.displacementBias))
                })(t, n))
              : n.isLineBasicMaterial
              ? ((function (t, e) {
                  t.diffuse.value.copy(e.color), (t.opacity.value = e.opacity)
                })(t, n),
                n.isLineDashedMaterial &&
                  (function (t, e) {
                    ;(t.dashSize.value = e.dashSize),
                      (t.totalSize.value = e.dashSize + e.gapSize),
                      (t.scale.value = e.scale)
                  })(t, n))
              : n.isPointsMaterial
              ? (function (t, e, i, n) {
                  let s
                  t.diffuse.value.copy(e.color),
                    (t.opacity.value = e.opacity),
                    (t.size.value = e.size * i),
                    (t.scale.value = 0.5 * n),
                    e.map && (t.map.value = e.map),
                    e.alphaMap && (t.alphaMap.value = e.alphaMap),
                    e.map ? (s = e.map) : e.alphaMap && (s = e.alphaMap),
                    void 0 !== s && (!0 === s.matrixAutoUpdate && s.updateMatrix(), t.uvTransform.value.copy(s.matrix))
                })(t, n, s, r)
              : n.isSpriteMaterial
              ? (function (t, e) {
                  let i
                  t.diffuse.value.copy(e.color),
                    (t.opacity.value = e.opacity),
                    (t.rotation.value = e.rotation),
                    e.map && (t.map.value = e.map),
                    e.alphaMap && (t.alphaMap.value = e.alphaMap),
                    e.map ? (i = e.map) : e.alphaMap && (i = e.alphaMap),
                    void 0 !== i && (!0 === i.matrixAutoUpdate && i.updateMatrix(), t.uvTransform.value.copy(i.matrix))
                })(t, n)
              : n.isShadowMaterial
              ? (t.color.value.copy(n.color), (t.opacity.value = n.opacity))
              : n.isShaderMaterial && (n.uniformsNeedUpdate = !1)
          },
        }
      }
      function Qr(t = {}) {
        const e =
            void 0 !== t.canvas
              ? t.canvas
              : (function () {
                  const t = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas')
                  return (t.style.display = 'block'), t
                })(),
          i = void 0 !== t.context ? t.context : null,
          n = void 0 !== t.alpha && t.alpha,
          s = void 0 === t.depth || t.depth,
          r = void 0 === t.stencil || t.stencil,
          a = void 0 !== t.antialias && t.antialias,
          o = void 0 === t.premultipliedAlpha || t.premultipliedAlpha,
          l = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer,
          c = void 0 !== t.powerPreference ? t.powerPreference : 'default',
          h = void 0 !== t.failIfMajorPerformanceCaveat && t.failIfMajorPerformanceCaveat
        let u = null,
          d = null
        const p = [],
          A = []
        ;(this.domElement = e),
          (this.debug = { checkShaderErrors: !0 }),
          (this.autoClear = !0),
          (this.autoClearColor = !0),
          (this.autoClearDepth = !0),
          (this.autoClearStencil = !0),
          (this.sortObjects = !0),
          (this.clippingPlanes = []),
          (this.localClippingEnabled = !1),
          (this.gammaFactor = 2),
          (this.outputEncoding = 3e3),
          (this.physicallyCorrectLights = !1),
          (this.toneMapping = 0),
          (this.toneMappingExposure = 1)
        const g = this
        let m = !1,
          f = 0,
          v = 0,
          y = null,
          x = -1,
          w = null
        const _ = new _t(),
          I = new _t()
        let C = null,
          M = e.width,
          E = e.height,
          b = 1,
          S = null,
          B = null
        const T = new _t(0, 0, M, E),
          L = new _t(0, 0, M, E)
        let D = !1
        const Q = [],
          R = new qi()
        let P = !1,
          N = !1,
          F = null
        const U = new ne(),
          k = new Et(),
          O = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 }
        function G() {
          return null === y ? b : 1
        }
        let z,
          V,
          H,
          W,
          q,
          j,
          Y,
          J,
          X,
          K,
          Z,
          $,
          tt,
          et,
          it,
          nt,
          st,
          rt,
          at,
          ot,
          lt,
          ct,
          ht,
          ut = i
        function dt(t, i) {
          for (let n = 0; n < t.length; n++) {
            const s = t[n],
              r = e.getContext(s, i)
            if (null !== r) return r
          }
          return null
        }
        try {
          const t = {
            alpha: n,
            depth: s,
            stencil: r,
            antialias: a,
            premultipliedAlpha: o,
            preserveDrawingBuffer: l,
            powerPreference: c,
            failIfMajorPerformanceCaveat: h,
          }
          if (
            (e.addEventListener('webglcontextlost', gt, !1),
            e.addEventListener('webglcontextrestored', mt, !1),
            null === ut)
          ) {
            const e = ['webgl2', 'webgl', 'experimental-webgl']
            if ((!0 === g.isWebGL1Renderer && e.shift(), (ut = dt(e, t)), null === ut))
              throw dt(e)
                ? new Error('Error creating WebGL context with your selected attributes.')
                : new Error('Error creating WebGL context.')
          }
          void 0 === ut.getShaderPrecisionFormat &&
            (ut.getShaderPrecisionFormat = function () {
              return { rangeMin: 1, rangeMax: 1, precision: 1 }
            })
        } catch (t) {
          throw t
        }
        function pt() {
          ;(z = new Ln(ut)),
            (V = new nn(ut, z, t)),
            z.init(V),
            (ct = new Er(ut, z, V)),
            (H = new Cr(ut, z, V)),
            (Q[0] = 1029),
            (W = new Rn(ut)),
            (q = new hr()),
            (j = new Mr(ut, z, H, q, V, ct, W)),
            (Y = new rn(g)),
            (J = new Tn(g)),
            (X = new Yi(ut, V)),
            (ht = new tn(ut, z, X, V)),
            (K = new Dn(ut, X, W, ht)),
            (Z = new Un(ut, K, X, W)),
            (at = new Fn(ut)),
            (nt = new sn(q)),
            ($ = new cr(g, Y, J, z, V, ht, nt)),
            (tt = new Dr(q)),
            (et = new Ar(q)),
            (it = new xr(z, V)),
            (rt = new $i(g, Y, H, Z, o)),
            (st = new Ir(g, Z, V)),
            (ot = new en(ut, z, W, V)),
            (lt = new Qn(ut, z, W, V)),
            (W.programs = $.programs),
            (g.capabilities = V),
            (g.extensions = z),
            (g.properties = q),
            (g.renderLists = et),
            (g.shadowMap = st),
            (g.state = H),
            (g.info = W)
        }
        pt()
        const At = new Lr(g, ut)
        function gt(t) {
          t.preventDefault(), (m = !0)
        }
        function mt() {
          m = !1
          const t = W.autoReset,
            e = st.enabled,
            i = st.autoUpdate,
            n = st.needsUpdate,
            s = st.type
          pt(), (W.autoReset = t), (st.enabled = e), (st.autoUpdate = i), (st.needsUpdate = n), (st.type = s)
        }
        function ft(t) {
          const e = t.target
          e.removeEventListener('dispose', ft),
            (function (t) {
              ;(function (t) {
                const e = q.get(t).programs
                void 0 !== e &&
                  e.forEach(function (t) {
                    $.releaseProgram(t)
                  })
              })(t),
                q.remove(t)
            })(e)
        }
        ;(this.xr = At),
          (this.getContext = function () {
            return ut
          }),
          (this.getContextAttributes = function () {
            return ut.getContextAttributes()
          }),
          (this.forceContextLoss = function () {
            const t = z.get('WEBGL_lose_context')
            t && t.loseContext()
          }),
          (this.forceContextRestore = function () {
            const t = z.get('WEBGL_lose_context')
            t && t.restoreContext()
          }),
          (this.getPixelRatio = function () {
            return b
          }),
          (this.setPixelRatio = function (t) {
            void 0 !== t && ((b = t), this.setSize(M, E, !1))
          }),
          (this.getSize = function (t) {
            return t.set(M, E)
          }),
          (this.setSize = function (t, i, n) {
            At.isPresenting ||
              ((M = t),
              (E = i),
              (e.width = Math.floor(t * b)),
              (e.height = Math.floor(i * b)),
              !1 !== n && ((e.style.width = t + 'px'), (e.style.height = i + 'px')),
              this.setViewport(0, 0, t, i))
          }),
          (this.getDrawingBufferSize = function (t) {
            return t.set(M * b, E * b).floor()
          }),
          (this.setDrawingBufferSize = function (t, i, n) {
            ;(M = t),
              (E = i),
              (b = n),
              (e.width = Math.floor(t * n)),
              (e.height = Math.floor(i * n)),
              this.setViewport(0, 0, t, i)
          }),
          (this.getCurrentViewport = function (t) {
            return t.copy(_)
          }),
          (this.getViewport = function (t) {
            return t.copy(T)
          }),
          (this.setViewport = function (t, e, i, n) {
            t.isVector4 ? T.set(t.x, t.y, t.z, t.w) : T.set(t, e, i, n), H.viewport(_.copy(T).multiplyScalar(b).floor())
          }),
          (this.getScissor = function (t) {
            return t.copy(L)
          }),
          (this.setScissor = function (t, e, i, n) {
            t.isVector4 ? L.set(t.x, t.y, t.z, t.w) : L.set(t, e, i, n), H.scissor(I.copy(L).multiplyScalar(b).floor())
          }),
          (this.getScissorTest = function () {
            return D
          }),
          (this.setScissorTest = function (t) {
            H.setScissorTest((D = t))
          }),
          (this.setOpaqueSort = function (t) {
            S = t
          }),
          (this.setTransparentSort = function (t) {
            B = t
          }),
          (this.getClearColor = function (t) {
            return t.copy(rt.getClearColor())
          }),
          (this.setClearColor = function () {
            rt.setClearColor.apply(rt, arguments)
          }),
          (this.getClearAlpha = function () {
            return rt.getClearAlpha()
          }),
          (this.setClearAlpha = function () {
            rt.setClearAlpha.apply(rt, arguments)
          }),
          (this.clear = function (t, e, i) {
            let n = 0
            ;(void 0 === t || t) && (n |= 16384),
              (void 0 === e || e) && (n |= 256),
              (void 0 === i || i) && (n |= 1024),
              ut.clear(n)
          }),
          (this.clearColor = function () {
            this.clear(!0, !1, !1)
          }),
          (this.clearDepth = function () {
            this.clear(!1, !0, !1)
          }),
          (this.clearStencil = function () {
            this.clear(!1, !1, !0)
          }),
          (this.dispose = function () {
            e.removeEventListener('webglcontextlost', gt, !1),
              e.removeEventListener('webglcontextrestored', mt, !1),
              et.dispose(),
              it.dispose(),
              q.dispose(),
              Y.dispose(),
              J.dispose(),
              Z.dispose(),
              ht.dispose(),
              At.dispose(),
              At.removeEventListener('sessionstart', yt),
              At.removeEventListener('sessionend', xt),
              F && (F.dispose(), (F = null)),
              wt.stop()
          }),
          (this.renderBufferImmediate = function (t, e) {
            ht.initAttributes()
            const i = q.get(t)
            t.hasPositions && !i.position && (i.position = ut.createBuffer()),
              t.hasNormals && !i.normal && (i.normal = ut.createBuffer()),
              t.hasUvs && !i.uv && (i.uv = ut.createBuffer()),
              t.hasColors && !i.color && (i.color = ut.createBuffer())
            const n = e.getAttributes()
            t.hasPositions &&
              (ut.bindBuffer(34962, i.position),
              ut.bufferData(34962, t.positionArray, 35048),
              ht.enableAttribute(n.position),
              ut.vertexAttribPointer(n.position, 3, 5126, !1, 0, 0)),
              t.hasNormals &&
                (ut.bindBuffer(34962, i.normal),
                ut.bufferData(34962, t.normalArray, 35048),
                ht.enableAttribute(n.normal),
                ut.vertexAttribPointer(n.normal, 3, 5126, !1, 0, 0)),
              t.hasUvs &&
                (ut.bindBuffer(34962, i.uv),
                ut.bufferData(34962, t.uvArray, 35048),
                ht.enableAttribute(n.uv),
                ut.vertexAttribPointer(n.uv, 2, 5126, !1, 0, 0)),
              t.hasColors &&
                (ut.bindBuffer(34962, i.color),
                ut.bufferData(34962, t.colorArray, 35048),
                ht.enableAttribute(n.color),
                ut.vertexAttribPointer(n.color, 3, 5126, !1, 0, 0)),
              ht.disableUnusedAttributes(),
              ut.drawArrays(4, 0, t.count),
              (t.count = 0)
          }),
          (this.renderBufferDirect = function (t, e, i, n, s, r) {
            null === e && (e = O)
            const a = s.isMesh && s.matrixWorld.determinant() < 0,
              o = Lt(t, e, n, s)
            H.setMaterial(n, a)
            let l = i.index
            const c = i.attributes.position
            if (null === l) {
              if (void 0 === c || 0 === c.count) return
            } else if (0 === l.count) return
            let h,
              u = 1
            !0 === n.wireframe && ((l = K.getWireframeAttribute(i)), (u = 2)),
              (void 0 === i.morphAttributes.position && void 0 === i.morphAttributes.normal) || at.update(s, i, n, o),
              ht.setup(s, n, o, i, l)
            let d = ot
            null !== l && ((h = X.get(l)), (d = lt), d.setIndex(h))
            const p = null !== l ? l.count : c.count,
              A = i.drawRange.start * u,
              g = i.drawRange.count * u,
              m = null !== r ? r.start * u : 0,
              f = null !== r ? r.count * u : 1 / 0,
              v = Math.max(A, m),
              y = Math.min(p, A + g, m + f) - 1,
              x = Math.max(0, y - v + 1)
            if (0 !== x) {
              if (s.isMesh)
                !0 === n.wireframe ? (H.setLineWidth(n.wireframeLinewidth * G()), d.setMode(1)) : d.setMode(4)
              else if (s.isLine) {
                let t = n.linewidth
                void 0 === t && (t = 1),
                  H.setLineWidth(t * G()),
                  s.isLineSegments ? d.setMode(1) : s.isLineLoop ? d.setMode(2) : d.setMode(3)
              } else s.isPoints ? d.setMode(0) : s.isSprite && d.setMode(4)
              if (s.isInstancedMesh) d.renderInstances(v, x, s.count)
              else if (i.isInstancedBufferGeometry) {
                const t = Math.min(i.instanceCount, i._maxInstanceCount)
                d.renderInstances(v, x, t)
              } else d.render(v, x)
            }
          }),
          (this.compile = function (t, e) {
            ;(d = it.get(t)),
              d.init(),
              A.push(d),
              t.traverseVisible(function (t) {
                t.isLight && t.layers.test(e.layers) && (d.pushLight(t), t.castShadow && d.pushShadow(t))
              }),
              d.setupLights(),
              t.traverse(function (e) {
                const i = e.material
                if (i)
                  if (Array.isArray(i)) for (let n = 0; n < i.length; n++) Bt(i[n], t, e)
                  else Bt(i, t, e)
              }),
              A.pop(),
              (d = null)
          })
        let vt = null
        function yt() {
          wt.stop()
        }
        function xt() {
          wt.start()
        }
        const wt = new ji()
        function Mt(t, e, i, n) {
          if (!1 === t.visible) return
          if (t.layers.test(e.layers))
            if (t.isGroup) i = t.renderOrder
            else if (t.isLOD) !0 === t.autoUpdate && t.update(e)
            else if (t.isLight) d.pushLight(t), t.castShadow && d.pushShadow(t)
            else if (t.isSprite) {
              if (!t.frustumCulled || R.intersectsSprite(t)) {
                n && k.setFromMatrixPosition(t.matrixWorld).applyMatrix4(U)
                const e = Z.update(t),
                  s = t.material
                s.visible && u.push(t, e, s, i, k.z, null)
              }
            } else if (t.isImmediateRenderObject)
              n && k.setFromMatrixPosition(t.matrixWorld).applyMatrix4(U), u.push(t, null, t.material, i, k.z, null)
            else if (
              (t.isMesh || t.isLine || t.isPoints) &&
              (t.isSkinnedMesh &&
                t.skeleton.frame !== W.render.frame &&
                (t.skeleton.update(), (t.skeleton.frame = W.render.frame)),
              !t.frustumCulled || R.intersectsObject(t))
            ) {
              n && k.setFromMatrixPosition(t.matrixWorld).applyMatrix4(U)
              const e = Z.update(t),
                s = t.material
              if (Array.isArray(s)) {
                const n = e.groups
                for (let r = 0, a = n.length; r < a; r++) {
                  const a = n[r],
                    o = s[a.materialIndex]
                  o && o.visible && u.push(t, e, o, i, k.z, a)
                }
              } else s.visible && u.push(t, e, s, i, k.z, null)
            }
          const s = t.children
          for (let r = 0, a = s.length; r < a; r++) Mt(s[r], e, i, n)
        }
        function bt(t, e, i) {
          const n = !0 === e.isScene ? e.overrideMaterial : null
          if (i.isArrayCamera) {
            const s = i.cameras
            for (let i = 0, r = s.length; i < r; i++) {
              const r = s[i]
              H.viewport(_.copy(r.viewport)), d.setupLightsView(r)
              for (let i = 0, s = t.length; i < s; i++) {
                const s = t[i],
                  a = s.object,
                  o = s.geometry,
                  l = null === n ? s.material : n,
                  c = s.group
                a.layers.test(r.layers) && St(a, e, r, o, l, c)
              }
            }
          } else
            for (let s = 0, r = t.length; s < r; s++) {
              const r = t[s]
              St(r.object, e, i, r.geometry, null === n ? r.material : n, r.group)
            }
        }
        function St(t, e, i, n, s, r) {
          if (
            (t.onBeforeRender(g, e, i, n, s, r),
            t.modelViewMatrix.multiplyMatrices(i.matrixWorldInverse, t.matrixWorld),
            t.normalMatrix.getNormalMatrix(t.modelViewMatrix),
            t.isImmediateRenderObject)
          ) {
            const n = Lt(i, e, s, t)
            H.setMaterial(s),
              ht.reset(),
              (function (t, e) {
                t.render(function (t) {
                  g.renderBufferImmediate(t, e)
                })
              })(t, n)
          } else
            !0 === s.transparent && 2 === s.side
              ? ((s.side = 1),
                (s.needsUpdate = !0),
                g.renderBufferDirect(i, e, n, s, t, r),
                (s.side = 0),
                (s.needsUpdate = !0),
                g.renderBufferDirect(i, e, n, s, t, r),
                (s.side = 2))
              : g.renderBufferDirect(i, e, n, s, t, r)
          t.onAfterRender(g, e, i, n, s, r)
        }
        function Bt(t, e, i) {
          !0 !== e.isScene && (e = O)
          const n = q.get(t),
            s = d.state.lights,
            r = d.state.shadowsArray,
            a = s.state.version,
            o = $.getParameters(t, s.state, r, e, i),
            l = $.getProgramCacheKey(o)
          let c = n.programs
          ;(n.environment = t.isMeshStandardMaterial ? e.environment : null),
            (n.fog = e.fog),
            (n.envMap = (t.isMeshStandardMaterial ? J : Y).get(t.envMap || n.environment)),
            void 0 === c && (t.addEventListener('dispose', ft), (c = new Map()), (n.programs = c))
          let h = c.get(l)
          if (void 0 !== h) {
            if (n.currentProgram === h && n.lightsStateVersion === a) return Tt(t, o), h
          } else
            (o.uniforms = $.getUniforms(t)),
              t.onBuild(o, g),
              t.onBeforeCompile(o, g),
              (h = $.acquireProgram(o, l)),
              c.set(l, h),
              (n.uniforms = o.uniforms)
          const u = n.uniforms
          ;((t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping) || (u.clippingPlanes = nt.uniform),
            Tt(t, o),
            (n.needsLights = (function (t) {
              return (
                t.isMeshLambertMaterial ||
                t.isMeshToonMaterial ||
                t.isMeshPhongMaterial ||
                t.isMeshStandardMaterial ||
                t.isShadowMaterial ||
                (t.isShaderMaterial && !0 === t.lights)
              )
            })(t)),
            (n.lightsStateVersion = a),
            n.needsLights &&
              ((u.ambientLightColor.value = s.state.ambient),
              (u.lightProbe.value = s.state.probe),
              (u.directionalLights.value = s.state.directional),
              (u.directionalLightShadows.value = s.state.directionalShadow),
              (u.spotLights.value = s.state.spot),
              (u.spotLightShadows.value = s.state.spotShadow),
              (u.rectAreaLights.value = s.state.rectArea),
              (u.ltc_1.value = s.state.rectAreaLTC1),
              (u.ltc_2.value = s.state.rectAreaLTC2),
              (u.pointLights.value = s.state.point),
              (u.pointLightShadows.value = s.state.pointShadow),
              (u.hemisphereLights.value = s.state.hemi),
              (u.directionalShadowMap.value = s.state.directionalShadowMap),
              (u.directionalShadowMatrix.value = s.state.directionalShadowMatrix),
              (u.spotShadowMap.value = s.state.spotShadowMap),
              (u.spotShadowMatrix.value = s.state.spotShadowMatrix),
              (u.pointShadowMap.value = s.state.pointShadowMap),
              (u.pointShadowMatrix.value = s.state.pointShadowMatrix))
          const p = h.getUniforms(),
            A = zs.seqWithValue(p.seq, u)
          return (n.currentProgram = h), (n.uniformsList = A), h
        }
        function Tt(t, e) {
          const i = q.get(t)
          ;(i.outputEncoding = e.outputEncoding),
            (i.instancing = e.instancing),
            (i.skinning = e.skinning),
            (i.morphTargets = e.morphTargets),
            (i.morphNormals = e.morphNormals),
            (i.numClippingPlanes = e.numClippingPlanes),
            (i.numIntersection = e.numClipIntersection),
            (i.vertexAlphas = e.vertexAlphas),
            (i.vertexTangents = e.vertexTangents)
        }
        function Lt(t, e, i, n) {
          !0 !== e.isScene && (e = O), j.resetTextureUnits()
          const s = e.fog,
            r = i.isMeshStandardMaterial ? e.environment : null,
            a = null === y ? g.outputEncoding : y.texture.encoding,
            o = (i.isMeshStandardMaterial ? J : Y).get(i.envMap || r),
            l =
              !0 === i.vertexColors &&
              !!n.geometry &&
              !!n.geometry.attributes.color &&
              4 === n.geometry.attributes.color.itemSize,
            c = !!n.geometry && !!n.geometry.attributes.tangent,
            h = !!n.geometry && !!n.geometry.morphAttributes.position,
            u = !!n.geometry && !!n.geometry.morphAttributes.normal,
            p = q.get(i),
            A = d.state.lights
          if (!0 === P && (!0 === N || t !== w)) {
            const e = t === w && i.id === x
            nt.setState(i, t, e)
          }
          let m = !1
          i.version === p.__version
            ? (p.needsLights && p.lightsStateVersion !== A.state.version) ||
              p.outputEncoding !== a ||
              (n.isInstancedMesh && !1 === p.instancing)
              ? (m = !0)
              : n.isInstancedMesh || !0 !== p.instancing
              ? n.isSkinnedMesh && !1 === p.skinning
                ? (m = !0)
                : n.isSkinnedMesh || !0 !== p.skinning
                ? p.envMap !== o || (i.fog && p.fog !== s)
                  ? (m = !0)
                  : void 0 === p.numClippingPlanes ||
                    (p.numClippingPlanes === nt.numPlanes && p.numIntersection === nt.numIntersection)
                  ? (p.vertexAlphas !== l || p.vertexTangents !== c || p.morphTargets !== h || p.morphNormals !== u) &&
                    (m = !0)
                  : (m = !0)
                : (m = !0)
              : (m = !0)
            : ((m = !0), (p.__version = i.version))
          let f = p.currentProgram
          !0 === m && (f = Bt(i, e, n))
          let v = !1,
            _ = !1,
            I = !1
          const C = f.getUniforms(),
            M = p.uniforms
          if (
            (H.useProgram(f.program) && ((v = !0), (_ = !0), (I = !0)),
            i.id !== x && ((x = i.id), (_ = !0)),
            v || w !== t)
          ) {
            if (
              (C.setValue(ut, 'projectionMatrix', t.projectionMatrix),
              V.logarithmicDepthBuffer && C.setValue(ut, 'logDepthBufFC', 2 / (Math.log(t.far + 1) / Math.LN2)),
              w !== t && ((w = t), (_ = !0), (I = !0)),
              i.isShaderMaterial ||
                i.isMeshPhongMaterial ||
                i.isMeshToonMaterial ||
                i.isMeshStandardMaterial ||
                i.envMap)
            ) {
              const e = C.map.cameraPosition
              void 0 !== e && e.setValue(ut, k.setFromMatrixPosition(t.matrixWorld))
            }
            ;(i.isMeshPhongMaterial ||
              i.isMeshToonMaterial ||
              i.isMeshLambertMaterial ||
              i.isMeshBasicMaterial ||
              i.isMeshStandardMaterial ||
              i.isShaderMaterial) &&
              C.setValue(ut, 'isOrthographic', !0 === t.isOrthographicCamera),
              (i.isMeshPhongMaterial ||
                i.isMeshToonMaterial ||
                i.isMeshLambertMaterial ||
                i.isMeshBasicMaterial ||
                i.isMeshStandardMaterial ||
                i.isShaderMaterial ||
                i.isShadowMaterial ||
                n.isSkinnedMesh) &&
                C.setValue(ut, 'viewMatrix', t.matrixWorldInverse)
          }
          if (n.isSkinnedMesh) {
            C.setOptional(ut, n, 'bindMatrix'), C.setOptional(ut, n, 'bindMatrixInverse')
            const t = n.skeleton
            t &&
              (V.floatVertexTextures
                ? (null === t.boneTexture && t.computeBoneTexture(),
                  C.setValue(ut, 'boneTexture', t.boneTexture, j),
                  C.setValue(ut, 'boneTextureSize', t.boneTextureSize))
                : C.setOptional(ut, t, 'boneMatrices'))
          }
          var S, B
          return (
            (_ || p.receiveShadow !== n.receiveShadow) &&
              ((p.receiveShadow = n.receiveShadow), C.setValue(ut, 'receiveShadow', n.receiveShadow)),
            _ &&
              (C.setValue(ut, 'toneMappingExposure', g.toneMappingExposure),
              p.needsLights &&
                ((B = I),
                ((S = M).ambientLightColor.needsUpdate = B),
                (S.lightProbe.needsUpdate = B),
                (S.directionalLights.needsUpdate = B),
                (S.directionalLightShadows.needsUpdate = B),
                (S.pointLights.needsUpdate = B),
                (S.pointLightShadows.needsUpdate = B),
                (S.spotLights.needsUpdate = B),
                (S.spotLightShadows.needsUpdate = B),
                (S.rectAreaLights.needsUpdate = B),
                (S.hemisphereLights.needsUpdate = B)),
              s && i.fog && tt.refreshFogUniforms(M, s),
              tt.refreshMaterialUniforms(M, i, b, E, F),
              zs.upload(ut, p.uniformsList, M, j)),
            i.isShaderMaterial &&
              !0 === i.uniformsNeedUpdate &&
              (zs.upload(ut, p.uniformsList, M, j), (i.uniformsNeedUpdate = !1)),
            i.isSpriteMaterial && C.setValue(ut, 'center', n.center),
            C.setValue(ut, 'modelViewMatrix', n.modelViewMatrix),
            C.setValue(ut, 'normalMatrix', n.normalMatrix),
            C.setValue(ut, 'modelMatrix', n.matrixWorld),
            f
          )
        }
        wt.setAnimationLoop(function (t) {
          vt && vt(t)
        }),
          'undefined' != typeof window && wt.setContext(window),
          (this.setAnimationLoop = function (t) {
            ;(vt = t), At.setAnimationLoop(t), null === t ? wt.stop() : wt.start()
          }),
          At.addEventListener('sessionstart', yt),
          At.addEventListener('sessionend', xt),
          (this.render = function (t, e) {
            if (void 0 !== e && !0 !== e.isCamera) return
            if (!0 === m) return
            !0 === t.autoUpdate && t.updateMatrixWorld(),
              null === e.parent && e.updateMatrixWorld(),
              !0 === At.enabled &&
                !0 === At.isPresenting &&
                (!0 === At.cameraAutoUpdate && At.updateCamera(e), (e = At.getCamera())),
              !0 === t.isScene && t.onBeforeRender(g, t, e, y),
              (d = it.get(t, A.length)),
              d.init(),
              A.push(d),
              U.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
              R.setFromProjectionMatrix(U),
              (N = this.localClippingEnabled),
              (P = nt.init(this.clippingPlanes, N, e)),
              (u = et.get(t, p.length)),
              u.init(),
              p.push(u),
              Mt(t, e, 0, g.sortObjects),
              u.finish(),
              !0 === g.sortObjects && u.sort(S, B),
              !0 === P && nt.beginShadows()
            const i = d.state.shadowsArray
            st.render(i, t, e),
              d.setupLights(),
              d.setupLightsView(e),
              !0 === P && nt.endShadows(),
              !0 === this.info.autoReset && this.info.reset(),
              rt.render(u, t)
            const n = u.opaque,
              s = u.transmissive,
              r = u.transparent
            n.length > 0 && bt(n, t, e),
              s.length > 0 &&
                (function (t, e, i, n) {
                  if (null === F) {
                    const t = !0 === a && !0 === V.isWebGL2
                    F = new (t ? Ct : It)(1024, 1024, {
                      generateMipmaps: !0,
                      type: null !== ct.convert(1016) ? 1016 : 1009,
                      minFilter: 1008,
                      magFilter: 1003,
                      wrapS: 1001,
                      wrapT: 1001,
                    })
                  }
                  const s = g.getRenderTarget()
                  g.setRenderTarget(F), g.clear()
                  const r = g.toneMapping
                  ;(g.toneMapping = 0),
                    bt(t, i, n),
                    (g.toneMapping = r),
                    j.updateMultisampleRenderTarget(F),
                    j.updateRenderTargetMipmap(F),
                    g.setRenderTarget(s),
                    bt(e, i, n)
                })(n, s, t, e),
              r.length > 0 && bt(r, t, e),
              null !== y && (j.updateMultisampleRenderTarget(y), j.updateRenderTargetMipmap(y)),
              !0 === t.isScene && t.onAfterRender(g, t, e),
              H.buffers.depth.setTest(!0),
              H.buffers.depth.setMask(!0),
              H.buffers.color.setMask(!0),
              H.setPolygonOffset(!1),
              ht.resetDefaultState(),
              (x = -1),
              (w = null),
              A.pop(),
              (d = A.length > 0 ? A[A.length - 1] : null),
              p.pop(),
              (u = p.length > 0 ? p[p.length - 1] : null)
          }),
          (this.getActiveCubeFace = function () {
            return f
          }),
          (this.getActiveMipmapLevel = function () {
            return v
          }),
          (this.getRenderTarget = function () {
            return y
          }),
          (this.setRenderTarget = function (t, e = 0, i = 0) {
            ;(y = t), (f = e), (v = i), t && void 0 === q.get(t).__webglFramebuffer && j.setupRenderTarget(t)
            let n = null,
              s = !1,
              r = !1
            if (t) {
              const i = t.texture
              ;(i.isDataTexture3D || i.isDataTexture2DArray) && (r = !0)
              const a = q.get(t).__webglFramebuffer
              t.isWebGLCubeRenderTarget
                ? ((n = a[e]), (s = !0))
                : (n = t.isWebGLMultisampleRenderTarget ? q.get(t).__webglMultisampledFramebuffer : a),
                _.copy(t.viewport),
                I.copy(t.scissor),
                (C = t.scissorTest)
            } else _.copy(T).multiplyScalar(b).floor(), I.copy(L).multiplyScalar(b).floor(), (C = D)
            if (H.bindFramebuffer(36160, n) && V.drawBuffers) {
              let e = !1
              if (t)
                if (t.isWebGLMultipleRenderTargets) {
                  const i = t.texture
                  if (Q.length !== i.length || 36064 !== Q[0]) {
                    for (let t = 0, e = i.length; t < e; t++) Q[t] = 36064 + t
                    ;(Q.length = i.length), (e = !0)
                  }
                } else (1 === Q.length && 36064 === Q[0]) || ((Q[0] = 36064), (Q.length = 1), (e = !0))
              else (1 === Q.length && 1029 === Q[0]) || ((Q[0] = 1029), (Q.length = 1), (e = !0))
              e && (V.isWebGL2 ? ut.drawBuffers(Q) : z.get('WEBGL_draw_buffers').drawBuffersWEBGL(Q))
            }
            if ((H.viewport(_), H.scissor(I), H.setScissorTest(C), s)) {
              const n = q.get(t.texture)
              ut.framebufferTexture2D(36160, 36064, 34069 + e, n.__webglTexture, i)
            } else if (r) {
              const n = q.get(t.texture),
                s = e || 0
              ut.framebufferTextureLayer(36160, 36064, n.__webglTexture, i || 0, s)
            }
          }),
          (this.readRenderTargetPixels = function (t, e, i, n, s, r, a) {
            if (!t || !t.isWebGLRenderTarget) return
            let o = q.get(t).__webglFramebuffer
            if ((t.isWebGLCubeRenderTarget && void 0 !== a && (o = o[a]), o)) {
              H.bindFramebuffer(36160, o)
              try {
                const a = t.texture,
                  o = a.format,
                  l = a.type
                if (1023 !== o && ct.convert(o) !== ut.getParameter(35739)) return
                const c =
                  1016 === l &&
                  (z.has('EXT_color_buffer_half_float') || (V.isWebGL2 && z.has('EXT_color_buffer_float')))
                if (
                  !(
                    1009 === l ||
                    ct.convert(l) === ut.getParameter(35738) ||
                    (1015 === l && (V.isWebGL2 || z.has('OES_texture_float') || z.has('WEBGL_color_buffer_float'))) ||
                    c
                  )
                )
                  return
                36053 === ut.checkFramebufferStatus(36160) &&
                  e >= 0 &&
                  e <= t.width - n &&
                  i >= 0 &&
                  i <= t.height - s &&
                  ut.readPixels(e, i, n, s, ct.convert(o), ct.convert(l), r)
              } finally {
                const t = null !== y ? q.get(y).__webglFramebuffer : null
                H.bindFramebuffer(36160, t)
              }
            }
          }),
          (this.copyFramebufferToTexture = function (t, e, i = 0) {
            const n = Math.pow(2, -i),
              s = Math.floor(e.image.width * n),
              r = Math.floor(e.image.height * n)
            let a = ct.convert(e.format)
            V.isWebGL2 && (6407 === a && (a = 32849), 6408 === a && (a = 32856)),
              j.setTexture2D(e, 0),
              ut.copyTexImage2D(3553, i, a, t.x, t.y, s, r, 0),
              H.unbindTexture()
          }),
          (this.copyTextureToTexture = function (t, e, i, n = 0) {
            const s = e.image.width,
              r = e.image.height,
              a = ct.convert(i.format),
              o = ct.convert(i.type)
            j.setTexture2D(i, 0),
              ut.pixelStorei(37440, i.flipY),
              ut.pixelStorei(37441, i.premultiplyAlpha),
              ut.pixelStorei(3317, i.unpackAlignment),
              e.isDataTexture
                ? ut.texSubImage2D(3553, n, t.x, t.y, s, r, a, o, e.image.data)
                : e.isCompressedTexture
                ? ut.compressedTexSubImage2D(
                    3553,
                    n,
                    t.x,
                    t.y,
                    e.mipmaps[0].width,
                    e.mipmaps[0].height,
                    a,
                    e.mipmaps[0].data,
                  )
                : ut.texSubImage2D(3553, n, t.x, t.y, a, o, e.image),
              0 === n && i.generateMipmaps && ut.generateMipmap(3553),
              H.unbindTexture()
          }),
          (this.copyTextureToTexture3D = function (t, e, i, n, s = 0) {
            if (g.isWebGL1Renderer) return
            const r = t.max.x - t.min.x + 1,
              a = t.max.y - t.min.y + 1,
              o = t.max.z - t.min.z + 1,
              l = ct.convert(n.format),
              c = ct.convert(n.type)
            let h
            if (n.isDataTexture3D) j.setTexture3D(n, 0), (h = 32879)
            else {
              if (!n.isDataTexture2DArray) return
              j.setTexture2DArray(n, 0), (h = 35866)
            }
            ut.pixelStorei(37440, n.flipY),
              ut.pixelStorei(37441, n.premultiplyAlpha),
              ut.pixelStorei(3317, n.unpackAlignment)
            const u = ut.getParameter(3314),
              d = ut.getParameter(32878),
              p = ut.getParameter(3316),
              A = ut.getParameter(3315),
              m = ut.getParameter(32877),
              f = i.isCompressedTexture ? i.mipmaps[0] : i.image
            ut.pixelStorei(3314, f.width),
              ut.pixelStorei(32878, f.height),
              ut.pixelStorei(3316, t.min.x),
              ut.pixelStorei(3315, t.min.y),
              ut.pixelStorei(32877, t.min.z),
              i.isDataTexture || i.isDataTexture3D
                ? ut.texSubImage3D(h, s, e.x, e.y, e.z, r, a, o, l, c, f.data)
                : i.isCompressedTexture
                ? ut.compressedTexSubImage3D(h, s, e.x, e.y, e.z, r, a, o, l, f.data)
                : ut.texSubImage3D(h, s, e.x, e.y, e.z, r, a, o, l, c, f),
              ut.pixelStorei(3314, u),
              ut.pixelStorei(32878, d),
              ut.pixelStorei(3316, p),
              ut.pixelStorei(3315, A),
              ut.pixelStorei(32877, m),
              0 === s && n.generateMipmaps && ut.generateMipmap(h),
              H.unbindTexture()
          }),
          (this.initTexture = function (t) {
            j.setTexture2D(t, 0), H.unbindTexture()
          }),
          (this.resetState = function () {
            ;(f = 0), (v = 0), (y = null), H.reset(), ht.reset()
          }),
          'undefined' != typeof __THREE_DEVTOOLS__ &&
            __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', { detail: this }))
      }
      ;(class extends Qr {}.prototype.isWebGL1Renderer = !0)
      class Rr extends Se {
        constructor() {
          super(),
            (this.type = 'Scene'),
            (this.background = null),
            (this.environment = null),
            (this.fog = null),
            (this.overrideMaterial = null),
            (this.autoUpdate = !0),
            'undefined' != typeof __THREE_DEVTOOLS__ &&
              __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', { detail: this }))
        }
        copy(t, e) {
          return (
            super.copy(t, e),
            null !== t.background && (this.background = t.background.clone()),
            null !== t.environment && (this.environment = t.environment.clone()),
            null !== t.fog && (this.fog = t.fog.clone()),
            null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()),
            (this.autoUpdate = t.autoUpdate),
            (this.matrixAutoUpdate = t.matrixAutoUpdate),
            this
          )
        }
        toJSON(t) {
          const e = super.toJSON(t)
          return null !== this.fog && (e.object.fog = this.fog.toJSON()), e
        }
      }
      Rr.prototype.isScene = !0
      class Pr {
        constructor(t, e) {
          ;(this.array = t),
            (this.stride = e),
            (this.count = void 0 !== t ? t.length / e : 0),
            (this.usage = 35044),
            (this.updateRange = { offset: 0, count: -1 }),
            (this.version = 0),
            (this.uuid = ot())
        }
        onUploadCallback() {}
        set needsUpdate(t) {
          !0 === t && this.version++
        }
        setUsage(t) {
          return (this.usage = t), this
        }
        copy(t) {
          return (
            (this.array = new t.array.constructor(t.array)),
            (this.count = t.count),
            (this.stride = t.stride),
            (this.usage = t.usage),
            this
          )
        }
        copyAt(t, e, i) {
          ;(t *= this.stride), (i *= e.stride)
          for (let n = 0, s = this.stride; n < s; n++) this.array[t + n] = e.array[i + n]
          return this
        }
        set(t, e = 0) {
          return this.array.set(t, e), this
        }
        clone(t) {
          void 0 === t.arrayBuffers && (t.arrayBuffers = {}),
            void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = ot()),
            void 0 === t.arrayBuffers[this.array.buffer._uuid] &&
              (t.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer)
          const e = new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]),
            i = new this.constructor(e, this.stride)
          return i.setUsage(this.usage), i
        }
        onUpload(t) {
          return (this.onUploadCallback = t), this
        }
        toJSON(t) {
          return (
            void 0 === t.arrayBuffers && (t.arrayBuffers = {}),
            void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = ot()),
            void 0 === t.arrayBuffers[this.array.buffer._uuid] &&
              (t.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(
                new Uint32Array(this.array.buffer),
              )),
            { uuid: this.uuid, buffer: this.array.buffer._uuid, type: this.array.constructor.name, stride: this.stride }
          )
        }
      }
      Pr.prototype.isInterleavedBuffer = !0
      const Nr = new Et()
      class Fr {
        constructor(t, e, i, n = !1) {
          ;(this.name = ''), (this.data = t), (this.itemSize = e), (this.offset = i), (this.normalized = !0 === n)
        }
        get count() {
          return this.data.count
        }
        get array() {
          return this.data.array
        }
        set needsUpdate(t) {
          this.data.needsUpdate = t
        }
        applyMatrix4(t) {
          for (let e = 0, i = this.data.count; e < i; e++)
            (Nr.x = this.getX(e)),
              (Nr.y = this.getY(e)),
              (Nr.z = this.getZ(e)),
              Nr.applyMatrix4(t),
              this.setXYZ(e, Nr.x, Nr.y, Nr.z)
          return this
        }
        applyNormalMatrix(t) {
          for (let e = 0, i = this.count; e < i; e++)
            (Nr.x = this.getX(e)),
              (Nr.y = this.getY(e)),
              (Nr.z = this.getZ(e)),
              Nr.applyNormalMatrix(t),
              this.setXYZ(e, Nr.x, Nr.y, Nr.z)
          return this
        }
        transformDirection(t) {
          for (let e = 0, i = this.count; e < i; e++)
            (Nr.x = this.getX(e)),
              (Nr.y = this.getY(e)),
              (Nr.z = this.getZ(e)),
              Nr.transformDirection(t),
              this.setXYZ(e, Nr.x, Nr.y, Nr.z)
          return this
        }
        setX(t, e) {
          return (this.data.array[t * this.data.stride + this.offset] = e), this
        }
        setY(t, e) {
          return (this.data.array[t * this.data.stride + this.offset + 1] = e), this
        }
        setZ(t, e) {
          return (this.data.array[t * this.data.stride + this.offset + 2] = e), this
        }
        setW(t, e) {
          return (this.data.array[t * this.data.stride + this.offset + 3] = e), this
        }
        getX(t) {
          return this.data.array[t * this.data.stride + this.offset]
        }
        getY(t) {
          return this.data.array[t * this.data.stride + this.offset + 1]
        }
        getZ(t) {
          return this.data.array[t * this.data.stride + this.offset + 2]
        }
        getW(t) {
          return this.data.array[t * this.data.stride + this.offset + 3]
        }
        setXY(t, e, i) {
          return (
            (t = t * this.data.stride + this.offset), (this.data.array[t + 0] = e), (this.data.array[t + 1] = i), this
          )
        }
        setXYZ(t, e, i, n) {
          return (
            (t = t * this.data.stride + this.offset),
            (this.data.array[t + 0] = e),
            (this.data.array[t + 1] = i),
            (this.data.array[t + 2] = n),
            this
          )
        }
        setXYZW(t, e, i, n, s) {
          return (
            (t = t * this.data.stride + this.offset),
            (this.data.array[t + 0] = e),
            (this.data.array[t + 1] = i),
            (this.data.array[t + 2] = n),
            (this.data.array[t + 3] = s),
            this
          )
        }
        clone(t) {
          if (void 0 === t) {
            const t = []
            for (let e = 0; e < this.count; e++) {
              const i = e * this.data.stride + this.offset
              for (let e = 0; e < this.itemSize; e++) t.push(this.data.array[i + e])
            }
            return new Ze(new this.array.constructor(t), this.itemSize, this.normalized)
          }
          return (
            void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}),
            void 0 === t.interleavedBuffers[this.data.uuid] &&
              (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)),
            new Fr(t.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized)
          )
        }
        toJSON(t) {
          if (void 0 === t) {
            const t = []
            for (let e = 0; e < this.count; e++) {
              const i = e * this.data.stride + this.offset
              for (let e = 0; e < this.itemSize; e++) t.push(this.data.array[i + e])
            }
            return { itemSize: this.itemSize, type: this.array.constructor.name, array: t, normalized: this.normalized }
          }
          return (
            void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}),
            void 0 === t.interleavedBuffers[this.data.uuid] &&
              (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)),
            {
              isInterleavedBufferAttribute: !0,
              itemSize: this.itemSize,
              data: this.data.uuid,
              offset: this.offset,
              normalized: this.normalized,
            }
          )
        }
      }
      Fr.prototype.isInterleavedBufferAttribute = !0
      class Ur extends Ge {
        constructor(t) {
          super(),
            (this.type = 'SpriteMaterial'),
            (this.color = new Ye(16777215)),
            (this.map = null),
            (this.alphaMap = null),
            (this.rotation = 0),
            (this.sizeAttenuation = !0),
            (this.transparent = !0),
            this.setValues(t)
        }
        copy(t) {
          return (
            super.copy(t),
            this.color.copy(t.color),
            (this.map = t.map),
            (this.alphaMap = t.alphaMap),
            (this.rotation = t.rotation),
            (this.sizeAttenuation = t.sizeAttenuation),
            this
          )
        }
      }
      let kr
      Ur.prototype.isSpriteMaterial = !0
      const Or = new Et(),
        Gr = new Et(),
        zr = new Et(),
        Vr = new gt(),
        Hr = new gt(),
        Wr = new ne(),
        qr = new Et(),
        jr = new Et(),
        Yr = new Et(),
        Jr = new gt(),
        Xr = new gt(),
        Kr = new gt()
      function Zr(t, e, i, n, s, r) {
        Vr.subVectors(t, i).addScalar(0.5).multiply(n),
          void 0 !== s ? ((Hr.x = r * Vr.x - s * Vr.y), (Hr.y = s * Vr.x + r * Vr.y)) : Hr.copy(Vr),
          t.copy(e),
          (t.x += Hr.x),
          (t.y += Hr.y),
          t.applyMatrix4(Wr)
      }
      ;(class extends Se {
        constructor(t) {
          if ((super(), (this.type = 'Sprite'), void 0 === kr)) {
            kr = new hi()
            const t = new Float32Array([
                -0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5, 0, 0, 1,
              ]),
              e = new Pr(t, 5)
            kr.setIndex([0, 1, 2, 0, 2, 3]),
              kr.setAttribute('position', new Fr(e, 3, 0, !1)),
              kr.setAttribute('uv', new Fr(e, 2, 3, !1))
          }
          ;(this.geometry = kr), (this.material = void 0 !== t ? t : new Ur()), (this.center = new gt(0.5, 0.5))
        }
        raycast(t, e) {
          t.camera,
            Gr.setFromMatrixScale(this.matrixWorld),
            Wr.copy(t.camera.matrixWorld),
            this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse, this.matrixWorld),
            zr.setFromMatrixPosition(this.modelViewMatrix),
            t.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && Gr.multiplyScalar(-zr.z)
          const i = this.material.rotation
          let n, s
          0 !== i && ((s = Math.cos(i)), (n = Math.sin(i)))
          const r = this.center
          Zr(qr.set(-0.5, -0.5, 0), zr, r, Gr, n, s),
            Zr(jr.set(0.5, -0.5, 0), zr, r, Gr, n, s),
            Zr(Yr.set(0.5, 0.5, 0), zr, r, Gr, n, s),
            Jr.set(0, 0),
            Xr.set(1, 0),
            Kr.set(1, 1)
          let a = t.ray.intersectTriangle(qr, jr, Yr, !1, Or)
          if (
            null === a &&
            (Zr(jr.set(-0.5, 0.5, 0), zr, r, Gr, n, s),
            Xr.set(0, 1),
            (a = t.ray.intersectTriangle(qr, Yr, jr, !1, Or)),
            null === a)
          )
            return
          const o = t.ray.origin.distanceTo(Or)
          o < t.near ||
            o > t.far ||
            e.push({
              distance: o,
              point: Or.clone(),
              uv: ke.getUV(Or, qr, jr, Yr, Jr, Xr, Kr, new gt()),
              face: null,
              object: this,
            })
        }
        copy(t) {
          return super.copy(t), void 0 !== t.center && this.center.copy(t.center), (this.material = t.material), this
        }
      }.prototype.isSprite = !0)
      const $r = new Et(),
        ta = new _t(),
        ea = new _t(),
        ia = new Et(),
        na = new ne()
      class sa extends Si {
        constructor(t, e) {
          super(t, e),
            (this.type = 'SkinnedMesh'),
            (this.bindMode = 'attached'),
            (this.bindMatrix = new ne()),
            (this.bindMatrixInverse = new ne())
        }
        copy(t) {
          return (
            super.copy(t),
            (this.bindMode = t.bindMode),
            this.bindMatrix.copy(t.bindMatrix),
            this.bindMatrixInverse.copy(t.bindMatrixInverse),
            (this.skeleton = t.skeleton),
            this
          )
        }
        bind(t, e) {
          ;(this.skeleton = t),
            void 0 === e && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), (e = this.matrixWorld)),
            this.bindMatrix.copy(e),
            this.bindMatrixInverse.copy(e).invert()
        }
        pose() {
          this.skeleton.pose()
        }
        normalizeSkinWeights() {
          const t = new _t(),
            e = this.geometry.attributes.skinWeight
          for (let i = 0, n = e.count; i < n; i++) {
            ;(t.x = e.getX(i)), (t.y = e.getY(i)), (t.z = e.getZ(i)), (t.w = e.getW(i))
            const n = 1 / t.manhattanLength()
            n !== 1 / 0 ? t.multiplyScalar(n) : t.set(1, 0, 0, 0), e.setXYZW(i, t.x, t.y, t.z, t.w)
          }
        }
        updateMatrixWorld(t) {
          super.updateMatrixWorld(t),
            'attached' === this.bindMode
              ? this.bindMatrixInverse.copy(this.matrixWorld).invert()
              : 'detached' === this.bindMode && this.bindMatrixInverse.copy(this.bindMatrix).invert()
        }
        boneTransform(t, e) {
          const i = this.skeleton,
            n = this.geometry
          ta.fromBufferAttribute(n.attributes.skinIndex, t),
            ea.fromBufferAttribute(n.attributes.skinWeight, t),
            $r.fromBufferAttribute(n.attributes.position, t).applyMatrix4(this.bindMatrix),
            e.set(0, 0, 0)
          for (let s = 0; s < 4; s++) {
            const t = ea.getComponent(s)
            if (0 !== t) {
              const n = ta.getComponent(s)
              na.multiplyMatrices(i.bones[n].matrixWorld, i.boneInverses[n]),
                e.addScaledVector(ia.copy($r).applyMatrix4(na), t)
            }
          }
          return e.applyMatrix4(this.bindMatrixInverse)
        }
      }
      sa.prototype.isSkinnedMesh = !0
      class ra extends Se {
        constructor() {
          super(), (this.type = 'Bone')
        }
      }
      ra.prototype.isBone = !0
      class aa extends xt {
        constructor(t = null, e = 1, i = 1, n, s, r, a, o, l = 1003, c = 1003, h, u) {
          super(null, r, a, o, l, c, n, s, h, u),
            (this.image = { data: t, width: e, height: i }),
            (this.magFilter = l),
            (this.minFilter = c),
            (this.generateMipmaps = !1),
            (this.flipY = !1),
            (this.unpackAlignment = 1),
            (this.needsUpdate = !0)
        }
      }
      aa.prototype.isDataTexture = !0
      const oa = new ne(),
        la = new ne()
      class ca {
        constructor(t = [], e = []) {
          ;(this.uuid = ot()),
            (this.bones = t.slice(0)),
            (this.boneInverses = e),
            (this.boneMatrices = null),
            (this.boneTexture = null),
            (this.boneTextureSize = 0),
            (this.frame = -1),
            this.init()
        }
        init() {
          const t = this.bones,
            e = this.boneInverses
          if (((this.boneMatrices = new Float32Array(16 * t.length)), 0 === e.length)) this.calculateInverses()
          else if (t.length !== e.length) {
            this.boneInverses = []
            for (let t = 0, e = this.bones.length; t < e; t++) this.boneInverses.push(new ne())
          }
        }
        calculateInverses() {
          this.boneInverses.length = 0
          for (let t = 0, e = this.bones.length; t < e; t++) {
            const e = new ne()
            this.bones[t] && e.copy(this.bones[t].matrixWorld).invert(), this.boneInverses.push(e)
          }
        }
        pose() {
          for (let t = 0, e = this.bones.length; t < e; t++) {
            const e = this.bones[t]
            e && e.matrixWorld.copy(this.boneInverses[t]).invert()
          }
          for (let t = 0, e = this.bones.length; t < e; t++) {
            const e = this.bones[t]
            e &&
              (e.parent && e.parent.isBone
                ? (e.matrix.copy(e.parent.matrixWorld).invert(), e.matrix.multiply(e.matrixWorld))
                : e.matrix.copy(e.matrixWorld),
              e.matrix.decompose(e.position, e.quaternion, e.scale))
          }
        }
        update() {
          const t = this.bones,
            e = this.boneInverses,
            i = this.boneMatrices,
            n = this.boneTexture
          for (let s = 0, r = t.length; s < r; s++) {
            const n = t[s] ? t[s].matrixWorld : la
            oa.multiplyMatrices(n, e[s]), oa.toArray(i, 16 * s)
          }
          null !== n && (n.needsUpdate = !0)
        }
        clone() {
          return new ca(this.bones, this.boneInverses)
        }
        computeBoneTexture() {
          let t = Math.sqrt(4 * this.bones.length)
          ;(t = dt(t)), (t = Math.max(t, 4))
          const e = new Float32Array(t * t * 4)
          e.set(this.boneMatrices)
          const i = new aa(e, t, t, 1023, 1015)
          return (this.boneMatrices = e), (this.boneTexture = i), (this.boneTextureSize = t), this
        }
        getBoneByName(t) {
          for (let e = 0, i = this.bones.length; e < i; e++) {
            const i = this.bones[e]
            if (i.name === t) return i
          }
        }
        dispose() {
          null !== this.boneTexture && (this.boneTexture.dispose(), (this.boneTexture = null))
        }
        fromJSON(t, e) {
          this.uuid = t.uuid
          for (let i = 0, n = t.bones.length; i < n; i++) {
            let n = e[t.bones[i]]
            void 0 === n && (n = new ra()),
              this.bones.push(n),
              this.boneInverses.push(new ne().fromArray(t.boneInverses[i]))
          }
          return this.init(), this
        }
        toJSON() {
          const t = {
            metadata: { version: 4.5, type: 'Skeleton', generator: 'Skeleton.toJSON' },
            bones: [],
            boneInverses: [],
          }
          t.uuid = this.uuid
          const e = this.bones,
            i = this.boneInverses
          for (let n = 0, s = e.length; n < s; n++) {
            const s = e[n]
            t.bones.push(s.uuid)
            const r = i[n]
            t.boneInverses.push(r.toArray())
          }
          return t
        }
      }
      const ha = new ne(),
        ua = new ne(),
        da = [],
        pa = new Si()
      ;(class extends Si {
        constructor(t, e, i) {
          super(t, e),
            (this.instanceMatrix = new Ze(new Float32Array(16 * i), 16)),
            (this.instanceColor = null),
            (this.count = i),
            (this.frustumCulled = !1)
        }
        copy(t) {
          return (
            super.copy(t),
            this.instanceMatrix.copy(t.instanceMatrix),
            null !== t.instanceColor && (this.instanceColor = t.instanceColor.clone()),
            (this.count = t.count),
            this
          )
        }
        getColorAt(t, e) {
          e.fromArray(this.instanceColor.array, 3 * t)
        }
        getMatrixAt(t, e) {
          e.fromArray(this.instanceMatrix.array, 16 * t)
        }
        raycast(t, e) {
          const i = this.matrixWorld,
            n = this.count
          if (((pa.geometry = this.geometry), (pa.material = this.material), void 0 !== pa.material))
            for (let s = 0; s < n; s++) {
              this.getMatrixAt(s, ha), ua.multiplyMatrices(i, ha), (pa.matrixWorld = ua), pa.raycast(t, da)
              for (let t = 0, i = da.length; t < i; t++) {
                const i = da[t]
                ;(i.instanceId = s), (i.object = this), e.push(i)
              }
              da.length = 0
            }
        }
        setColorAt(t, e) {
          null === this.instanceColor &&
            (this.instanceColor = new Ze(new Float32Array(3 * this.instanceMatrix.count), 3)),
            e.toArray(this.instanceColor.array, 3 * t)
        }
        setMatrixAt(t, e) {
          e.toArray(this.instanceMatrix.array, 16 * t)
        }
        updateMorphTargets() {}
        dispose() {
          this.dispatchEvent({ type: 'dispose' })
        }
      }.prototype.isInstancedMesh = !0)
      class Aa extends Ge {
        constructor(t) {
          super(),
            (this.type = 'LineBasicMaterial'),
            (this.color = new Ye(16777215)),
            (this.linewidth = 1),
            (this.linecap = 'round'),
            (this.linejoin = 'round'),
            this.setValues(t)
        }
        copy(t) {
          return (
            super.copy(t),
            this.color.copy(t.color),
            (this.linewidth = t.linewidth),
            (this.linecap = t.linecap),
            (this.linejoin = t.linejoin),
            this
          )
        }
      }
      Aa.prototype.isLineBasicMaterial = !0
      const ga = new Et(),
        ma = new Et(),
        fa = new ne(),
        va = new ie(),
        ya = new Yt()
      class xa extends Se {
        constructor(t = new hi(), e = new Aa()) {
          super(), (this.type = 'Line'), (this.geometry = t), (this.material = e), this.updateMorphTargets()
        }
        copy(t) {
          return super.copy(t), (this.material = t.material), (this.geometry = t.geometry), this
        }
        computeLineDistances() {
          const t = this.geometry
          if (t.isBufferGeometry) {
            if (null === t.index) {
              const e = t.attributes.position,
                i = [0]
              for (let t = 1, n = e.count; t < n; t++)
                ga.fromBufferAttribute(e, t - 1),
                  ma.fromBufferAttribute(e, t),
                  (i[t] = i[t - 1]),
                  (i[t] += ga.distanceTo(ma))
              t.setAttribute('lineDistance', new ei(i, 1))
            }
          } else t.isGeometry
          return this
        }
        raycast(t, e) {
          const i = this.geometry,
            n = this.matrixWorld,
            s = t.params.Line.threshold,
            r = i.drawRange
          if (
            (null === i.boundingSphere && i.computeBoundingSphere(),
            ya.copy(i.boundingSphere),
            ya.applyMatrix4(n),
            (ya.radius += s),
            !1 === t.ray.intersectsSphere(ya))
          )
            return
          fa.copy(n).invert(), va.copy(t.ray).applyMatrix4(fa)
          const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
            o = a * a,
            l = new Et(),
            c = new Et(),
            h = new Et(),
            u = new Et(),
            d = this.isLineSegments ? 2 : 1
          if (i.isBufferGeometry) {
            const n = i.index,
              s = i.attributes.position
            if (null !== n)
              for (let i = Math.max(0, r.start), a = Math.min(n.count, r.start + r.count) - 1; i < a; i += d) {
                const r = n.getX(i),
                  a = n.getX(i + 1)
                if ((l.fromBufferAttribute(s, r), c.fromBufferAttribute(s, a), va.distanceSqToSegment(l, c, u, h) > o))
                  continue
                u.applyMatrix4(this.matrixWorld)
                const d = t.ray.origin.distanceTo(u)
                d < t.near ||
                  d > t.far ||
                  e.push({
                    distance: d,
                    point: h.clone().applyMatrix4(this.matrixWorld),
                    index: i,
                    face: null,
                    faceIndex: null,
                    object: this,
                  })
              }
            else
              for (let i = Math.max(0, r.start), a = Math.min(s.count, r.start + r.count) - 1; i < a; i += d) {
                if (
                  (l.fromBufferAttribute(s, i), c.fromBufferAttribute(s, i + 1), va.distanceSqToSegment(l, c, u, h) > o)
                )
                  continue
                u.applyMatrix4(this.matrixWorld)
                const n = t.ray.origin.distanceTo(u)
                n < t.near ||
                  n > t.far ||
                  e.push({
                    distance: n,
                    point: h.clone().applyMatrix4(this.matrixWorld),
                    index: i,
                    face: null,
                    faceIndex: null,
                    object: this,
                  })
              }
          } else i.isGeometry
        }
        updateMorphTargets() {
          const t = this.geometry
          if (t.isBufferGeometry) {
            const e = t.morphAttributes,
              i = Object.keys(e)
            if (i.length > 0) {
              const t = e[i[0]]
              if (void 0 !== t) {
                ;(this.morphTargetInfluences = []), (this.morphTargetDictionary = {})
                for (let e = 0, i = t.length; e < i; e++) {
                  const i = t[e].name || String(e)
                  this.morphTargetInfluences.push(0), (this.morphTargetDictionary[i] = e)
                }
              }
            }
          } else {
            const e = t.morphTargets
            void 0 !== e && e.length
          }
        }
      }
      xa.prototype.isLine = !0
      const wa = new Et(),
        _a = new Et()
      class Ia extends xa {
        constructor(t, e) {
          super(t, e), (this.type = 'LineSegments')
        }
        computeLineDistances() {
          const t = this.geometry
          if (t.isBufferGeometry) {
            if (null === t.index) {
              const e = t.attributes.position,
                i = []
              for (let t = 0, n = e.count; t < n; t += 2)
                wa.fromBufferAttribute(e, t),
                  _a.fromBufferAttribute(e, t + 1),
                  (i[t] = 0 === t ? 0 : i[t - 1]),
                  (i[t + 1] = i[t] + wa.distanceTo(_a))
              t.setAttribute('lineDistance', new ei(i, 1))
            }
          } else t.isGeometry
          return this
        }
      }
      Ia.prototype.isLineSegments = !0
      class Ca extends xa {
        constructor(t, e) {
          super(t, e), (this.type = 'LineLoop')
        }
      }
      Ca.prototype.isLineLoop = !0
      class Ma extends Ge {
        constructor(t) {
          super(),
            (this.type = 'PointsMaterial'),
            (this.color = new Ye(16777215)),
            (this.map = null),
            (this.alphaMap = null),
            (this.size = 1),
            (this.sizeAttenuation = !0),
            this.setValues(t)
        }
        copy(t) {
          return (
            super.copy(t),
            this.color.copy(t.color),
            (this.map = t.map),
            (this.alphaMap = t.alphaMap),
            (this.size = t.size),
            (this.sizeAttenuation = t.sizeAttenuation),
            this
          )
        }
      }
      Ma.prototype.isPointsMaterial = !0
      const Ea = new ne(),
        ba = new ie(),
        Sa = new Yt(),
        Ba = new Et()
      class Ta extends Se {
        constructor(t = new hi(), e = new Ma()) {
          super(), (this.type = 'Points'), (this.geometry = t), (this.material = e), this.updateMorphTargets()
        }
        copy(t) {
          return super.copy(t), (this.material = t.material), (this.geometry = t.geometry), this
        }
        raycast(t, e) {
          const i = this.geometry,
            n = this.matrixWorld,
            s = t.params.Points.threshold,
            r = i.drawRange
          if (
            (null === i.boundingSphere && i.computeBoundingSphere(),
            Sa.copy(i.boundingSphere),
            Sa.applyMatrix4(n),
            (Sa.radius += s),
            !1 === t.ray.intersectsSphere(Sa))
          )
            return
          Ea.copy(n).invert(), ba.copy(t.ray).applyMatrix4(Ea)
          const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
            o = a * a
          if (i.isBufferGeometry) {
            const s = i.index,
              a = i.attributes.position
            if (null !== s)
              for (let i = Math.max(0, r.start), l = Math.min(s.count, r.start + r.count); i < l; i++) {
                const r = s.getX(i)
                Ba.fromBufferAttribute(a, r), La(Ba, r, o, n, t, e, this)
              }
            else
              for (let i = Math.max(0, r.start), l = Math.min(a.count, r.start + r.count); i < l; i++)
                Ba.fromBufferAttribute(a, i), La(Ba, i, o, n, t, e, this)
          }
        }
        updateMorphTargets() {
          const t = this.geometry
          if (t.isBufferGeometry) {
            const e = t.morphAttributes,
              i = Object.keys(e)
            if (i.length > 0) {
              const t = e[i[0]]
              if (void 0 !== t) {
                ;(this.morphTargetInfluences = []), (this.morphTargetDictionary = {})
                for (let e = 0, i = t.length; e < i; e++) {
                  const i = t[e].name || String(e)
                  this.morphTargetInfluences.push(0), (this.morphTargetDictionary[i] = e)
                }
              }
            }
          } else {
            const e = t.morphTargets
            void 0 !== e && e.length
          }
        }
      }
      function La(t, e, i, n, s, r, a) {
        const o = ba.distanceSqToPoint(t)
        if (o < i) {
          const i = new Et()
          ba.closestPointToPoint(t, i), i.applyMatrix4(n)
          const l = s.ray.origin.distanceTo(i)
          if (l < s.near || l > s.far) return
          r.push({ distance: l, distanceToRay: Math.sqrt(o), point: i, index: e, face: null, object: a })
        }
      }
      ;(Ta.prototype.isPoints = !0),
        (class extends xt {
          constructor(t, e, i, n, s, r, a, o, l) {
            super(t, e, i, n, s, r, a, o, l),
              (this.format = void 0 !== a ? a : 1022),
              (this.minFilter = void 0 !== r ? r : 1006),
              (this.magFilter = void 0 !== s ? s : 1006),
              (this.generateMipmaps = !1)
            const c = this
            'requestVideoFrameCallback' in t &&
              t.requestVideoFrameCallback(function e() {
                ;(c.needsUpdate = !0), t.requestVideoFrameCallback(e)
              })
          }
          clone() {
            return new this.constructor(this.image).copy(this)
          }
          update() {
            const t = this.image
            !1 == 'requestVideoFrameCallback' in t && t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
          }
        }.prototype.isVideoTexture = !0)
      class Da extends xt {
        constructor(t, e, i, n, s, r, a, o, l, c, h, u) {
          super(null, r, a, o, l, c, n, s, h, u),
            (this.image = { width: e, height: i }),
            (this.mipmaps = t),
            (this.flipY = !1),
            (this.generateMipmaps = !1)
        }
      }
      ;(Da.prototype.isCompressedTexture = !0),
        (class extends xt {
          constructor(t, e, i, n, s, r, a, o, l) {
            super(t, e, i, n, s, r, a, o, l), (this.needsUpdate = !0)
          }
        }.prototype.isCanvasTexture = !0),
        (class extends xt {
          constructor(t, e, i, n, s, r, a, o, l, c) {
            if (1026 !== (c = void 0 !== c ? c : 1026) && 1027 !== c)
              throw new Error('DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat')
            void 0 === i && 1026 === c && (i = 1012),
              void 0 === i && 1027 === c && (i = 1020),
              super(null, n, s, r, a, o, c, i, l),
              (this.image = { width: t, height: e }),
              (this.magFilter = void 0 !== a ? a : 1003),
              (this.minFilter = void 0 !== o ? o : 1003),
              (this.flipY = !1),
              (this.generateMipmaps = !1)
          }
        }.prototype.isDepthTexture = !0),
        new Et(),
        new Et(),
        new Et(),
        new ke()
      class Qa {
        constructor() {
          ;(this.type = 'Curve'), (this.arcLengthDivisions = 200)
        }
        getPoint() {
          return null
        }
        getPointAt(t, e) {
          const i = this.getUtoTmapping(t)
          return this.getPoint(i, e)
        }
        getPoints(t = 5) {
          const e = []
          for (let i = 0; i <= t; i++) e.push(this.getPoint(i / t))
          return e
        }
        getSpacedPoints(t = 5) {
          const e = []
          for (let i = 0; i <= t; i++) e.push(this.getPointAt(i / t))
          return e
        }
        getLength() {
          const t = this.getLengths()
          return t[t.length - 1]
        }
        getLengths(t = this.arcLengthDivisions) {
          if (this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate)
            return this.cacheArcLengths
          this.needsUpdate = !1
          const e = []
          let i,
            n = this.getPoint(0),
            s = 0
          e.push(0)
          for (let r = 1; r <= t; r++) (i = this.getPoint(r / t)), (s += i.distanceTo(n)), e.push(s), (n = i)
          return (this.cacheArcLengths = e), e
        }
        updateArcLengths() {
          ;(this.needsUpdate = !0), this.getLengths()
        }
        getUtoTmapping(t, e) {
          const i = this.getLengths()
          let n = 0
          const s = i.length
          let r
          r = e || t * i[s - 1]
          let a,
            o = 0,
            l = s - 1
          for (; o <= l; )
            if (((n = Math.floor(o + (l - o) / 2)), (a = i[n] - r), a < 0)) o = n + 1
            else {
              if (!(a > 0)) {
                l = n
                break
              }
              l = n - 1
            }
          if (((n = l), i[n] === r)) return n / (s - 1)
          const c = i[n]
          return (n + (r - c) / (i[n + 1] - c)) / (s - 1)
        }
        getTangent(t, e) {
          const i = 1e-4
          let n = t - i,
            s = t + i
          n < 0 && (n = 0), s > 1 && (s = 1)
          const r = this.getPoint(n),
            a = this.getPoint(s),
            o = e || (r.isVector2 ? new gt() : new Et())
          return o.copy(a).sub(r).normalize(), o
        }
        getTangentAt(t, e) {
          const i = this.getUtoTmapping(t)
          return this.getTangent(i, e)
        }
        computeFrenetFrames(t, e) {
          const i = new Et(),
            n = [],
            s = [],
            r = [],
            a = new Et(),
            o = new ne()
          for (let d = 0; d <= t; d++) {
            const e = d / t
            ;(n[d] = this.getTangentAt(e, new Et())), n[d].normalize()
          }
          ;(s[0] = new Et()), (r[0] = new Et())
          let l = Number.MAX_VALUE
          const c = Math.abs(n[0].x),
            h = Math.abs(n[0].y),
            u = Math.abs(n[0].z)
          c <= l && ((l = c), i.set(1, 0, 0)),
            h <= l && ((l = h), i.set(0, 1, 0)),
            u <= l && i.set(0, 0, 1),
            a.crossVectors(n[0], i).normalize(),
            s[0].crossVectors(n[0], a),
            r[0].crossVectors(n[0], s[0])
          for (let d = 1; d <= t; d++) {
            if (
              ((s[d] = s[d - 1].clone()),
              (r[d] = r[d - 1].clone()),
              a.crossVectors(n[d - 1], n[d]),
              a.length() > Number.EPSILON)
            ) {
              a.normalize()
              const t = Math.acos(lt(n[d - 1].dot(n[d]), -1, 1))
              s[d].applyMatrix4(o.makeRotationAxis(a, t))
            }
            r[d].crossVectors(n[d], s[d])
          }
          if (!0 === e) {
            let e = Math.acos(lt(s[0].dot(s[t]), -1, 1))
            ;(e /= t), n[0].dot(a.crossVectors(s[0], s[t])) > 0 && (e = -e)
            for (let i = 1; i <= t; i++)
              s[i].applyMatrix4(o.makeRotationAxis(n[i], e * i)), r[i].crossVectors(n[i], s[i])
          }
          return { tangents: n, normals: s, binormals: r }
        }
        clone() {
          return new this.constructor().copy(this)
        }
        copy(t) {
          return (this.arcLengthDivisions = t.arcLengthDivisions), this
        }
        toJSON() {
          const t = { metadata: { version: 4.5, type: 'Curve', generator: 'Curve.toJSON' } }
          return (t.arcLengthDivisions = this.arcLengthDivisions), (t.type = this.type), t
        }
        fromJSON(t) {
          return (this.arcLengthDivisions = t.arcLengthDivisions), this
        }
      }
      class Ra extends Qa {
        constructor(t = 0, e = 0, i = 1, n = 1, s = 0, r = 2 * Math.PI, a = !1, o = 0) {
          super(),
            (this.type = 'EllipseCurve'),
            (this.aX = t),
            (this.aY = e),
            (this.xRadius = i),
            (this.yRadius = n),
            (this.aStartAngle = s),
            (this.aEndAngle = r),
            (this.aClockwise = a),
            (this.aRotation = o)
        }
        getPoint(t, e) {
          const i = e || new gt(),
            n = 2 * Math.PI
          let s = this.aEndAngle - this.aStartAngle
          const r = Math.abs(s) < Number.EPSILON
          for (; s < 0; ) s += n
          for (; s > n; ) s -= n
          s < Number.EPSILON && (s = r ? 0 : n), !0 !== this.aClockwise || r || (s === n ? (s = -n) : (s -= n))
          const a = this.aStartAngle + t * s
          let o = this.aX + this.xRadius * Math.cos(a),
            l = this.aY + this.yRadius * Math.sin(a)
          if (0 !== this.aRotation) {
            const t = Math.cos(this.aRotation),
              e = Math.sin(this.aRotation),
              i = o - this.aX,
              n = l - this.aY
            ;(o = i * t - n * e + this.aX), (l = i * e + n * t + this.aY)
          }
          return i.set(o, l)
        }
        copy(t) {
          return (
            super.copy(t),
            (this.aX = t.aX),
            (this.aY = t.aY),
            (this.xRadius = t.xRadius),
            (this.yRadius = t.yRadius),
            (this.aStartAngle = t.aStartAngle),
            (this.aEndAngle = t.aEndAngle),
            (this.aClockwise = t.aClockwise),
            (this.aRotation = t.aRotation),
            this
          )
        }
        toJSON() {
          const t = super.toJSON()
          return (
            (t.aX = this.aX),
            (t.aY = this.aY),
            (t.xRadius = this.xRadius),
            (t.yRadius = this.yRadius),
            (t.aStartAngle = this.aStartAngle),
            (t.aEndAngle = this.aEndAngle),
            (t.aClockwise = this.aClockwise),
            (t.aRotation = this.aRotation),
            t
          )
        }
        fromJSON(t) {
          return (
            super.fromJSON(t),
            (this.aX = t.aX),
            (this.aY = t.aY),
            (this.xRadius = t.xRadius),
            (this.yRadius = t.yRadius),
            (this.aStartAngle = t.aStartAngle),
            (this.aEndAngle = t.aEndAngle),
            (this.aClockwise = t.aClockwise),
            (this.aRotation = t.aRotation),
            this
          )
        }
      }
      Ra.prototype.isEllipseCurve = !0
      class Pa extends Ra {
        constructor(t, e, i, n, s, r) {
          super(t, e, i, i, n, s, r), (this.type = 'ArcCurve')
        }
      }
      function Na() {
        let t = 0,
          e = 0,
          i = 0,
          n = 0
        function s(s, r, a, o) {
          ;(t = s), (e = a), (i = -3 * s + 3 * r - 2 * a - o), (n = 2 * s - 2 * r + a + o)
        }
        return {
          initCatmullRom: function (t, e, i, n, r) {
            s(e, i, r * (i - t), r * (n - e))
          },
          initNonuniformCatmullRom: function (t, e, i, n, r, a, o) {
            let l = (e - t) / r - (i - t) / (r + a) + (i - e) / a,
              c = (i - e) / a - (n - e) / (a + o) + (n - i) / o
            ;(l *= a), (c *= a), s(e, i, l, c)
          },
          calc: function (s) {
            const r = s * s
            return t + e * s + i * r + n * (r * s)
          },
        }
      }
      Pa.prototype.isArcCurve = !0
      const Fa = new Et(),
        Ua = new Na(),
        ka = new Na(),
        Oa = new Na()
      class Ga extends Qa {
        constructor(t = [], e = !1, i = 'centripetal', n = 0.5) {
          super(),
            (this.type = 'CatmullRomCurve3'),
            (this.points = t),
            (this.closed = e),
            (this.curveType = i),
            (this.tension = n)
        }
        getPoint(t, e = new Et()) {
          const i = e,
            n = this.points,
            s = n.length,
            r = (s - (this.closed ? 0 : 1)) * t
          let a,
            o,
            l = Math.floor(r),
            c = r - l
          this.closed
            ? (l += l > 0 ? 0 : (Math.floor(Math.abs(l) / s) + 1) * s)
            : 0 === c && l === s - 1 && ((l = s - 2), (c = 1)),
            this.closed || l > 0 ? (a = n[(l - 1) % s]) : (Fa.subVectors(n[0], n[1]).add(n[0]), (a = Fa))
          const h = n[l % s],
            u = n[(l + 1) % s]
          if (
            (this.closed || l + 2 < s
              ? (o = n[(l + 2) % s])
              : (Fa.subVectors(n[s - 1], n[s - 2]).add(n[s - 1]), (o = Fa)),
            'centripetal' === this.curveType || 'chordal' === this.curveType)
          ) {
            const t = 'chordal' === this.curveType ? 0.5 : 0.25
            let e = Math.pow(a.distanceToSquared(h), t),
              i = Math.pow(h.distanceToSquared(u), t),
              n = Math.pow(u.distanceToSquared(o), t)
            i < 1e-4 && (i = 1),
              e < 1e-4 && (e = i),
              n < 1e-4 && (n = i),
              Ua.initNonuniformCatmullRom(a.x, h.x, u.x, o.x, e, i, n),
              ka.initNonuniformCatmullRom(a.y, h.y, u.y, o.y, e, i, n),
              Oa.initNonuniformCatmullRom(a.z, h.z, u.z, o.z, e, i, n)
          } else
            'catmullrom' === this.curveType &&
              (Ua.initCatmullRom(a.x, h.x, u.x, o.x, this.tension),
              ka.initCatmullRom(a.y, h.y, u.y, o.y, this.tension),
              Oa.initCatmullRom(a.z, h.z, u.z, o.z, this.tension))
          return i.set(Ua.calc(c), ka.calc(c), Oa.calc(c)), i
        }
        copy(t) {
          super.copy(t), (this.points = [])
          for (let e = 0, i = t.points.length; e < i; e++) {
            const i = t.points[e]
            this.points.push(i.clone())
          }
          return (this.closed = t.closed), (this.curveType = t.curveType), (this.tension = t.tension), this
        }
        toJSON() {
          const t = super.toJSON()
          t.points = []
          for (let e = 0, i = this.points.length; e < i; e++) {
            const i = this.points[e]
            t.points.push(i.toArray())
          }
          return (t.closed = this.closed), (t.curveType = this.curveType), (t.tension = this.tension), t
        }
        fromJSON(t) {
          super.fromJSON(t), (this.points = [])
          for (let e = 0, i = t.points.length; e < i; e++) {
            const i = t.points[e]
            this.points.push(new Et().fromArray(i))
          }
          return (this.closed = t.closed), (this.curveType = t.curveType), (this.tension = t.tension), this
        }
      }
      function za(t, e, i, n, s) {
        const r = 0.5 * (n - e),
          a = 0.5 * (s - i),
          o = t * t
        return (2 * i - 2 * n + r + a) * (t * o) + (-3 * i + 3 * n - 2 * r - a) * o + r * t + i
      }
      function Va(t, e, i, n) {
        return (
          (function (t, e) {
            const i = 1 - t
            return i * i * e
          })(t, e) +
          (function (t, e) {
            return 2 * (1 - t) * t * e
          })(t, i) +
          (function (t, e) {
            return t * t * e
          })(t, n)
        )
      }
      function Ha(t, e, i, n, s) {
        return (
          (function (t, e) {
            const i = 1 - t
            return i * i * i * e
          })(t, e) +
          (function (t, e) {
            const i = 1 - t
            return 3 * i * i * t * e
          })(t, i) +
          (function (t, e) {
            return 3 * (1 - t) * t * t * e
          })(t, n) +
          (function (t, e) {
            return t * t * t * e
          })(t, s)
        )
      }
      Ga.prototype.isCatmullRomCurve3 = !0
      class Wa extends Qa {
        constructor(t = new gt(), e = new gt(), i = new gt(), n = new gt()) {
          super(), (this.type = 'CubicBezierCurve'), (this.v0 = t), (this.v1 = e), (this.v2 = i), (this.v3 = n)
        }
        getPoint(t, e = new gt()) {
          const i = e,
            n = this.v0,
            s = this.v1,
            r = this.v2,
            a = this.v3
          return i.set(Ha(t, n.x, s.x, r.x, a.x), Ha(t, n.y, s.y, r.y, a.y)), i
        }
        copy(t) {
          return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this
        }
        toJSON() {
          const t = super.toJSON()
          return (
            (t.v0 = this.v0.toArray()),
            (t.v1 = this.v1.toArray()),
            (t.v2 = this.v2.toArray()),
            (t.v3 = this.v3.toArray()),
            t
          )
        }
        fromJSON(t) {
          return (
            super.fromJSON(t),
            this.v0.fromArray(t.v0),
            this.v1.fromArray(t.v1),
            this.v2.fromArray(t.v2),
            this.v3.fromArray(t.v3),
            this
          )
        }
      }
      Wa.prototype.isCubicBezierCurve = !0
      class qa extends Qa {
        constructor(t = new Et(), e = new Et(), i = new Et(), n = new Et()) {
          super(), (this.type = 'CubicBezierCurve3'), (this.v0 = t), (this.v1 = e), (this.v2 = i), (this.v3 = n)
        }
        getPoint(t, e = new Et()) {
          const i = e,
            n = this.v0,
            s = this.v1,
            r = this.v2,
            a = this.v3
          return i.set(Ha(t, n.x, s.x, r.x, a.x), Ha(t, n.y, s.y, r.y, a.y), Ha(t, n.z, s.z, r.z, a.z)), i
        }
        copy(t) {
          return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this
        }
        toJSON() {
          const t = super.toJSON()
          return (
            (t.v0 = this.v0.toArray()),
            (t.v1 = this.v1.toArray()),
            (t.v2 = this.v2.toArray()),
            (t.v3 = this.v3.toArray()),
            t
          )
        }
        fromJSON(t) {
          return (
            super.fromJSON(t),
            this.v0.fromArray(t.v0),
            this.v1.fromArray(t.v1),
            this.v2.fromArray(t.v2),
            this.v3.fromArray(t.v3),
            this
          )
        }
      }
      qa.prototype.isCubicBezierCurve3 = !0
      class ja extends Qa {
        constructor(t = new gt(), e = new gt()) {
          super(), (this.type = 'LineCurve'), (this.v1 = t), (this.v2 = e)
        }
        getPoint(t, e = new gt()) {
          const i = e
          return 1 === t ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(t).add(this.v1)), i
        }
        getPointAt(t, e) {
          return this.getPoint(t, e)
        }
        getTangent(t, e) {
          const i = e || new gt()
          return i.copy(this.v2).sub(this.v1).normalize(), i
        }
        copy(t) {
          return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
        }
        toJSON() {
          const t = super.toJSON()
          return (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t
        }
        fromJSON(t) {
          return super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
        }
      }
      ja.prototype.isLineCurve = !0
      class Ya extends Qa {
        constructor(t = new gt(), e = new gt(), i = new gt()) {
          super(), (this.type = 'QuadraticBezierCurve'), (this.v0 = t), (this.v1 = e), (this.v2 = i)
        }
        getPoint(t, e = new gt()) {
          const i = e,
            n = this.v0,
            s = this.v1,
            r = this.v2
          return i.set(Va(t, n.x, s.x, r.x), Va(t, n.y, s.y, r.y)), i
        }
        copy(t) {
          return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this
        }
        toJSON() {
          const t = super.toJSON()
          return (t.v0 = this.v0.toArray()), (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t
        }
        fromJSON(t) {
          return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
        }
      }
      Ya.prototype.isQuadraticBezierCurve = !0
      class Ja extends Qa {
        constructor(t = new Et(), e = new Et(), i = new Et()) {
          super(), (this.type = 'QuadraticBezierCurve3'), (this.v0 = t), (this.v1 = e), (this.v2 = i)
        }
        getPoint(t, e = new Et()) {
          const i = e,
            n = this.v0,
            s = this.v1,
            r = this.v2
          return i.set(Va(t, n.x, s.x, r.x), Va(t, n.y, s.y, r.y), Va(t, n.z, s.z, r.z)), i
        }
        copy(t) {
          return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this
        }
        toJSON() {
          const t = super.toJSON()
          return (t.v0 = this.v0.toArray()), (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t
        }
        fromJSON(t) {
          return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
        }
      }
      Ja.prototype.isQuadraticBezierCurve3 = !0
      class Xa extends Qa {
        constructor(t = []) {
          super(), (this.type = 'SplineCurve'), (this.points = t)
        }
        getPoint(t, e = new gt()) {
          const i = e,
            n = this.points,
            s = (n.length - 1) * t,
            r = Math.floor(s),
            a = s - r,
            o = n[0 === r ? r : r - 1],
            l = n[r],
            c = n[r > n.length - 2 ? n.length - 1 : r + 1],
            h = n[r > n.length - 3 ? n.length - 1 : r + 2]
          return i.set(za(a, o.x, l.x, c.x, h.x), za(a, o.y, l.y, c.y, h.y)), i
        }
        copy(t) {
          super.copy(t), (this.points = [])
          for (let e = 0, i = t.points.length; e < i; e++) {
            const i = t.points[e]
            this.points.push(i.clone())
          }
          return this
        }
        toJSON() {
          const t = super.toJSON()
          t.points = []
          for (let e = 0, i = this.points.length; e < i; e++) {
            const i = this.points[e]
            t.points.push(i.toArray())
          }
          return t
        }
        fromJSON(t) {
          super.fromJSON(t), (this.points = [])
          for (let e = 0, i = t.points.length; e < i; e++) {
            const i = t.points[e]
            this.points.push(new gt().fromArray(i))
          }
          return this
        }
      }
      Xa.prototype.isSplineCurve = !0
      var Ka = Object.freeze({
        __proto__: null,
        ArcCurve: Pa,
        CatmullRomCurve3: Ga,
        CubicBezierCurve: Wa,
        CubicBezierCurve3: qa,
        EllipseCurve: Ra,
        LineCurve: ja,
        LineCurve3: class extends Qa {
          constructor(t = new Et(), e = new Et()) {
            super(), (this.type = 'LineCurve3'), (this.isLineCurve3 = !0), (this.v1 = t), (this.v2 = e)
          }
          getPoint(t, e = new Et()) {
            const i = e
            return 1 === t ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(t).add(this.v1)), i
          }
          getPointAt(t, e) {
            return this.getPoint(t, e)
          }
          copy(t) {
            return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
          }
          toJSON() {
            const t = super.toJSON()
            return (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t
          }
          fromJSON(t) {
            return super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
          }
        },
        QuadraticBezierCurve: Ya,
        QuadraticBezierCurve3: Ja,
        SplineCurve: Xa,
      })
      function Za(t, e, i, n, s) {
        let r, a
        if (
          s ===
          (function (t, e, i, n) {
            let s = 0
            for (let r = e, a = i - n; r < i; r += n) (s += (t[a] - t[r]) * (t[r + 1] + t[a + 1])), (a = r)
            return s
          })(t, e, i, n) >
            0
        )
          for (r = e; r < i; r += n) a = xo(r, t[r], t[r + 1], a)
        else for (r = i - n; r >= e; r -= n) a = xo(r, t[r], t[r + 1], a)
        return a && Ao(a, a.next) && (wo(a), (a = a.next)), a
      }
      function $a(t, e) {
        if (!t) return t
        e || (e = t)
        let i,
          n = t
        do {
          if (((i = !1), n.steiner || (!Ao(n, n.next) && 0 !== po(n.prev, n, n.next)))) n = n.next
          else {
            if ((wo(n), (n = e = n.prev), n === n.next)) break
            i = !0
          }
        } while (i || n !== e)
        return e
      }
      function to(t, e, i, n, s, r, a) {
        if (!t) return
        !a &&
          r &&
          (function (t, e, i, n) {
            let s = t
            do {
              null === s.z && (s.z = lo(s.x, s.y, e, i, n)), (s.prevZ = s.prev), (s.nextZ = s.next), (s = s.next)
            } while (s !== t)
            ;(s.prevZ.nextZ = null),
              (s.prevZ = null),
              (function (t) {
                let e,
                  i,
                  n,
                  s,
                  r,
                  a,
                  o,
                  l,
                  c = 1
                do {
                  for (i = t, t = null, r = null, a = 0; i; ) {
                    for (a++, n = i, o = 0, e = 0; e < c && (o++, (n = n.nextZ), n); e++);
                    for (l = c; o > 0 || (l > 0 && n); )
                      0 !== o && (0 === l || !n || i.z <= n.z)
                        ? ((s = i), (i = i.nextZ), o--)
                        : ((s = n), (n = n.nextZ), l--),
                        r ? (r.nextZ = s) : (t = s),
                        (s.prevZ = r),
                        (r = s)
                    i = n
                  }
                  ;(r.nextZ = null), (c *= 2)
                } while (a > 1)
              })(s)
          })(t, n, s, r)
        let o,
          l,
          c = t
        for (; t.prev !== t.next; )
          if (((o = t.prev), (l = t.next), r ? io(t, n, s, r) : eo(t)))
            e.push(o.i / i), e.push(t.i / i), e.push(l.i / i), wo(t), (t = l.next), (c = l.next)
          else if ((t = l) === c) {
            a
              ? 1 === a
                ? to((t = no($a(t), e, i)), e, i, n, s, r, 2)
                : 2 === a && so(t, e, i, n, s, r)
              : to($a(t), e, i, n, s, r, 1)
            break
          }
      }
      function eo(t) {
        const e = t.prev,
          i = t,
          n = t.next
        if (po(e, i, n) >= 0) return !1
        let s = t.next.next
        for (; s !== t.prev; ) {
          if (ho(e.x, e.y, i.x, i.y, n.x, n.y, s.x, s.y) && po(s.prev, s, s.next) >= 0) return !1
          s = s.next
        }
        return !0
      }
      function io(t, e, i, n) {
        const s = t.prev,
          r = t,
          a = t.next
        if (po(s, r, a) >= 0) return !1
        const o = s.x < r.x ? (s.x < a.x ? s.x : a.x) : r.x < a.x ? r.x : a.x,
          l = s.y < r.y ? (s.y < a.y ? s.y : a.y) : r.y < a.y ? r.y : a.y,
          c = s.x > r.x ? (s.x > a.x ? s.x : a.x) : r.x > a.x ? r.x : a.x,
          h = s.y > r.y ? (s.y > a.y ? s.y : a.y) : r.y > a.y ? r.y : a.y,
          u = lo(o, l, e, i, n),
          d = lo(c, h, e, i, n)
        let p = t.prevZ,
          A = t.nextZ
        for (; p && p.z >= u && A && A.z <= d; ) {
          if (p !== t.prev && p !== t.next && ho(s.x, s.y, r.x, r.y, a.x, a.y, p.x, p.y) && po(p.prev, p, p.next) >= 0)
            return !1
          if (
            ((p = p.prevZ),
            A !== t.prev && A !== t.next && ho(s.x, s.y, r.x, r.y, a.x, a.y, A.x, A.y) && po(A.prev, A, A.next) >= 0)
          )
            return !1
          A = A.nextZ
        }
        for (; p && p.z >= u; ) {
          if (p !== t.prev && p !== t.next && ho(s.x, s.y, r.x, r.y, a.x, a.y, p.x, p.y) && po(p.prev, p, p.next) >= 0)
            return !1
          p = p.prevZ
        }
        for (; A && A.z <= d; ) {
          if (A !== t.prev && A !== t.next && ho(s.x, s.y, r.x, r.y, a.x, a.y, A.x, A.y) && po(A.prev, A, A.next) >= 0)
            return !1
          A = A.nextZ
        }
        return !0
      }
      function no(t, e, i) {
        let n = t
        do {
          const s = n.prev,
            r = n.next.next
          !Ao(s, r) &&
            go(s, n, n.next, r) &&
            vo(s, r) &&
            vo(r, s) &&
            (e.push(s.i / i), e.push(n.i / i), e.push(r.i / i), wo(n), wo(n.next), (n = t = r)),
            (n = n.next)
        } while (n !== t)
        return $a(n)
      }
      function so(t, e, i, n, s, r) {
        let a = t
        do {
          let t = a.next.next
          for (; t !== a.prev; ) {
            if (a.i !== t.i && uo(a, t)) {
              let o = yo(a, t)
              return (a = $a(a, a.next)), (o = $a(o, o.next)), to(a, e, i, n, s, r), void to(o, e, i, n, s, r)
            }
            t = t.next
          }
          a = a.next
        } while (a !== t)
      }
      function ro(t, e) {
        return t.x - e.x
      }
      function ao(t, e) {
        if (
          (e = (function (t, e) {
            let i = e
            const n = t.x,
              s = t.y
            let r,
              a = -1 / 0
            do {
              if (s <= i.y && s >= i.next.y && i.next.y !== i.y) {
                const t = i.x + ((s - i.y) * (i.next.x - i.x)) / (i.next.y - i.y)
                if (t <= n && t > a) {
                  if (((a = t), t === n)) {
                    if (s === i.y) return i
                    if (s === i.next.y) return i.next
                  }
                  r = i.x < i.next.x ? i : i.next
                }
              }
              i = i.next
            } while (i !== e)
            if (!r) return null
            if (n === a) return r
            const o = r,
              l = r.x,
              c = r.y
            let h,
              u = 1 / 0
            i = r
            do {
              n >= i.x &&
                i.x >= l &&
                n !== i.x &&
                ho(s < c ? n : a, s, l, c, s < c ? a : n, s, i.x, i.y) &&
                ((h = Math.abs(s - i.y) / (n - i.x)),
                vo(i, t) && (h < u || (h === u && (i.x > r.x || (i.x === r.x && oo(r, i))))) && ((r = i), (u = h))),
                (i = i.next)
            } while (i !== o)
            return r
          })(t, e))
        ) {
          const i = yo(e, t)
          $a(e, e.next), $a(i, i.next)
        }
      }
      function oo(t, e) {
        return po(t.prev, t, e.prev) < 0 && po(e.next, t, t.next) < 0
      }
      function lo(t, e, i, n, s) {
        return (
          (t =
            1431655765 &
            ((t =
              858993459 &
              ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - i) * s) | (t << 8))) | (t << 4))) | (t << 2))) |
              (t << 1))) |
          ((e =
            1431655765 &
            ((e =
              858993459 &
              ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - n) * s) | (e << 8))) | (e << 4))) | (e << 2))) |
              (e << 1))) <<
            1)
        )
      }
      function co(t) {
        let e = t,
          i = t
        do {
          ;(e.x < i.x || (e.x === i.x && e.y < i.y)) && (i = e), (e = e.next)
        } while (e !== t)
        return i
      }
      function ho(t, e, i, n, s, r, a, o) {
        return (
          (s - a) * (e - o) - (t - a) * (r - o) >= 0 &&
          (t - a) * (n - o) - (i - a) * (e - o) >= 0 &&
          (i - a) * (r - o) - (s - a) * (n - o) >= 0
        )
      }
      function uo(t, e) {
        return (
          t.next.i !== e.i &&
          t.prev.i !== e.i &&
          !(function (t, e) {
            let i = t
            do {
              if (i.i !== t.i && i.next.i !== t.i && i.i !== e.i && i.next.i !== e.i && go(i, i.next, t, e)) return !0
              i = i.next
            } while (i !== t)
            return !1
          })(t, e) &&
          ((vo(t, e) &&
            vo(e, t) &&
            (function (t, e) {
              let i = t,
                n = !1
              const s = (t.x + e.x) / 2,
                r = (t.y + e.y) / 2
              do {
                i.y > r != i.next.y > r &&
                  i.next.y !== i.y &&
                  s < ((i.next.x - i.x) * (r - i.y)) / (i.next.y - i.y) + i.x &&
                  (n = !n),
                  (i = i.next)
              } while (i !== t)
              return n
            })(t, e) &&
            (po(t.prev, t, e.prev) || po(t, e.prev, e))) ||
            (Ao(t, e) && po(t.prev, t, t.next) > 0 && po(e.prev, e, e.next) > 0))
        )
      }
      function po(t, e, i) {
        return (e.y - t.y) * (i.x - e.x) - (e.x - t.x) * (i.y - e.y)
      }
      function Ao(t, e) {
        return t.x === e.x && t.y === e.y
      }
      function go(t, e, i, n) {
        const s = fo(po(t, e, i)),
          r = fo(po(t, e, n)),
          a = fo(po(i, n, t)),
          o = fo(po(i, n, e))
        return (
          (s !== r && a !== o) ||
          !(0 !== s || !mo(t, i, e)) ||
          !(0 !== r || !mo(t, n, e)) ||
          !(0 !== a || !mo(i, t, n)) ||
          !(0 !== o || !mo(i, e, n))
        )
      }
      function mo(t, e, i) {
        return (
          e.x <= Math.max(t.x, i.x) &&
          e.x >= Math.min(t.x, i.x) &&
          e.y <= Math.max(t.y, i.y) &&
          e.y >= Math.min(t.y, i.y)
        )
      }
      function fo(t) {
        return t > 0 ? 1 : t < 0 ? -1 : 0
      }
      function vo(t, e) {
        return po(t.prev, t, t.next) < 0
          ? po(t, e, t.next) >= 0 && po(t, t.prev, e) >= 0
          : po(t, e, t.prev) < 0 || po(t, t.next, e) < 0
      }
      function yo(t, e) {
        const i = new _o(t.i, t.x, t.y),
          n = new _o(e.i, e.x, e.y),
          s = t.next,
          r = e.prev
        return (
          (t.next = e),
          (e.prev = t),
          (i.next = s),
          (s.prev = i),
          (n.next = i),
          (i.prev = n),
          (r.next = n),
          (n.prev = r),
          n
        )
      }
      function xo(t, e, i, n) {
        const s = new _o(t, e, i)
        return n ? ((s.next = n.next), (s.prev = n), (n.next.prev = s), (n.next = s)) : ((s.prev = s), (s.next = s)), s
      }
      function wo(t) {
        ;(t.next.prev = t.prev),
          (t.prev.next = t.next),
          t.prevZ && (t.prevZ.nextZ = t.nextZ),
          t.nextZ && (t.nextZ.prevZ = t.prevZ)
      }
      function _o(t, e, i) {
        ;(this.i = t),
          (this.x = e),
          (this.y = i),
          (this.prev = null),
          (this.next = null),
          (this.z = null),
          (this.prevZ = null),
          (this.nextZ = null),
          (this.steiner = !1)
      }
      class Io {
        static area(t) {
          const e = t.length
          let i = 0
          for (let n = e - 1, s = 0; s < e; n = s++) i += t[n].x * t[s].y - t[s].x * t[n].y
          return 0.5 * i
        }
        static isClockWise(t) {
          return Io.area(t) < 0
        }
        static triangulateShape(t, e) {
          const i = [],
            n = [],
            s = []
          Co(t), Mo(i, t)
          let r = t.length
          e.forEach(Co)
          for (let o = 0; o < e.length; o++) n.push(r), (r += e[o].length), Mo(i, e[o])
          const a = (function (t, e, i = 2) {
            const n = e && e.length,
              s = n ? e[0] * i : t.length
            let r = Za(t, 0, s, i, !0)
            const a = []
            if (!r || r.next === r.prev) return a
            let o, l, c, h, u, d, p
            if (
              (n &&
                (r = (function (t, e, i, n) {
                  const s = []
                  let r, a, o, l, c
                  for (r = 0, a = e.length; r < a; r++)
                    (o = e[r] * n),
                      (l = r < a - 1 ? e[r + 1] * n : t.length),
                      (c = Za(t, o, l, n, !1)),
                      c === c.next && (c.steiner = !0),
                      s.push(co(c))
                  for (s.sort(ro), r = 0; r < s.length; r++) ao(s[r], i), (i = $a(i, i.next))
                  return i
                })(t, e, r, i)),
              t.length > 80 * i)
            ) {
              ;(o = c = t[0]), (l = h = t[1])
              for (let e = i; e < s; e += i)
                (u = t[e]), (d = t[e + 1]), u < o && (o = u), d < l && (l = d), u > c && (c = u), d > h && (h = d)
              ;(p = Math.max(c - o, h - l)), (p = 0 !== p ? 1 / p : 0)
            }
            return to(r, a, i, o, l, p), a
          })(i, n)
          for (let o = 0; o < a.length; o += 3) s.push(a.slice(o, o + 3))
          return s
        }
      }
      function Co(t) {
        const e = t.length
        e > 2 && t[e - 1].equals(t[0]) && t.pop()
      }
      function Mo(t, e) {
        for (let i = 0; i < e.length; i++) t.push(e[i].x), t.push(e[i].y)
      }
      class Eo extends hi {
        constructor(t, e) {
          super(),
            (this.type = 'ExtrudeGeometry'),
            (this.parameters = { shapes: t, options: e }),
            (t = Array.isArray(t) ? t : [t])
          const i = this,
            n = [],
            s = []
          for (let a = 0, o = t.length; a < o; a++) r(t[a])
          function r(t) {
            const r = [],
              a = void 0 !== e.curveSegments ? e.curveSegments : 12,
              o = void 0 !== e.steps ? e.steps : 1
            let l = void 0 !== e.depth ? e.depth : 100,
              c = void 0 === e.bevelEnabled || e.bevelEnabled,
              h = void 0 !== e.bevelThickness ? e.bevelThickness : 6,
              u = void 0 !== e.bevelSize ? e.bevelSize : h - 2,
              d = void 0 !== e.bevelOffset ? e.bevelOffset : 0,
              p = void 0 !== e.bevelSegments ? e.bevelSegments : 3
            const A = e.extrudePath,
              g = void 0 !== e.UVGenerator ? e.UVGenerator : bo
            void 0 !== e.amount && (l = e.amount)
            let m,
              f,
              v,
              y,
              x,
              w = !1
            A &&
              ((m = A.getSpacedPoints(o)),
              (w = !0),
              (c = !1),
              (f = A.computeFrenetFrames(o, !1)),
              (v = new Et()),
              (y = new Et()),
              (x = new Et())),
              c || ((p = 0), (h = 0), (u = 0), (d = 0))
            const _ = t.extractPoints(a)
            let I = _.shape
            const C = _.holes
            if (!Io.isClockWise(I)) {
              I = I.reverse()
              for (let t = 0, e = C.length; t < e; t++) {
                const e = C[t]
                Io.isClockWise(e) && (C[t] = e.reverse())
              }
            }
            const M = Io.triangulateShape(I, C),
              E = I
            for (let e = 0, i = C.length; e < i; e++) {
              const t = C[e]
              I = I.concat(t)
            }
            function b(t, e, i) {
              return e.clone().multiplyScalar(i).add(t)
            }
            const S = I.length,
              B = M.length
            function T(t, e, i) {
              let n, s, r
              const a = t.x - e.x,
                o = t.y - e.y,
                l = i.x - t.x,
                c = i.y - t.y,
                h = a * a + o * o,
                u = a * c - o * l
              if (Math.abs(u) > Number.EPSILON) {
                const u = Math.sqrt(h),
                  d = Math.sqrt(l * l + c * c),
                  p = e.x - o / u,
                  A = e.y + a / u,
                  g = ((i.x - c / d - p) * c - (i.y + l / d - A) * l) / (a * c - o * l)
                ;(n = p + a * g - t.x), (s = A + o * g - t.y)
                const m = n * n + s * s
                if (m <= 2) return new gt(n, s)
                r = Math.sqrt(m / 2)
              } else {
                let t = !1
                a > Number.EPSILON
                  ? l > Number.EPSILON && (t = !0)
                  : a < -Number.EPSILON
                  ? l < -Number.EPSILON && (t = !0)
                  : Math.sign(o) === Math.sign(c) && (t = !0),
                  t ? ((n = -o), (s = a), (r = Math.sqrt(h))) : ((n = a), (s = o), (r = Math.sqrt(h / 2)))
              }
              return new gt(n / r, s / r)
            }
            const L = []
            for (let e = 0, i = E.length, n = i - 1, s = e + 1; e < i; e++, n++, s++)
              n === i && (n = 0), s === i && (s = 0), (L[e] = T(E[e], E[n], E[s]))
            const D = []
            let Q,
              R = L.concat()
            for (let e = 0, i = C.length; e < i; e++) {
              const t = C[e]
              Q = []
              for (let e = 0, i = t.length, n = i - 1, s = e + 1; e < i; e++, n++, s++)
                n === i && (n = 0), s === i && (s = 0), (Q[e] = T(t[e], t[n], t[s]))
              D.push(Q), (R = R.concat(Q))
            }
            for (let e = 0; e < p; e++) {
              const t = e / p,
                i = h * Math.cos((t * Math.PI) / 2),
                n = u * Math.sin((t * Math.PI) / 2) + d
              for (let e = 0, s = E.length; e < s; e++) {
                const t = b(E[e], L[e], n)
                F(t.x, t.y, -i)
              }
              for (let e = 0, s = C.length; e < s; e++) {
                const t = C[e]
                Q = D[e]
                for (let e = 0, s = t.length; e < s; e++) {
                  const s = b(t[e], Q[e], n)
                  F(s.x, s.y, -i)
                }
              }
            }
            const P = u + d
            for (let e = 0; e < S; e++) {
              const t = c ? b(I[e], R[e], P) : I[e]
              w
                ? (y.copy(f.normals[0]).multiplyScalar(t.x),
                  v.copy(f.binormals[0]).multiplyScalar(t.y),
                  x.copy(m[0]).add(y).add(v),
                  F(x.x, x.y, x.z))
                : F(t.x, t.y, 0)
            }
            for (let e = 1; e <= o; e++)
              for (let t = 0; t < S; t++) {
                const i = c ? b(I[t], R[t], P) : I[t]
                w
                  ? (y.copy(f.normals[e]).multiplyScalar(i.x),
                    v.copy(f.binormals[e]).multiplyScalar(i.y),
                    x.copy(m[e]).add(y).add(v),
                    F(x.x, x.y, x.z))
                  : F(i.x, i.y, (l / o) * e)
              }
            for (let e = p - 1; e >= 0; e--) {
              const t = e / p,
                i = h * Math.cos((t * Math.PI) / 2),
                n = u * Math.sin((t * Math.PI) / 2) + d
              for (let e = 0, s = E.length; e < s; e++) {
                const t = b(E[e], L[e], n)
                F(t.x, t.y, l + i)
              }
              for (let e = 0, s = C.length; e < s; e++) {
                const t = C[e]
                Q = D[e]
                for (let e = 0, s = t.length; e < s; e++) {
                  const s = b(t[e], Q[e], n)
                  w ? F(s.x, s.y + m[o - 1].y, m[o - 1].x + i) : F(s.x, s.y, l + i)
                }
              }
            }
            function N(t, e) {
              let i = t.length
              for (; --i >= 0; ) {
                const n = i
                let s = i - 1
                s < 0 && (s = t.length - 1)
                for (let t = 0, i = o + 2 * p; t < i; t++) {
                  const i = S * t,
                    r = S * (t + 1)
                  k(e + n + i, e + s + i, e + s + r, e + n + r)
                }
              }
            }
            function F(t, e, i) {
              r.push(t), r.push(e), r.push(i)
            }
            function U(t, e, s) {
              O(t), O(e), O(s)
              const r = n.length / 3,
                a = g.generateTopUV(i, n, r - 3, r - 2, r - 1)
              G(a[0]), G(a[1]), G(a[2])
            }
            function k(t, e, s, r) {
              O(t), O(e), O(r), O(e), O(s), O(r)
              const a = n.length / 3,
                o = g.generateSideWallUV(i, n, a - 6, a - 3, a - 2, a - 1)
              G(o[0]), G(o[1]), G(o[3]), G(o[1]), G(o[2]), G(o[3])
            }
            function O(t) {
              n.push(r[3 * t + 0]), n.push(r[3 * t + 1]), n.push(r[3 * t + 2])
            }
            function G(t) {
              s.push(t.x), s.push(t.y)
            }
            !(function () {
              const t = n.length / 3
              if (c) {
                let t = 0,
                  e = S * t
                for (let i = 0; i < B; i++) {
                  const t = M[i]
                  U(t[2] + e, t[1] + e, t[0] + e)
                }
                ;(t = o + 2 * p), (e = S * t)
                for (let i = 0; i < B; i++) {
                  const t = M[i]
                  U(t[0] + e, t[1] + e, t[2] + e)
                }
              } else {
                for (let t = 0; t < B; t++) {
                  const e = M[t]
                  U(e[2], e[1], e[0])
                }
                for (let t = 0; t < B; t++) {
                  const e = M[t]
                  U(e[0] + S * o, e[1] + S * o, e[2] + S * o)
                }
              }
              i.addGroup(t, n.length / 3 - t, 0)
            })(),
              (function () {
                const t = n.length / 3
                let e = 0
                N(E, e), (e += E.length)
                for (let i = 0, n = C.length; i < n; i++) {
                  const t = C[i]
                  N(t, e), (e += t.length)
                }
                i.addGroup(t, n.length / 3 - t, 1)
              })()
          }
          this.setAttribute('position', new ei(n, 3)),
            this.setAttribute('uv', new ei(s, 2)),
            this.computeVertexNormals()
        }
        toJSON() {
          const t = super.toJSON()
          return (function (t, e, i) {
            if (((i.shapes = []), Array.isArray(t)))
              for (let n = 0, s = t.length; n < s; n++) {
                const e = t[n]
                i.shapes.push(e.uuid)
              }
            else i.shapes.push(t.uuid)
            return void 0 !== e.extrudePath && (i.options.extrudePath = e.extrudePath.toJSON()), i
          })(this.parameters.shapes, this.parameters.options, t)
        }
        static fromJSON(t, e) {
          const i = []
          for (let s = 0, r = t.shapes.length; s < r; s++) {
            const n = e[t.shapes[s]]
            i.push(n)
          }
          const n = t.options.extrudePath
          return void 0 !== n && (t.options.extrudePath = new Ka[n.type]().fromJSON(n)), new Eo(i, t.options)
        }
      }
      const bo = {
        generateTopUV: function (t, e, i, n, s) {
          const r = e[3 * i],
            a = e[3 * i + 1],
            o = e[3 * n],
            l = e[3 * n + 1],
            c = e[3 * s],
            h = e[3 * s + 1]
          return [new gt(r, a), new gt(o, l), new gt(c, h)]
        },
        generateSideWallUV: function (t, e, i, n, s, r) {
          const a = e[3 * i],
            o = e[3 * i + 1],
            l = e[3 * i + 2],
            c = e[3 * n],
            h = e[3 * n + 1],
            u = e[3 * n + 2],
            d = e[3 * s],
            p = e[3 * s + 1],
            A = e[3 * s + 2],
            g = e[3 * r],
            m = e[3 * r + 1],
            f = e[3 * r + 2]
          return Math.abs(o - h) < Math.abs(a - c)
            ? [new gt(a, 1 - l), new gt(c, 1 - u), new gt(d, 1 - A), new gt(g, 1 - f)]
            : [new gt(o, 1 - l), new gt(h, 1 - u), new gt(p, 1 - A), new gt(m, 1 - f)]
        },
      }
      class So extends hi {
        constructor(t, e = 12) {
          super(), (this.type = 'ShapeGeometry'), (this.parameters = { shapes: t, curveSegments: e })
          const i = [],
            n = [],
            s = [],
            r = []
          let a = 0,
            o = 0
          if (!1 === Array.isArray(t)) l(t)
          else for (let c = 0; c < t.length; c++) l(t[c]), this.addGroup(a, o, c), (a += o), (o = 0)
          function l(t) {
            const a = n.length / 3,
              l = t.extractPoints(e)
            let c = l.shape
            const h = l.holes
            !1 === Io.isClockWise(c) && (c = c.reverse())
            for (let e = 0, i = h.length; e < i; e++) {
              const t = h[e]
              !0 === Io.isClockWise(t) && (h[e] = t.reverse())
            }
            const u = Io.triangulateShape(c, h)
            for (let e = 0, i = h.length; e < i; e++) {
              const t = h[e]
              c = c.concat(t)
            }
            for (let e = 0, i = c.length; e < i; e++) {
              const t = c[e]
              n.push(t.x, t.y, 0), s.push(0, 0, 1), r.push(t.x, t.y)
            }
            for (let e = 0, n = u.length; e < n; e++) {
              const t = u[e],
                n = t[0] + a,
                s = t[1] + a,
                r = t[2] + a
              i.push(n, s, r), (o += 3)
            }
          }
          this.setIndex(i),
            this.setAttribute('position', new ei(n, 3)),
            this.setAttribute('normal', new ei(s, 3)),
            this.setAttribute('uv', new ei(r, 2))
        }
        toJSON() {
          const t = super.toJSON()
          return (function (t, e) {
            if (((e.shapes = []), Array.isArray(t)))
              for (let i = 0, n = t.length; i < n; i++) {
                const n = t[i]
                e.shapes.push(n.uuid)
              }
            else e.shapes.push(t.uuid)
            return e
          })(this.parameters.shapes, t)
        }
        static fromJSON(t, e) {
          const i = []
          for (let n = 0, s = t.shapes.length; n < s; n++) {
            const s = e[t.shapes[n]]
            i.push(s)
          }
          return new So(i, t.curveSegments)
        }
      }
      class Bo extends Ge {
        constructor(t) {
          super(), (this.type = 'ShadowMaterial'), (this.color = new Ye(0)), (this.transparent = !0), this.setValues(t)
        }
        copy(t) {
          return super.copy(t), this.color.copy(t.color), this
        }
      }
      Bo.prototype.isShadowMaterial = !0
      class To extends Ge {
        constructor(t) {
          super(),
            (this.defines = { STANDARD: '' }),
            (this.type = 'MeshStandardMaterial'),
            (this.color = new Ye(16777215)),
            (this.roughness = 1),
            (this.metalness = 0),
            (this.map = null),
            (this.lightMap = null),
            (this.lightMapIntensity = 1),
            (this.aoMap = null),
            (this.aoMapIntensity = 1),
            (this.emissive = new Ye(0)),
            (this.emissiveIntensity = 1),
            (this.emissiveMap = null),
            (this.bumpMap = null),
            (this.bumpScale = 1),
            (this.normalMap = null),
            (this.normalMapType = 0),
            (this.normalScale = new gt(1, 1)),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.roughnessMap = null),
            (this.metalnessMap = null),
            (this.alphaMap = null),
            (this.envMap = null),
            (this.envMapIntensity = 1),
            (this.refractionRatio = 0.98),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.wireframeLinecap = 'round'),
            (this.wireframeLinejoin = 'round'),
            (this.flatShading = !1),
            this.setValues(t)
        }
        copy(t) {
          return (
            super.copy(t),
            (this.defines = { STANDARD: '' }),
            this.color.copy(t.color),
            (this.roughness = t.roughness),
            (this.metalness = t.metalness),
            (this.map = t.map),
            (this.lightMap = t.lightMap),
            (this.lightMapIntensity = t.lightMapIntensity),
            (this.aoMap = t.aoMap),
            (this.aoMapIntensity = t.aoMapIntensity),
            this.emissive.copy(t.emissive),
            (this.emissiveMap = t.emissiveMap),
            (this.emissiveIntensity = t.emissiveIntensity),
            (this.bumpMap = t.bumpMap),
            (this.bumpScale = t.bumpScale),
            (this.normalMap = t.normalMap),
            (this.normalMapType = t.normalMapType),
            this.normalScale.copy(t.normalScale),
            (this.displacementMap = t.displacementMap),
            (this.displacementScale = t.displacementScale),
            (this.displacementBias = t.displacementBias),
            (this.roughnessMap = t.roughnessMap),
            (this.metalnessMap = t.metalnessMap),
            (this.alphaMap = t.alphaMap),
            (this.envMap = t.envMap),
            (this.envMapIntensity = t.envMapIntensity),
            (this.refractionRatio = t.refractionRatio),
            (this.wireframe = t.wireframe),
            (this.wireframeLinewidth = t.wireframeLinewidth),
            (this.wireframeLinecap = t.wireframeLinecap),
            (this.wireframeLinejoin = t.wireframeLinejoin),
            (this.flatShading = t.flatShading),
            this
          )
        }
      }
      To.prototype.isMeshStandardMaterial = !0
      class Lo extends To {
        constructor(t) {
          super(),
            (this.defines = { STANDARD: '', PHYSICAL: '' }),
            (this.type = 'MeshPhysicalMaterial'),
            (this.clearcoat = 0),
            (this.clearcoatMap = null),
            (this.clearcoatRoughness = 0),
            (this.clearcoatRoughnessMap = null),
            (this.clearcoatNormalScale = new gt(1, 1)),
            (this.clearcoatNormalMap = null),
            (this.reflectivity = 0.5),
            Object.defineProperty(this, 'ior', {
              get: function () {
                return (1 + 0.4 * this.reflectivity) / (1 - 0.4 * this.reflectivity)
              },
              set: function (t) {
                this.reflectivity = lt((2.5 * (t - 1)) / (t + 1), 0, 1)
              },
            }),
            (this.sheen = null),
            (this.transmission = 0),
            (this.transmissionMap = null),
            (this.thickness = 0.01),
            (this.thicknessMap = null),
            (this.attenuationDistance = 0),
            (this.attenuationTint = new Ye(1, 1, 1)),
            (this.specularIntensity = 1),
            (this.specularIntensityMap = null),
            (this.specularTint = new Ye(1, 1, 1)),
            (this.specularTintMap = null),
            this.setValues(t)
        }
        copy(t) {
          return (
            super.copy(t),
            (this.defines = { STANDARD: '', PHYSICAL: '' }),
            (this.clearcoat = t.clearcoat),
            (this.clearcoatMap = t.clearcoatMap),
            (this.clearcoatRoughness = t.clearcoatRoughness),
            (this.clearcoatRoughnessMap = t.clearcoatRoughnessMap),
            (this.clearcoatNormalMap = t.clearcoatNormalMap),
            this.clearcoatNormalScale.copy(t.clearcoatNormalScale),
            (this.reflectivity = t.reflectivity),
            t.sheen ? (this.sheen = (this.sheen || new Ye()).copy(t.sheen)) : (this.sheen = null),
            (this.transmission = t.transmission),
            (this.transmissionMap = t.transmissionMap),
            (this.thickness = t.thickness),
            (this.thicknessMap = t.thicknessMap),
            (this.attenuationDistance = t.attenuationDistance),
            this.attenuationTint.copy(t.attenuationTint),
            (this.specularIntensity = t.specularIntensity),
            (this.specularIntensityMap = t.specularIntensityMap),
            this.specularTint.copy(t.specularTint),
            (this.specularTintMap = t.specularTintMap),
            this
          )
        }
      }
      ;(Lo.prototype.isMeshPhysicalMaterial = !0),
        (class extends Ge {
          constructor(t) {
            super(),
              (this.type = 'MeshPhongMaterial'),
              (this.color = new Ye(16777215)),
              (this.specular = new Ye(1118481)),
              (this.shininess = 30),
              (this.map = null),
              (this.lightMap = null),
              (this.lightMapIntensity = 1),
              (this.aoMap = null),
              (this.aoMapIntensity = 1),
              (this.emissive = new Ye(0)),
              (this.emissiveIntensity = 1),
              (this.emissiveMap = null),
              (this.bumpMap = null),
              (this.bumpScale = 1),
              (this.normalMap = null),
              (this.normalMapType = 0),
              (this.normalScale = new gt(1, 1)),
              (this.displacementMap = null),
              (this.displacementScale = 1),
              (this.displacementBias = 0),
              (this.specularMap = null),
              (this.alphaMap = null),
              (this.envMap = null),
              (this.combine = 0),
              (this.reflectivity = 1),
              (this.refractionRatio = 0.98),
              (this.wireframe = !1),
              (this.wireframeLinewidth = 1),
              (this.wireframeLinecap = 'round'),
              (this.wireframeLinejoin = 'round'),
              (this.flatShading = !1),
              this.setValues(t)
          }
          copy(t) {
            return (
              super.copy(t),
              this.color.copy(t.color),
              this.specular.copy(t.specular),
              (this.shininess = t.shininess),
              (this.map = t.map),
              (this.lightMap = t.lightMap),
              (this.lightMapIntensity = t.lightMapIntensity),
              (this.aoMap = t.aoMap),
              (this.aoMapIntensity = t.aoMapIntensity),
              this.emissive.copy(t.emissive),
              (this.emissiveMap = t.emissiveMap),
              (this.emissiveIntensity = t.emissiveIntensity),
              (this.bumpMap = t.bumpMap),
              (this.bumpScale = t.bumpScale),
              (this.normalMap = t.normalMap),
              (this.normalMapType = t.normalMapType),
              this.normalScale.copy(t.normalScale),
              (this.displacementMap = t.displacementMap),
              (this.displacementScale = t.displacementScale),
              (this.displacementBias = t.displacementBias),
              (this.specularMap = t.specularMap),
              (this.alphaMap = t.alphaMap),
              (this.envMap = t.envMap),
              (this.combine = t.combine),
              (this.reflectivity = t.reflectivity),
              (this.refractionRatio = t.refractionRatio),
              (this.wireframe = t.wireframe),
              (this.wireframeLinewidth = t.wireframeLinewidth),
              (this.wireframeLinecap = t.wireframeLinecap),
              (this.wireframeLinejoin = t.wireframeLinejoin),
              (this.flatShading = t.flatShading),
              this
            )
          }
        }.prototype.isMeshPhongMaterial = !0),
        (class extends Ge {
          constructor(t) {
            super(),
              (this.defines = { TOON: '' }),
              (this.type = 'MeshToonMaterial'),
              (this.color = new Ye(16777215)),
              (this.map = null),
              (this.gradientMap = null),
              (this.lightMap = null),
              (this.lightMapIntensity = 1),
              (this.aoMap = null),
              (this.aoMapIntensity = 1),
              (this.emissive = new Ye(0)),
              (this.emissiveIntensity = 1),
              (this.emissiveMap = null),
              (this.bumpMap = null),
              (this.bumpScale = 1),
              (this.normalMap = null),
              (this.normalMapType = 0),
              (this.normalScale = new gt(1, 1)),
              (this.displacementMap = null),
              (this.displacementScale = 1),
              (this.displacementBias = 0),
              (this.alphaMap = null),
              (this.wireframe = !1),
              (this.wireframeLinewidth = 1),
              (this.wireframeLinecap = 'round'),
              (this.wireframeLinejoin = 'round'),
              this.setValues(t)
          }
          copy(t) {
            return (
              super.copy(t),
              this.color.copy(t.color),
              (this.map = t.map),
              (this.gradientMap = t.gradientMap),
              (this.lightMap = t.lightMap),
              (this.lightMapIntensity = t.lightMapIntensity),
              (this.aoMap = t.aoMap),
              (this.aoMapIntensity = t.aoMapIntensity),
              this.emissive.copy(t.emissive),
              (this.emissiveMap = t.emissiveMap),
              (this.emissiveIntensity = t.emissiveIntensity),
              (this.bumpMap = t.bumpMap),
              (this.bumpScale = t.bumpScale),
              (this.normalMap = t.normalMap),
              (this.normalMapType = t.normalMapType),
              this.normalScale.copy(t.normalScale),
              (this.displacementMap = t.displacementMap),
              (this.displacementScale = t.displacementScale),
              (this.displacementBias = t.displacementBias),
              (this.alphaMap = t.alphaMap),
              (this.wireframe = t.wireframe),
              (this.wireframeLinewidth = t.wireframeLinewidth),
              (this.wireframeLinecap = t.wireframeLinecap),
              (this.wireframeLinejoin = t.wireframeLinejoin),
              this
            )
          }
        }.prototype.isMeshToonMaterial = !0),
        (class extends Ge {
          constructor(t) {
            super(),
              (this.type = 'MeshNormalMaterial'),
              (this.bumpMap = null),
              (this.bumpScale = 1),
              (this.normalMap = null),
              (this.normalMapType = 0),
              (this.normalScale = new gt(1, 1)),
              (this.displacementMap = null),
              (this.displacementScale = 1),
              (this.displacementBias = 0),
              (this.wireframe = !1),
              (this.wireframeLinewidth = 1),
              (this.fog = !1),
              (this.flatShading = !1),
              this.setValues(t)
          }
          copy(t) {
            return (
              super.copy(t),
              (this.bumpMap = t.bumpMap),
              (this.bumpScale = t.bumpScale),
              (this.normalMap = t.normalMap),
              (this.normalMapType = t.normalMapType),
              this.normalScale.copy(t.normalScale),
              (this.displacementMap = t.displacementMap),
              (this.displacementScale = t.displacementScale),
              (this.displacementBias = t.displacementBias),
              (this.wireframe = t.wireframe),
              (this.wireframeLinewidth = t.wireframeLinewidth),
              (this.flatShading = t.flatShading),
              this
            )
          }
        }.prototype.isMeshNormalMaterial = !0),
        (class extends Ge {
          constructor(t) {
            super(),
              (this.type = 'MeshLambertMaterial'),
              (this.color = new Ye(16777215)),
              (this.map = null),
              (this.lightMap = null),
              (this.lightMapIntensity = 1),
              (this.aoMap = null),
              (this.aoMapIntensity = 1),
              (this.emissive = new Ye(0)),
              (this.emissiveIntensity = 1),
              (this.emissiveMap = null),
              (this.specularMap = null),
              (this.alphaMap = null),
              (this.envMap = null),
              (this.combine = 0),
              (this.reflectivity = 1),
              (this.refractionRatio = 0.98),
              (this.wireframe = !1),
              (this.wireframeLinewidth = 1),
              (this.wireframeLinecap = 'round'),
              (this.wireframeLinejoin = 'round'),
              this.setValues(t)
          }
          copy(t) {
            return (
              super.copy(t),
              this.color.copy(t.color),
              (this.map = t.map),
              (this.lightMap = t.lightMap),
              (this.lightMapIntensity = t.lightMapIntensity),
              (this.aoMap = t.aoMap),
              (this.aoMapIntensity = t.aoMapIntensity),
              this.emissive.copy(t.emissive),
              (this.emissiveMap = t.emissiveMap),
              (this.emissiveIntensity = t.emissiveIntensity),
              (this.specularMap = t.specularMap),
              (this.alphaMap = t.alphaMap),
              (this.envMap = t.envMap),
              (this.combine = t.combine),
              (this.reflectivity = t.reflectivity),
              (this.refractionRatio = t.refractionRatio),
              (this.wireframe = t.wireframe),
              (this.wireframeLinewidth = t.wireframeLinewidth),
              (this.wireframeLinecap = t.wireframeLinecap),
              (this.wireframeLinejoin = t.wireframeLinejoin),
              this
            )
          }
        }.prototype.isMeshLambertMaterial = !0),
        (class extends Ge {
          constructor(t) {
            super(),
              (this.defines = { MATCAP: '' }),
              (this.type = 'MeshMatcapMaterial'),
              (this.color = new Ye(16777215)),
              (this.matcap = null),
              (this.map = null),
              (this.bumpMap = null),
              (this.bumpScale = 1),
              (this.normalMap = null),
              (this.normalMapType = 0),
              (this.normalScale = new gt(1, 1)),
              (this.displacementMap = null),
              (this.displacementScale = 1),
              (this.displacementBias = 0),
              (this.alphaMap = null),
              (this.flatShading = !1),
              this.setValues(t)
          }
          copy(t) {
            return (
              super.copy(t),
              (this.defines = { MATCAP: '' }),
              this.color.copy(t.color),
              (this.matcap = t.matcap),
              (this.map = t.map),
              (this.bumpMap = t.bumpMap),
              (this.bumpScale = t.bumpScale),
              (this.normalMap = t.normalMap),
              (this.normalMapType = t.normalMapType),
              this.normalScale.copy(t.normalScale),
              (this.displacementMap = t.displacementMap),
              (this.displacementScale = t.displacementScale),
              (this.displacementBias = t.displacementBias),
              (this.alphaMap = t.alphaMap),
              (this.flatShading = t.flatShading),
              this
            )
          }
        }.prototype.isMeshMatcapMaterial = !0),
        (class extends Aa {
          constructor(t) {
            super(),
              (this.type = 'LineDashedMaterial'),
              (this.scale = 1),
              (this.dashSize = 3),
              (this.gapSize = 1),
              this.setValues(t)
          }
          copy(t) {
            return super.copy(t), (this.scale = t.scale), (this.dashSize = t.dashSize), (this.gapSize = t.gapSize), this
          }
        }.prototype.isLineDashedMaterial = !0)
      const Do = {
        arraySlice: function (t, e, i) {
          return Do.isTypedArray(t) ? new t.constructor(t.subarray(e, void 0 !== i ? i : t.length)) : t.slice(e, i)
        },
        convertArray: function (t, e, i) {
          return !t || (!i && t.constructor === e)
            ? t
            : 'number' == typeof e.BYTES_PER_ELEMENT
            ? new e(t)
            : Array.prototype.slice.call(t)
        },
        isTypedArray: function (t) {
          return ArrayBuffer.isView(t) && !(t instanceof DataView)
        },
        getKeyframeOrder: function (t) {
          const e = t.length,
            i = new Array(e)
          for (let n = 0; n !== e; ++n) i[n] = n
          return (
            i.sort(function (e, i) {
              return t[e] - t[i]
            }),
            i
          )
        },
        sortedArray: function (t, e, i) {
          const n = t.length,
            s = new t.constructor(n)
          for (let r = 0, a = 0; a !== n; ++r) {
            const n = i[r] * e
            for (let i = 0; i !== e; ++i) s[a++] = t[n + i]
          }
          return s
        },
        flattenJSON: function (t, e, i, n) {
          let s = 1,
            r = t[0]
          for (; void 0 !== r && void 0 === r[n]; ) r = t[s++]
          if (void 0 === r) return
          let a = r[n]
          if (void 0 !== a)
            if (Array.isArray(a))
              do {
                ;(a = r[n]), void 0 !== a && (e.push(r.time), i.push.apply(i, a)), (r = t[s++])
              } while (void 0 !== r)
            else if (void 0 !== a.toArray)
              do {
                ;(a = r[n]), void 0 !== a && (e.push(r.time), a.toArray(i, i.length)), (r = t[s++])
              } while (void 0 !== r)
            else
              do {
                ;(a = r[n]), void 0 !== a && (e.push(r.time), i.push(a)), (r = t[s++])
              } while (void 0 !== r)
        },
        subclip: function (t, e, i, n, s = 30) {
          const r = t.clone()
          r.name = e
          const a = []
          for (let l = 0; l < r.tracks.length; ++l) {
            const t = r.tracks[l],
              e = t.getValueSize(),
              o = [],
              c = []
            for (let r = 0; r < t.times.length; ++r) {
              const a = t.times[r] * s
              if (!(a < i || a >= n)) {
                o.push(t.times[r])
                for (let i = 0; i < e; ++i) c.push(t.values[r * e + i])
              }
            }
            0 !== o.length &&
              ((t.times = Do.convertArray(o, t.times.constructor)),
              (t.values = Do.convertArray(c, t.values.constructor)),
              a.push(t))
          }
          r.tracks = a
          let o = 1 / 0
          for (let l = 0; l < r.tracks.length; ++l) o > r.tracks[l].times[0] && (o = r.tracks[l].times[0])
          for (let l = 0; l < r.tracks.length; ++l) r.tracks[l].shift(-1 * o)
          return r.resetDuration(), r
        },
        makeClipAdditive: function (t, e = 0, i = t, n = 30) {
          n <= 0 && (n = 30)
          const s = i.tracks.length,
            r = e / n
          for (let a = 0; a < s; ++a) {
            const e = i.tracks[a],
              n = e.ValueTypeName
            if ('bool' === n || 'string' === n) continue
            const s = t.tracks.find(function (t) {
              return t.name === e.name && t.ValueTypeName === n
            })
            if (void 0 === s) continue
            let o = 0
            const l = e.getValueSize()
            e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (o = l / 3)
            let c = 0
            const h = s.getValueSize()
            s.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (c = h / 3)
            const u = e.times.length - 1
            let d
            if (r <= e.times[0]) {
              const t = o,
                i = l - o
              d = Do.arraySlice(e.values, t, i)
            } else if (r >= e.times[u]) {
              const t = u * l + o,
                i = t + l - o
              d = Do.arraySlice(e.values, t, i)
            } else {
              const t = e.createInterpolant(),
                i = o,
                n = l - o
              t.evaluate(r), (d = Do.arraySlice(t.resultBuffer, i, n))
            }
            'quaternion' === n && new Mt().fromArray(d).normalize().conjugate().toArray(d)
            const p = s.times.length
            for (let t = 0; t < p; ++t) {
              const e = t * h + c
              if ('quaternion' === n) Mt.multiplyQuaternionsFlat(s.values, e, d, 0, s.values, e)
              else {
                const t = h - 2 * c
                for (let i = 0; i < t; ++i) s.values[e + i] -= d[i]
              }
            }
          }
          return (t.blendMode = 2501), t
        },
      }
      class Qo {
        constructor(t, e, i, n) {
          ;(this.parameterPositions = t),
            (this._cachedIndex = 0),
            (this.resultBuffer = void 0 !== n ? n : new e.constructor(i)),
            (this.sampleValues = e),
            (this.valueSize = i),
            (this.settings = null),
            (this.DefaultSettings_ = {})
        }
        evaluate(t) {
          const e = this.parameterPositions
          let i = this._cachedIndex,
            n = e[i],
            s = e[i - 1]
          t: {
            e: {
              let r
              i: {
                n: if (!(t < n)) {
                  for (let r = i + 2; ; ) {
                    if (void 0 === n) {
                      if (t < s) break n
                      return (i = e.length), (this._cachedIndex = i), this.afterEnd_(i - 1, t, s)
                    }
                    if (i === r) break
                    if (((s = n), (n = e[++i]), t < n)) break e
                  }
                  r = e.length
                  break i
                }
                if (t >= s) break t
                {
                  const a = e[1]
                  t < a && ((i = 2), (s = a))
                  for (let r = i - 2; ; ) {
                    if (void 0 === s) return (this._cachedIndex = 0), this.beforeStart_(0, t, n)
                    if (i === r) break
                    if (((n = s), (s = e[--i - 1]), t >= s)) break e
                  }
                  ;(r = i), (i = 0)
                }
              }
              for (; i < r; ) {
                const n = (i + r) >>> 1
                t < e[n] ? (r = n) : (i = n + 1)
              }
              if (((n = e[i]), (s = e[i - 1]), void 0 === s)) return (this._cachedIndex = 0), this.beforeStart_(0, t, n)
              if (void 0 === n) return (i = e.length), (this._cachedIndex = i), this.afterEnd_(i - 1, s, t)
            }
            ;(this._cachedIndex = i), this.intervalChanged_(i, s, n)
          }
          return this.interpolate_(i, s, t, n)
        }
        getSettings_() {
          return this.settings || this.DefaultSettings_
        }
        copySampleValue_(t) {
          const e = this.resultBuffer,
            i = this.sampleValues,
            n = this.valueSize,
            s = t * n
          for (let r = 0; r !== n; ++r) e[r] = i[s + r]
          return e
        }
        interpolate_() {
          throw new Error('call to abstract method')
        }
        intervalChanged_() {}
      }
      ;(Qo.prototype.beforeStart_ = Qo.prototype.copySampleValue_),
        (Qo.prototype.afterEnd_ = Qo.prototype.copySampleValue_)
      class Ro extends Qo {
        constructor(t, e, i, n) {
          super(t, e, i, n),
            (this._weightPrev = -0),
            (this._offsetPrev = -0),
            (this._weightNext = -0),
            (this._offsetNext = -0),
            (this.DefaultSettings_ = { endingStart: 2400, endingEnd: 2400 })
        }
        intervalChanged_(t, e, i) {
          const n = this.parameterPositions
          let s = t - 2,
            r = t + 1,
            a = n[s],
            o = n[r]
          if (void 0 === a)
            switch (this.getSettings_().endingStart) {
              case 2401:
                ;(s = t), (a = 2 * e - i)
                break
              case 2402:
                ;(s = n.length - 2), (a = e + n[s] - n[s + 1])
                break
              default:
                ;(s = t), (a = i)
            }
          if (void 0 === o)
            switch (this.getSettings_().endingEnd) {
              case 2401:
                ;(r = t), (o = 2 * i - e)
                break
              case 2402:
                ;(r = 1), (o = i + n[1] - n[0])
                break
              default:
                ;(r = t - 1), (o = e)
            }
          const l = 0.5 * (i - e),
            c = this.valueSize
          ;(this._weightPrev = l / (e - a)),
            (this._weightNext = l / (o - i)),
            (this._offsetPrev = s * c),
            (this._offsetNext = r * c)
        }
        interpolate_(t, e, i, n) {
          const s = this.resultBuffer,
            r = this.sampleValues,
            a = this.valueSize,
            o = t * a,
            l = o - a,
            c = this._offsetPrev,
            h = this._offsetNext,
            u = this._weightPrev,
            d = this._weightNext,
            p = (i - e) / (n - e),
            A = p * p,
            g = A * p,
            m = -u * g + 2 * u * A - u * p,
            f = (1 + u) * g + (-1.5 - 2 * u) * A + (-0.5 + u) * p + 1,
            v = (-1 - d) * g + (1.5 + d) * A + 0.5 * p,
            y = d * g - d * A
          for (let x = 0; x !== a; ++x) s[x] = m * r[c + x] + f * r[l + x] + v * r[o + x] + y * r[h + x]
          return s
        }
      }
      class Po extends Qo {
        constructor(t, e, i, n) {
          super(t, e, i, n)
        }
        interpolate_(t, e, i, n) {
          const s = this.resultBuffer,
            r = this.sampleValues,
            a = this.valueSize,
            o = t * a,
            l = o - a,
            c = (i - e) / (n - e),
            h = 1 - c
          for (let u = 0; u !== a; ++u) s[u] = r[l + u] * h + r[o + u] * c
          return s
        }
      }
      class No extends Qo {
        constructor(t, e, i, n) {
          super(t, e, i, n)
        }
        interpolate_(t) {
          return this.copySampleValue_(t - 1)
        }
      }
      class Fo {
        constructor(t, e, i, n) {
          if (void 0 === t) throw new Error('THREE.KeyframeTrack: track name is undefined')
          if (void 0 === e || 0 === e.length) throw new Error('THREE.KeyframeTrack: no keyframes in track named ' + t)
          ;(this.name = t),
            (this.times = Do.convertArray(e, this.TimeBufferType)),
            (this.values = Do.convertArray(i, this.ValueBufferType)),
            this.setInterpolation(n || this.DefaultInterpolation)
        }
        static toJSON(t) {
          const e = t.constructor
          let i
          if (e.toJSON !== this.toJSON) i = e.toJSON(t)
          else {
            i = { name: t.name, times: Do.convertArray(t.times, Array), values: Do.convertArray(t.values, Array) }
            const e = t.getInterpolation()
            e !== t.DefaultInterpolation && (i.interpolation = e)
          }
          return (i.type = t.ValueTypeName), i
        }
        InterpolantFactoryMethodDiscrete(t) {
          return new No(this.times, this.values, this.getValueSize(), t)
        }
        InterpolantFactoryMethodLinear(t) {
          return new Po(this.times, this.values, this.getValueSize(), t)
        }
        InterpolantFactoryMethodSmooth(t) {
          return new Ro(this.times, this.values, this.getValueSize(), t)
        }
        setInterpolation(t) {
          let e
          switch (t) {
            case 2300:
              e = this.InterpolantFactoryMethodDiscrete
              break
            case 2301:
              e = this.InterpolantFactoryMethodLinear
              break
            case 2302:
              e = this.InterpolantFactoryMethodSmooth
          }
          if (void 0 === e) {
            const e = 'unsupported interpolation for ' + this.ValueTypeName + ' keyframe track named ' + this.name
            if (void 0 === this.createInterpolant) {
              if (t === this.DefaultInterpolation) throw new Error(e)
              this.setInterpolation(this.DefaultInterpolation)
            }
            return this
          }
          return (this.createInterpolant = e), this
        }
        getInterpolation() {
          switch (this.createInterpolant) {
            case this.InterpolantFactoryMethodDiscrete:
              return 2300
            case this.InterpolantFactoryMethodLinear:
              return 2301
            case this.InterpolantFactoryMethodSmooth:
              return 2302
          }
        }
        getValueSize() {
          return this.values.length / this.times.length
        }
        shift(t) {
          if (0 !== t) {
            const e = this.times
            for (let i = 0, n = e.length; i !== n; ++i) e[i] += t
          }
          return this
        }
        scale(t) {
          if (1 !== t) {
            const e = this.times
            for (let i = 0, n = e.length; i !== n; ++i) e[i] *= t
          }
          return this
        }
        trim(t, e) {
          const i = this.times,
            n = i.length
          let s = 0,
            r = n - 1
          for (; s !== n && i[s] < t; ) ++s
          for (; -1 !== r && i[r] > e; ) --r
          if ((++r, 0 !== s || r !== n)) {
            s >= r && ((r = Math.max(r, 1)), (s = r - 1))
            const t = this.getValueSize()
            ;(this.times = Do.arraySlice(i, s, r)), (this.values = Do.arraySlice(this.values, s * t, r * t))
          }
          return this
        }
        validate() {
          let t = !0
          const e = this.getValueSize()
          e - Math.floor(e) != 0 && (t = !1)
          const i = this.times,
            n = this.values,
            s = i.length
          0 === s && (t = !1)
          let r = null
          for (let a = 0; a !== s; a++) {
            const e = i[a]
            if ('number' == typeof e && isNaN(e)) {
              t = !1
              break
            }
            if (null !== r && r > e) {
              t = !1
              break
            }
            r = e
          }
          if (void 0 !== n && Do.isTypedArray(n))
            for (let a = 0, o = n.length; a !== o; ++a) {
              const e = n[a]
              if (isNaN(e)) {
                t = !1
                break
              }
            }
          return t
        }
        optimize() {
          const t = Do.arraySlice(this.times),
            e = Do.arraySlice(this.values),
            i = this.getValueSize(),
            n = 2302 === this.getInterpolation(),
            s = t.length - 1
          let r = 1
          for (let a = 1; a < s; ++a) {
            let s = !1
            const o = t[a]
            if (o !== t[a + 1] && (1 !== a || o !== t[0]))
              if (n) s = !0
              else {
                const t = a * i,
                  n = t - i,
                  r = t + i
                for (let a = 0; a !== i; ++a) {
                  const i = e[t + a]
                  if (i !== e[n + a] || i !== e[r + a]) {
                    s = !0
                    break
                  }
                }
              }
            if (s) {
              if (a !== r) {
                t[r] = t[a]
                const n = a * i,
                  s = r * i
                for (let t = 0; t !== i; ++t) e[s + t] = e[n + t]
              }
              ++r
            }
          }
          if (s > 0) {
            t[r] = t[s]
            for (let t = s * i, n = r * i, a = 0; a !== i; ++a) e[n + a] = e[t + a]
            ++r
          }
          return (
            r !== t.length
              ? ((this.times = Do.arraySlice(t, 0, r)), (this.values = Do.arraySlice(e, 0, r * i)))
              : ((this.times = t), (this.values = e)),
            this
          )
        }
        clone() {
          const t = Do.arraySlice(this.times, 0),
            e = Do.arraySlice(this.values, 0),
            i = new (0, this.constructor)(this.name, t, e)
          return (i.createInterpolant = this.createInterpolant), i
        }
      }
      ;(Fo.prototype.TimeBufferType = Float32Array),
        (Fo.prototype.ValueBufferType = Float32Array),
        (Fo.prototype.DefaultInterpolation = 2301)
      class Uo extends Fo {}
      ;(Uo.prototype.ValueTypeName = 'bool'),
        (Uo.prototype.ValueBufferType = Array),
        (Uo.prototype.DefaultInterpolation = 2300),
        (Uo.prototype.InterpolantFactoryMethodLinear = void 0),
        (Uo.prototype.InterpolantFactoryMethodSmooth = void 0)
      class ko extends Fo {}
      ko.prototype.ValueTypeName = 'color'
      class Oo extends Fo {}
      Oo.prototype.ValueTypeName = 'number'
      class Go extends Qo {
        constructor(t, e, i, n) {
          super(t, e, i, n)
        }
        interpolate_(t, e, i, n) {
          const s = this.resultBuffer,
            r = this.sampleValues,
            a = this.valueSize,
            o = (i - e) / (n - e)
          let l = t * a
          for (let c = l + a; l !== c; l += 4) Mt.slerpFlat(s, 0, r, l - a, r, l, o)
          return s
        }
      }
      class zo extends Fo {
        InterpolantFactoryMethodLinear(t) {
          return new Go(this.times, this.values, this.getValueSize(), t)
        }
      }
      ;(zo.prototype.ValueTypeName = 'quaternion'),
        (zo.prototype.DefaultInterpolation = 2301),
        (zo.prototype.InterpolantFactoryMethodSmooth = void 0)
      class Vo extends Fo {}
      ;(Vo.prototype.ValueTypeName = 'string'),
        (Vo.prototype.ValueBufferType = Array),
        (Vo.prototype.DefaultInterpolation = 2300),
        (Vo.prototype.InterpolantFactoryMethodLinear = void 0),
        (Vo.prototype.InterpolantFactoryMethodSmooth = void 0)
      class Ho extends Fo {}
      Ho.prototype.ValueTypeName = 'vector'
      class Wo {
        constructor(t, e = -1, i, n = 2500) {
          ;(this.name = t),
            (this.tracks = i),
            (this.duration = e),
            (this.blendMode = n),
            (this.uuid = ot()),
            this.duration < 0 && this.resetDuration()
        }
        static parse(t) {
          const e = [],
            i = t.tracks,
            n = 1 / (t.fps || 1)
          for (let r = 0, a = i.length; r !== a; ++r) e.push(qo(i[r]).scale(n))
          const s = new this(t.name, t.duration, e, t.blendMode)
          return (s.uuid = t.uuid), s
        }
        static toJSON(t) {
          const e = [],
            i = t.tracks,
            n = { name: t.name, duration: t.duration, tracks: e, uuid: t.uuid, blendMode: t.blendMode }
          for (let s = 0, r = i.length; s !== r; ++s) e.push(Fo.toJSON(i[s]))
          return n
        }
        static CreateFromMorphTargetSequence(t, e, i, n) {
          const s = e.length,
            r = []
          for (let a = 0; a < s; a++) {
            let t = [],
              o = []
            t.push((a + s - 1) % s, a, (a + 1) % s), o.push(0, 1, 0)
            const l = Do.getKeyframeOrder(t)
            ;(t = Do.sortedArray(t, 1, l)),
              (o = Do.sortedArray(o, 1, l)),
              n || 0 !== t[0] || (t.push(s), o.push(o[0])),
              r.push(new Oo('.morphTargetInfluences[' + e[a].name + ']', t, o).scale(1 / i))
          }
          return new this(t, -1, r)
        }
        static findByName(t, e) {
          let i = t
          if (!Array.isArray(t)) {
            const e = t
            i = (e.geometry && e.geometry.animations) || e.animations
          }
          for (let n = 0; n < i.length; n++) if (i[n].name === e) return i[n]
          return null
        }
        static CreateClipsFromMorphTargetSequences(t, e, i) {
          const n = {},
            s = /^([\w-]*?)([\d]+)$/
          for (let a = 0, o = t.length; a < o; a++) {
            const e = t[a],
              i = e.name.match(s)
            if (i && i.length > 1) {
              const t = i[1]
              let s = n[t]
              s || (n[t] = s = []), s.push(e)
            }
          }
          const r = []
          for (const a in n) r.push(this.CreateFromMorphTargetSequence(a, n[a], e, i))
          return r
        }
        static parseAnimation(t, e) {
          if (!t) return null
          const i = function (t, e, i, n, s) {
              if (0 !== i.length) {
                const r = [],
                  a = []
                Do.flattenJSON(i, r, a, n), 0 !== r.length && s.push(new t(e, r, a))
              }
            },
            n = [],
            s = t.name || 'default',
            r = t.fps || 30,
            a = t.blendMode
          let o = t.length || -1
          const l = t.hierarchy || []
          for (let c = 0; c < l.length; c++) {
            const t = l[c].keys
            if (t && 0 !== t.length)
              if (t[0].morphTargets) {
                const e = {}
                let i
                for (i = 0; i < t.length; i++)
                  if (t[i].morphTargets) for (let n = 0; n < t[i].morphTargets.length; n++) e[t[i].morphTargets[n]] = -1
                for (const s in e) {
                  const e = [],
                    r = []
                  for (let n = 0; n !== t[i].morphTargets.length; ++n) {
                    const n = t[i]
                    e.push(n.time), r.push(n.morphTarget === s ? 1 : 0)
                  }
                  n.push(new Oo('.morphTargetInfluence[' + s + ']', e, r))
                }
                o = e.length * (r || 1)
              } else {
                const s = '.bones[' + e[c].name + ']'
                i(Ho, s + '.position', t, 'pos', n),
                  i(zo, s + '.quaternion', t, 'rot', n),
                  i(Ho, s + '.scale', t, 'scl', n)
              }
          }
          return 0 === n.length ? null : new this(s, o, n, a)
        }
        resetDuration() {
          let t = 0
          for (let e = 0, i = this.tracks.length; e !== i; ++e) {
            const i = this.tracks[e]
            t = Math.max(t, i.times[i.times.length - 1])
          }
          return (this.duration = t), this
        }
        trim() {
          for (let t = 0; t < this.tracks.length; t++) this.tracks[t].trim(0, this.duration)
          return this
        }
        validate() {
          let t = !0
          for (let e = 0; e < this.tracks.length; e++) t = t && this.tracks[e].validate()
          return t
        }
        optimize() {
          for (let t = 0; t < this.tracks.length; t++) this.tracks[t].optimize()
          return this
        }
        clone() {
          const t = []
          for (let e = 0; e < this.tracks.length; e++) t.push(this.tracks[e].clone())
          return new this.constructor(this.name, this.duration, t, this.blendMode)
        }
        toJSON() {
          return this.constructor.toJSON(this)
        }
      }
      function qo(t) {
        if (void 0 === t.type) throw new Error('THREE.KeyframeTrack: track type undefined, can not parse')
        const e = (function (t) {
          switch (t.toLowerCase()) {
            case 'scalar':
            case 'double':
            case 'float':
            case 'number':
            case 'integer':
              return Oo
            case 'vector':
            case 'vector2':
            case 'vector3':
            case 'vector4':
              return Ho
            case 'color':
              return ko
            case 'quaternion':
              return zo
            case 'bool':
            case 'boolean':
              return Uo
            case 'string':
              return Vo
          }
          throw new Error('THREE.KeyframeTrack: Unsupported typeName: ' + t)
        })(t.type)
        if (void 0 === t.times) {
          const e = [],
            i = []
          Do.flattenJSON(t.keys, e, i, 'value'), (t.times = e), (t.values = i)
        }
        return void 0 !== e.parse ? e.parse(t) : new e(t.name, t.times, t.values, t.interpolation)
      }
      const jo = {
          enabled: !1,
          files: {},
          add: function (t, e) {
            !1 !== this.enabled && (this.files[t] = e)
          },
          get: function (t) {
            if (!1 !== this.enabled) return this.files[t]
          },
          remove: function (t) {
            delete this.files[t]
          },
          clear: function () {
            this.files = {}
          },
        },
        Yo = new (class {
          constructor(t, e, i) {
            const n = this
            let s,
              r = !1,
              a = 0,
              o = 0
            const l = []
            ;(this.onStart = void 0),
              (this.onLoad = t),
              (this.onProgress = e),
              (this.onError = i),
              (this.itemStart = function (t) {
                o++, !1 === r && void 0 !== n.onStart && n.onStart(t, a, o), (r = !0)
              }),
              (this.itemEnd = function (t) {
                a++,
                  void 0 !== n.onProgress && n.onProgress(t, a, o),
                  a === o && ((r = !1), void 0 !== n.onLoad && n.onLoad())
              }),
              (this.itemError = function (t) {
                void 0 !== n.onError && n.onError(t)
              }),
              (this.resolveURL = function (t) {
                return s ? s(t) : t
              }),
              (this.setURLModifier = function (t) {
                return (s = t), this
              }),
              (this.addHandler = function (t, e) {
                return l.push(t, e), this
              }),
              (this.removeHandler = function (t) {
                const e = l.indexOf(t)
                return -1 !== e && l.splice(e, 2), this
              }),
              (this.getHandler = function (t) {
                for (let e = 0, i = l.length; e < i; e += 2) {
                  const i = l[e],
                    n = l[e + 1]
                  if ((i.global && (i.lastIndex = 0), i.test(t))) return n
                }
                return null
              })
          }
        })()
      class Jo {
        constructor(t) {
          ;(this.manager = void 0 !== t ? t : Yo),
            (this.crossOrigin = 'anonymous'),
            (this.withCredentials = !1),
            (this.path = ''),
            (this.resourcePath = ''),
            (this.requestHeader = {})
        }
        load() {}
        loadAsync(t, e) {
          const i = this
          return new Promise(function (n, s) {
            i.load(t, n, e, s)
          })
        }
        parse() {}
        setCrossOrigin(t) {
          return (this.crossOrigin = t), this
        }
        setWithCredentials(t) {
          return (this.withCredentials = t), this
        }
        setPath(t) {
          return (this.path = t), this
        }
        setResourcePath(t) {
          return (this.resourcePath = t), this
        }
        setRequestHeader(t) {
          return (this.requestHeader = t), this
        }
      }
      const Xo = {}
      class Ko extends Jo {
        constructor(t) {
          super(t)
        }
        load(t, e, i, n) {
          void 0 === t && (t = ''), void 0 !== this.path && (t = this.path + t), (t = this.manager.resolveURL(t))
          const s = this,
            r = jo.get(t)
          if (void 0 !== r)
            return (
              s.manager.itemStart(t),
              setTimeout(function () {
                e && e(r), s.manager.itemEnd(t)
              }, 0),
              r
            )
          if (void 0 !== Xo[t]) return void Xo[t].push({ onLoad: e, onProgress: i, onError: n })
          const a = t.match(/^data:(.*?)(;base64)?,(.*)$/)
          let o
          if (a) {
            const i = a[1],
              r = !!a[2]
            let o = a[3]
            ;(o = decodeURIComponent(o)), r && (o = atob(o))
            try {
              let n
              const r = (this.responseType || '').toLowerCase()
              switch (r) {
                case 'arraybuffer':
                case 'blob':
                  const t = new Uint8Array(o.length)
                  for (let i = 0; i < o.length; i++) t[i] = o.charCodeAt(i)
                  n = 'blob' === r ? new Blob([t.buffer], { type: i }) : t.buffer
                  break
                case 'document':
                  const e = new DOMParser()
                  n = e.parseFromString(o, i)
                  break
                case 'json':
                  n = JSON.parse(o)
                  break
                default:
                  n = o
              }
              setTimeout(function () {
                e && e(n), s.manager.itemEnd(t)
              }, 0)
            } catch (e) {
              setTimeout(function () {
                n && n(e), s.manager.itemError(t), s.manager.itemEnd(t)
              }, 0)
            }
          } else {
            ;(Xo[t] = []),
              Xo[t].push({ onLoad: e, onProgress: i, onError: n }),
              (o = new XMLHttpRequest()),
              o.open('GET', t, !0),
              o.addEventListener(
                'load',
                function (e) {
                  const i = this.response,
                    n = Xo[t]
                  if ((delete Xo[t], 200 === this.status || 0 === this.status)) {
                    this.status, jo.add(t, i)
                    for (let t = 0, e = n.length; t < e; t++) {
                      const e = n[t]
                      e.onLoad && e.onLoad(i)
                    }
                    s.manager.itemEnd(t)
                  } else {
                    for (let t = 0, i = n.length; t < i; t++) {
                      const i = n[t]
                      i.onError && i.onError(e)
                    }
                    s.manager.itemError(t), s.manager.itemEnd(t)
                  }
                },
                !1,
              ),
              o.addEventListener(
                'progress',
                function (e) {
                  const i = Xo[t]
                  for (let t = 0, n = i.length; t < n; t++) {
                    const n = i[t]
                    n.onProgress && n.onProgress(e)
                  }
                },
                !1,
              ),
              o.addEventListener(
                'error',
                function (e) {
                  const i = Xo[t]
                  delete Xo[t]
                  for (let t = 0, n = i.length; t < n; t++) {
                    const n = i[t]
                    n.onError && n.onError(e)
                  }
                  s.manager.itemError(t), s.manager.itemEnd(t)
                },
                !1,
              ),
              o.addEventListener(
                'abort',
                function (e) {
                  const i = Xo[t]
                  delete Xo[t]
                  for (let t = 0, n = i.length; t < n; t++) {
                    const n = i[t]
                    n.onError && n.onError(e)
                  }
                  s.manager.itemError(t), s.manager.itemEnd(t)
                },
                !1,
              ),
              void 0 !== this.responseType && (o.responseType = this.responseType),
              void 0 !== this.withCredentials && (o.withCredentials = this.withCredentials),
              o.overrideMimeType && o.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : 'text/plain')
            for (const t in this.requestHeader) o.setRequestHeader(t, this.requestHeader[t])
            o.send(null)
          }
          return s.manager.itemStart(t), o
        }
        setResponseType(t) {
          return (this.responseType = t), this
        }
        setMimeType(t) {
          return (this.mimeType = t), this
        }
      }
      class Zo extends Jo {
        constructor(t) {
          super(t)
        }
        load(t, e, i, n) {
          const s = this,
            r = [],
            a = new Da(),
            o = new Ko(this.manager)
          o.setPath(this.path),
            o.setResponseType('arraybuffer'),
            o.setRequestHeader(this.requestHeader),
            o.setWithCredentials(s.withCredentials)
          let l = 0
          function c(c) {
            o.load(
              t[c],
              function (t) {
                const i = s.parse(t, !0)
                ;(r[c] = { width: i.width, height: i.height, format: i.format, mipmaps: i.mipmaps }),
                  (l += 1),
                  6 === l &&
                    (1 === i.mipmapCount && (a.minFilter = 1006),
                    (a.image = r),
                    (a.format = i.format),
                    (a.needsUpdate = !0),
                    e && e(a))
              },
              i,
              n,
            )
          }
          if (Array.isArray(t)) for (let h = 0, u = t.length; h < u; ++h) c(h)
          else
            o.load(
              t,
              function (t) {
                const i = s.parse(t, !0)
                if (i.isCubemap) {
                  const t = i.mipmaps.length / i.mipmapCount
                  for (let e = 0; e < t; e++) {
                    r[e] = { mipmaps: [] }
                    for (let t = 0; t < i.mipmapCount; t++)
                      r[e].mipmaps.push(i.mipmaps[e * i.mipmapCount + t]),
                        (r[e].format = i.format),
                        (r[e].width = i.width),
                        (r[e].height = i.height)
                  }
                  a.image = r
                } else (a.image.width = i.width), (a.image.height = i.height), (a.mipmaps = i.mipmaps)
                1 === i.mipmapCount && (a.minFilter = 1006), (a.format = i.format), (a.needsUpdate = !0), e && e(a)
              },
              i,
              n,
            )
          return a
        }
      }
      class $o extends Jo {
        constructor(t) {
          super(t)
        }
        load(t, e, i, n) {
          void 0 !== this.path && (t = this.path + t), (t = this.manager.resolveURL(t))
          const s = this,
            r = jo.get(t)
          if (void 0 !== r)
            return (
              s.manager.itemStart(t),
              setTimeout(function () {
                e && e(r), s.manager.itemEnd(t)
              }, 0),
              r
            )
          const a = document.createElementNS('http://www.w3.org/1999/xhtml', 'img')
          function o() {
            a.removeEventListener('load', o, !1),
              a.removeEventListener('error', l, !1),
              jo.add(t, this),
              e && e(this),
              s.manager.itemEnd(t)
          }
          function l(e) {
            a.removeEventListener('load', o, !1),
              a.removeEventListener('error', l, !1),
              n && n(e),
              s.manager.itemError(t),
              s.manager.itemEnd(t)
          }
          return (
            a.addEventListener('load', o, !1),
            a.addEventListener('error', l, !1),
            'data:' !== t.substr(0, 5) && void 0 !== this.crossOrigin && (a.crossOrigin = this.crossOrigin),
            s.manager.itemStart(t),
            (a.src = t),
            a
          )
        }
      }
      class tl extends Jo {
        constructor(t) {
          super(t)
        }
        load(t, e, i, n) {
          const s = new Ui(),
            r = new $o(this.manager)
          r.setCrossOrigin(this.crossOrigin), r.setPath(this.path)
          let a = 0
          function o(i) {
            r.load(
              t[i],
              function (t) {
                ;(s.images[i] = t), a++, 6 === a && ((s.needsUpdate = !0), e && e(s))
              },
              void 0,
              n,
            )
          }
          for (let l = 0; l < t.length; ++l) o(l)
          return s
        }
      }
      class el extends Jo {
        constructor(t) {
          super(t)
        }
        load(t, e, i, n) {
          const s = this,
            r = new aa(),
            a = new Ko(this.manager)
          return (
            a.setResponseType('arraybuffer'),
            a.setRequestHeader(this.requestHeader),
            a.setPath(this.path),
            a.setWithCredentials(s.withCredentials),
            a.load(
              t,
              function (t) {
                const i = s.parse(t)
                i &&
                  (void 0 !== i.image
                    ? (r.image = i.image)
                    : void 0 !== i.data &&
                      ((r.image.width = i.width), (r.image.height = i.height), (r.image.data = i.data)),
                  (r.wrapS = void 0 !== i.wrapS ? i.wrapS : 1001),
                  (r.wrapT = void 0 !== i.wrapT ? i.wrapT : 1001),
                  (r.magFilter = void 0 !== i.magFilter ? i.magFilter : 1006),
                  (r.minFilter = void 0 !== i.minFilter ? i.minFilter : 1006),
                  (r.anisotropy = void 0 !== i.anisotropy ? i.anisotropy : 1),
                  void 0 !== i.encoding && (r.encoding = i.encoding),
                  void 0 !== i.flipY && (r.flipY = i.flipY),
                  void 0 !== i.format && (r.format = i.format),
                  void 0 !== i.type && (r.type = i.type),
                  void 0 !== i.mipmaps && ((r.mipmaps = i.mipmaps), (r.minFilter = 1008)),
                  1 === i.mipmapCount && (r.minFilter = 1006),
                  void 0 !== i.generateMipmaps && (r.generateMipmaps = i.generateMipmaps),
                  (r.needsUpdate = !0),
                  e && e(r, i))
              },
              i,
              n,
            ),
            r
          )
        }
      }
      class il extends Jo {
        constructor(t) {
          super(t)
        }
        load(t, e, i, n) {
          const s = new xt(),
            r = new $o(this.manager)
          return (
            r.setCrossOrigin(this.crossOrigin),
            r.setPath(this.path),
            r.load(
              t,
              function (i) {
                s.image = i
                const n = t.search(/\.jpe?g($|\?)/i) > 0 || 0 === t.search(/^data\:image\/jpeg/)
                ;(s.format = n ? 1022 : 1023), (s.needsUpdate = !0), void 0 !== e && e(s)
              },
              i,
              n,
            ),
            s
          )
        }
      }
      class nl extends Qa {
        constructor() {
          super(), (this.type = 'CurvePath'), (this.curves = []), (this.autoClose = !1)
        }
        add(t) {
          this.curves.push(t)
        }
        closePath() {
          const t = this.curves[0].getPoint(0),
            e = this.curves[this.curves.length - 1].getPoint(1)
          t.equals(e) || this.curves.push(new ja(e, t))
        }
        getPoint(t) {
          const e = t * this.getLength(),
            i = this.getCurveLengths()
          let n = 0
          for (; n < i.length; ) {
            if (i[n] >= e) {
              const t = i[n] - e,
                s = this.curves[n],
                r = s.getLength(),
                a = 0 === r ? 0 : 1 - t / r
              return s.getPointAt(a)
            }
            n++
          }
          return null
        }
        getLength() {
          const t = this.getCurveLengths()
          return t[t.length - 1]
        }
        updateArcLengths() {
          ;(this.needsUpdate = !0), (this.cacheLengths = null), this.getCurveLengths()
        }
        getCurveLengths() {
          if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths
          const t = []
          let e = 0
          for (let i = 0, n = this.curves.length; i < n; i++) (e += this.curves[i].getLength()), t.push(e)
          return (this.cacheLengths = t), t
        }
        getSpacedPoints(t = 40) {
          const e = []
          for (let i = 0; i <= t; i++) e.push(this.getPoint(i / t))
          return this.autoClose && e.push(e[0]), e
        }
        getPoints(t = 12) {
          const e = []
          let i
          for (let n = 0, s = this.curves; n < s.length; n++) {
            const r = s[n],
              a =
                r && r.isEllipseCurve
                  ? 2 * t
                  : r && (r.isLineCurve || r.isLineCurve3)
                  ? 1
                  : r && r.isSplineCurve
                  ? t * r.points.length
                  : t,
              o = r.getPoints(a)
            for (let t = 0; t < o.length; t++) {
              const n = o[t]
              ;(i && i.equals(n)) || (e.push(n), (i = n))
            }
          }
          return this.autoClose && e.length > 1 && !e[e.length - 1].equals(e[0]) && e.push(e[0]), e
        }
        copy(t) {
          super.copy(t), (this.curves = [])
          for (let e = 0, i = t.curves.length; e < i; e++) {
            const i = t.curves[e]
            this.curves.push(i.clone())
          }
          return (this.autoClose = t.autoClose), this
        }
        toJSON() {
          const t = super.toJSON()
          ;(t.autoClose = this.autoClose), (t.curves = [])
          for (let e = 0, i = this.curves.length; e < i; e++) {
            const i = this.curves[e]
            t.curves.push(i.toJSON())
          }
          return t
        }
        fromJSON(t) {
          super.fromJSON(t), (this.autoClose = t.autoClose), (this.curves = [])
          for (let e = 0, i = t.curves.length; e < i; e++) {
            const i = t.curves[e]
            this.curves.push(new Ka[i.type]().fromJSON(i))
          }
          return this
        }
      }
      class sl extends nl {
        constructor(t) {
          super(), (this.type = 'Path'), (this.currentPoint = new gt()), t && this.setFromPoints(t)
        }
        setFromPoints(t) {
          this.moveTo(t[0].x, t[0].y)
          for (let e = 1, i = t.length; e < i; e++) this.lineTo(t[e].x, t[e].y)
          return this
        }
        moveTo(t, e) {
          return this.currentPoint.set(t, e), this
        }
        lineTo(t, e) {
          const i = new ja(this.currentPoint.clone(), new gt(t, e))
          return this.curves.push(i), this.currentPoint.set(t, e), this
        }
        quadraticCurveTo(t, e, i, n) {
          const s = new Ya(this.currentPoint.clone(), new gt(t, e), new gt(i, n))
          return this.curves.push(s), this.currentPoint.set(i, n), this
        }
        bezierCurveTo(t, e, i, n, s, r) {
          const a = new Wa(this.currentPoint.clone(), new gt(t, e), new gt(i, n), new gt(s, r))
          return this.curves.push(a), this.currentPoint.set(s, r), this
        }
        splineThru(t) {
          const e = [this.currentPoint.clone()].concat(t),
            i = new Xa(e)
          return this.curves.push(i), this.currentPoint.copy(t[t.length - 1]), this
        }
        arc(t, e, i, n, s, r) {
          const a = this.currentPoint.x,
            o = this.currentPoint.y
          return this.absarc(t + a, e + o, i, n, s, r), this
        }
        absarc(t, e, i, n, s, r) {
          return this.absellipse(t, e, i, i, n, s, r), this
        }
        ellipse(t, e, i, n, s, r, a, o) {
          const l = this.currentPoint.x,
            c = this.currentPoint.y
          return this.absellipse(t + l, e + c, i, n, s, r, a, o), this
        }
        absellipse(t, e, i, n, s, r, a, o) {
          const l = new Ra(t, e, i, n, s, r, a, o)
          if (this.curves.length > 0) {
            const t = l.getPoint(0)
            t.equals(this.currentPoint) || this.lineTo(t.x, t.y)
          }
          this.curves.push(l)
          const c = l.getPoint(1)
          return this.currentPoint.copy(c), this
        }
        copy(t) {
          return super.copy(t), this.currentPoint.copy(t.currentPoint), this
        }
        toJSON() {
          const t = super.toJSON()
          return (t.currentPoint = this.currentPoint.toArray()), t
        }
        fromJSON(t) {
          return super.fromJSON(t), this.currentPoint.fromArray(t.currentPoint), this
        }
      }
      class rl extends sl {
        constructor(t) {
          super(t), (this.uuid = ot()), (this.type = 'Shape'), (this.holes = [])
        }
        getPointsHoles(t) {
          const e = []
          for (let i = 0, n = this.holes.length; i < n; i++) e[i] = this.holes[i].getPoints(t)
          return e
        }
        extractPoints(t) {
          return { shape: this.getPoints(t), holes: this.getPointsHoles(t) }
        }
        copy(t) {
          super.copy(t), (this.holes = [])
          for (let e = 0, i = t.holes.length; e < i; e++) {
            const i = t.holes[e]
            this.holes.push(i.clone())
          }
          return this
        }
        toJSON() {
          const t = super.toJSON()
          ;(t.uuid = this.uuid), (t.holes = [])
          for (let e = 0, i = this.holes.length; e < i; e++) {
            const i = this.holes[e]
            t.holes.push(i.toJSON())
          }
          return t
        }
        fromJSON(t) {
          super.fromJSON(t), (this.uuid = t.uuid), (this.holes = [])
          for (let e = 0, i = t.holes.length; e < i; e++) {
            const i = t.holes[e]
            this.holes.push(new sl().fromJSON(i))
          }
          return this
        }
      }
      class al extends Se {
        constructor(t, e = 1) {
          super(), (this.type = 'Light'), (this.color = new Ye(t)), (this.intensity = e)
        }
        dispose() {}
        copy(t) {
          return super.copy(t), this.color.copy(t.color), (this.intensity = t.intensity), this
        }
        toJSON(t) {
          const e = super.toJSON(t)
          return (
            (e.object.color = this.color.getHex()),
            (e.object.intensity = this.intensity),
            void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()),
            void 0 !== this.distance && (e.object.distance = this.distance),
            void 0 !== this.angle && (e.object.angle = this.angle),
            void 0 !== this.decay && (e.object.decay = this.decay),
            void 0 !== this.penumbra && (e.object.penumbra = this.penumbra),
            void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()),
            e
          )
        }
      }
      ;(al.prototype.isLight = !0),
        (class extends al {
          constructor(t, e, i) {
            super(t, i),
              (this.type = 'HemisphereLight'),
              this.position.copy(Se.DefaultUp),
              this.updateMatrix(),
              (this.groundColor = new Ye(e))
          }
          copy(t) {
            return al.prototype.copy.call(this, t), this.groundColor.copy(t.groundColor), this
          }
        }.prototype.isHemisphereLight = !0)
      const ol = new ne(),
        ll = new Et(),
        cl = new Et()
      class hl {
        constructor(t) {
          ;(this.camera = t),
            (this.bias = 0),
            (this.normalBias = 0),
            (this.radius = 1),
            (this.mapSize = new gt(512, 512)),
            (this.map = null),
            (this.mapPass = null),
            (this.matrix = new ne()),
            (this.autoUpdate = !0),
            (this.needsUpdate = !1),
            (this._frustum = new qi()),
            (this._frameExtents = new gt(1, 1)),
            (this._viewportCount = 1),
            (this._viewports = [new _t(0, 0, 1, 1)])
        }
        getViewportCount() {
          return this._viewportCount
        }
        getFrustum() {
          return this._frustum
        }
        updateMatrices(t) {
          const e = this.camera,
            i = this.matrix
          ll.setFromMatrixPosition(t.matrixWorld),
            e.position.copy(ll),
            cl.setFromMatrixPosition(t.target.matrixWorld),
            e.lookAt(cl),
            e.updateMatrixWorld(),
            ol.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
            this._frustum.setFromProjectionMatrix(ol),
            i.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
            i.multiply(e.projectionMatrix),
            i.multiply(e.matrixWorldInverse)
        }
        getViewport(t) {
          return this._viewports[t]
        }
        getFrameExtents() {
          return this._frameExtents
        }
        dispose() {
          this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose()
        }
        copy(t) {
          return (
            (this.camera = t.camera.clone()),
            (this.bias = t.bias),
            (this.radius = t.radius),
            this.mapSize.copy(t.mapSize),
            this
          )
        }
        clone() {
          return new this.constructor().copy(this)
        }
        toJSON() {
          const t = {}
          return (
            0 !== this.bias && (t.bias = this.bias),
            0 !== this.normalBias && (t.normalBias = this.normalBias),
            1 !== this.radius && (t.radius = this.radius),
            (512 === this.mapSize.x && 512 === this.mapSize.y) || (t.mapSize = this.mapSize.toArray()),
            (t.camera = this.camera.toJSON(!1).object),
            delete t.camera.matrix,
            t
          )
        }
      }
      class ul extends hl {
        constructor() {
          super(new Ni(50, 1, 0.5, 500)), (this.focus = 1)
        }
        updateMatrices(t) {
          const e = this.camera,
            i = 2 * at * t.angle * this.focus,
            n = this.mapSize.width / this.mapSize.height,
            s = t.distance || e.far
          ;(i === e.fov && n === e.aspect && s === e.far) ||
            ((e.fov = i), (e.aspect = n), (e.far = s), e.updateProjectionMatrix()),
            super.updateMatrices(t)
        }
        copy(t) {
          return super.copy(t), (this.focus = t.focus), this
        }
      }
      ul.prototype.isSpotLightShadow = !0
      class dl extends al {
        constructor(t, e, i = 0, n = Math.PI / 3, s = 0, r = 1) {
          super(t, e),
            (this.type = 'SpotLight'),
            this.position.copy(Se.DefaultUp),
            this.updateMatrix(),
            (this.target = new Se()),
            (this.distance = i),
            (this.angle = n),
            (this.penumbra = s),
            (this.decay = r),
            (this.shadow = new ul())
        }
        get power() {
          return this.intensity * Math.PI
        }
        set power(t) {
          this.intensity = t / Math.PI
        }
        dispose() {
          this.shadow.dispose()
        }
        copy(t) {
          return (
            super.copy(t),
            (this.distance = t.distance),
            (this.angle = t.angle),
            (this.penumbra = t.penumbra),
            (this.decay = t.decay),
            (this.target = t.target.clone()),
            (this.shadow = t.shadow.clone()),
            this
          )
        }
      }
      dl.prototype.isSpotLight = !0
      const pl = new ne(),
        Al = new Et(),
        gl = new Et()
      class ml extends hl {
        constructor() {
          super(new Ni(90, 1, 0.5, 500)),
            (this._frameExtents = new gt(4, 2)),
            (this._viewportCount = 6),
            (this._viewports = [
              new _t(2, 1, 1, 1),
              new _t(0, 1, 1, 1),
              new _t(3, 1, 1, 1),
              new _t(1, 1, 1, 1),
              new _t(3, 0, 1, 1),
              new _t(1, 0, 1, 1),
            ]),
            (this._cubeDirections = [
              new Et(1, 0, 0),
              new Et(-1, 0, 0),
              new Et(0, 0, 1),
              new Et(0, 0, -1),
              new Et(0, 1, 0),
              new Et(0, -1, 0),
            ]),
            (this._cubeUps = [
              new Et(0, 1, 0),
              new Et(0, 1, 0),
              new Et(0, 1, 0),
              new Et(0, 1, 0),
              new Et(0, 0, 1),
              new Et(0, 0, -1),
            ])
        }
        updateMatrices(t, e = 0) {
          const i = this.camera,
            n = this.matrix,
            s = t.distance || i.far
          s !== i.far && ((i.far = s), i.updateProjectionMatrix()),
            Al.setFromMatrixPosition(t.matrixWorld),
            i.position.copy(Al),
            gl.copy(i.position),
            gl.add(this._cubeDirections[e]),
            i.up.copy(this._cubeUps[e]),
            i.lookAt(gl),
            i.updateMatrixWorld(),
            n.makeTranslation(-Al.x, -Al.y, -Al.z),
            pl.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse),
            this._frustum.setFromProjectionMatrix(pl)
        }
      }
      ml.prototype.isPointLightShadow = !0
      class fl extends al {
        constructor(t, e, i = 0, n = 1) {
          super(t, e), (this.type = 'PointLight'), (this.distance = i), (this.decay = n), (this.shadow = new ml())
        }
        get power() {
          return 4 * this.intensity * Math.PI
        }
        set power(t) {
          this.intensity = t / (4 * Math.PI)
        }
        dispose() {
          this.shadow.dispose()
        }
        copy(t) {
          return (
            super.copy(t), (this.distance = t.distance), (this.decay = t.decay), (this.shadow = t.shadow.clone()), this
          )
        }
      }
      fl.prototype.isPointLight = !0
      class vl extends hl {
        constructor() {
          super(new an(-5, 5, 5, -5, 0.5, 500))
        }
      }
      vl.prototype.isDirectionalLightShadow = !0
      class yl extends al {
        constructor(t, e) {
          super(t, e),
            (this.type = 'DirectionalLight'),
            this.position.copy(Se.DefaultUp),
            this.updateMatrix(),
            (this.target = new Se()),
            (this.shadow = new vl())
        }
        dispose() {
          this.shadow.dispose()
        }
        copy(t) {
          return super.copy(t), (this.target = t.target.clone()), (this.shadow = t.shadow.clone()), this
        }
      }
      ;(yl.prototype.isDirectionalLight = !0),
        (class extends al {
          constructor(t, e) {
            super(t, e), (this.type = 'AmbientLight')
          }
        }.prototype.isAmbientLight = !0),
        (class extends al {
          constructor(t, e, i = 10, n = 10) {
            super(t, e), (this.type = 'RectAreaLight'), (this.width = i), (this.height = n)
          }
          copy(t) {
            return super.copy(t), (this.width = t.width), (this.height = t.height), this
          }
          toJSON(t) {
            const e = super.toJSON(t)
            return (e.object.width = this.width), (e.object.height = this.height), e
          }
        }.prototype.isRectAreaLight = !0)
      class xl {
        constructor() {
          this.coefficients = []
          for (let t = 0; t < 9; t++) this.coefficients.push(new Et())
        }
        set(t) {
          for (let e = 0; e < 9; e++) this.coefficients[e].copy(t[e])
          return this
        }
        zero() {
          for (let t = 0; t < 9; t++) this.coefficients[t].set(0, 0, 0)
          return this
        }
        getAt(t, e) {
          const i = t.x,
            n = t.y,
            s = t.z,
            r = this.coefficients
          return (
            e.copy(r[0]).multiplyScalar(0.282095),
            e.addScaledVector(r[1], 0.488603 * n),
            e.addScaledVector(r[2], 0.488603 * s),
            e.addScaledVector(r[3], 0.488603 * i),
            e.addScaledVector(r[4], i * n * 1.092548),
            e.addScaledVector(r[5], n * s * 1.092548),
            e.addScaledVector(r[6], 0.315392 * (3 * s * s - 1)),
            e.addScaledVector(r[7], i * s * 1.092548),
            e.addScaledVector(r[8], 0.546274 * (i * i - n * n)),
            e
          )
        }
        getIrradianceAt(t, e) {
          const i = t.x,
            n = t.y,
            s = t.z,
            r = this.coefficients
          return (
            e.copy(r[0]).multiplyScalar(0.886227),
            e.addScaledVector(r[1], 1.023328 * n),
            e.addScaledVector(r[2], 1.023328 * s),
            e.addScaledVector(r[3], 1.023328 * i),
            e.addScaledVector(r[4], 0.858086 * i * n),
            e.addScaledVector(r[5], 0.858086 * n * s),
            e.addScaledVector(r[6], 0.743125 * s * s - 0.247708),
            e.addScaledVector(r[7], 0.858086 * i * s),
            e.addScaledVector(r[8], 0.429043 * (i * i - n * n)),
            e
          )
        }
        add(t) {
          for (let e = 0; e < 9; e++) this.coefficients[e].add(t.coefficients[e])
          return this
        }
        addScaledSH(t, e) {
          for (let i = 0; i < 9; i++) this.coefficients[i].addScaledVector(t.coefficients[i], e)
          return this
        }
        scale(t) {
          for (let e = 0; e < 9; e++) this.coefficients[e].multiplyScalar(t)
          return this
        }
        lerp(t, e) {
          for (let i = 0; i < 9; i++) this.coefficients[i].lerp(t.coefficients[i], e)
          return this
        }
        equals(t) {
          for (let e = 0; e < 9; e++) if (!this.coefficients[e].equals(t.coefficients[e])) return !1
          return !0
        }
        copy(t) {
          return this.set(t.coefficients)
        }
        clone() {
          return new this.constructor().copy(this)
        }
        fromArray(t, e = 0) {
          const i = this.coefficients
          for (let n = 0; n < 9; n++) i[n].fromArray(t, e + 3 * n)
          return this
        }
        toArray(t = [], e = 0) {
          const i = this.coefficients
          for (let n = 0; n < 9; n++) i[n].toArray(t, e + 3 * n)
          return t
        }
        static getBasisAt(t, e) {
          const i = t.x,
            n = t.y,
            s = t.z
          ;(e[0] = 0.282095),
            (e[1] = 0.488603 * n),
            (e[2] = 0.488603 * s),
            (e[3] = 0.488603 * i),
            (e[4] = 1.092548 * i * n),
            (e[5] = 1.092548 * n * s),
            (e[6] = 0.315392 * (3 * s * s - 1)),
            (e[7] = 1.092548 * i * s),
            (e[8] = 0.546274 * (i * i - n * n))
        }
      }
      xl.prototype.isSphericalHarmonics3 = !0
      class wl extends al {
        constructor(t = new xl(), e = 1) {
          super(void 0, e), (this.sh = t)
        }
        copy(t) {
          return super.copy(t), this.sh.copy(t.sh), this
        }
        fromJSON(t) {
          return (this.intensity = t.intensity), this.sh.fromArray(t.sh), this
        }
        toJSON(t) {
          const e = super.toJSON(t)
          return (e.object.sh = this.sh.toArray()), e
        }
      }
      wl.prototype.isLightProbe = !0
      class _l {
        static decodeText(t) {
          if ('undefined' != typeof TextDecoder) return new TextDecoder().decode(t)
          let e = ''
          for (let i = 0, n = t.length; i < n; i++) e += String.fromCharCode(t[i])
          try {
            return decodeURIComponent(escape(e))
          } catch (t) {
            return e
          }
        }
        static extractUrlBase(t) {
          const e = t.lastIndexOf('/')
          return -1 === e ? './' : t.substr(0, e + 1)
        }
      }
      ;((class extends hi {
        constructor() {
          super(), (this.type = 'InstancedBufferGeometry'), (this.instanceCount = 1 / 0)
        }
        copy(t) {
          return super.copy(t), (this.instanceCount = t.instanceCount), this
        }
        clone() {
          return new this.constructor().copy(this)
        }
        toJSON() {
          const t = super.toJSON(this)
          return (t.instanceCount = this.instanceCount), (t.isInstancedBufferGeometry = !0), t
        }
      }.prototype.isInstancedBufferGeometry = !0),
        (class extends Ze {
          constructor(t, e, i, n = 1) {
            'number' == typeof i && ((n = i), (i = !1)), super(t, e, i), (this.meshPerAttribute = n)
          }
          copy(t) {
            return super.copy(t), (this.meshPerAttribute = t.meshPerAttribute), this
          }
          toJSON() {
            const t = super.toJSON()
            return (t.meshPerAttribute = this.meshPerAttribute), (t.isInstancedBufferAttribute = !0), t
          }
        }.prototype.isInstancedBufferAttribute = !0))
      class Il extends Jo {
        constructor(t) {
          super(t), (this.options = { premultiplyAlpha: 'none' })
        }
        setOptions(t) {
          return (this.options = t), this
        }
        load(t, e, i, n) {
          void 0 === t && (t = ''), void 0 !== this.path && (t = this.path + t), (t = this.manager.resolveURL(t))
          const s = this,
            r = jo.get(t)
          if (void 0 !== r)
            return (
              s.manager.itemStart(t),
              setTimeout(function () {
                e && e(r), s.manager.itemEnd(t)
              }, 0),
              r
            )
          const a = {}
          ;(a.credentials = 'anonymous' === this.crossOrigin ? 'same-origin' : 'include'),
            (a.headers = this.requestHeader),
            fetch(t, a)
              .then(function (t) {
                return t.blob()
              })
              .then(function (t) {
                return createImageBitmap(t, Object.assign(s.options, { colorSpaceConversion: 'none' }))
              })
              .then(function (i) {
                jo.add(t, i), e && e(i), s.manager.itemEnd(t)
              })
              .catch(function (e) {
                n && n(e), s.manager.itemError(t), s.manager.itemEnd(t)
              }),
            s.manager.itemStart(t)
        }
      }
      let Cl
      Il.prototype.isImageBitmapLoader = !0
      class Ml extends Jo {
        constructor(t) {
          super(t)
        }
        load(t, e, i, n) {
          const s = this,
            r = new Ko(this.manager)
          r.setResponseType('arraybuffer'),
            r.setPath(this.path),
            r.setRequestHeader(this.requestHeader),
            r.setWithCredentials(this.withCredentials),
            r.load(
              t,
              function (i) {
                try {
                  const t = i.slice(0)
                  ;(void 0 === Cl && (Cl = new (window.AudioContext || window.webkitAudioContext)()),
                  Cl).decodeAudioData(t, function (t) {
                    e(t)
                  })
                } catch (e) {
                  n && n(e), s.manager.itemError(t)
                }
              },
              i,
              n,
            )
        }
      }
      ;((class extends wl {
        constructor(t, e, i = 1) {
          super(void 0, i)
          const n = new Ye().set(t),
            s = new Ye().set(e),
            r = new Et(n.r, n.g, n.b),
            a = new Et(s.r, s.g, s.b),
            o = Math.sqrt(Math.PI),
            l = o * Math.sqrt(0.75)
          this.sh.coefficients[0].copy(r).add(a).multiplyScalar(o),
            this.sh.coefficients[1].copy(r).sub(a).multiplyScalar(l)
        }
      }.prototype.isHemisphereLightProbe = !0),
        (class extends wl {
          constructor(t, e = 1) {
            super(void 0, e)
            const i = new Ye().set(t)
            this.sh.coefficients[0].set(i.r, i.g, i.b).multiplyScalar(2 * Math.sqrt(Math.PI))
          }
        }.prototype.isAmbientLightProbe = !0))
      class El {
        constructor(t, e, i) {
          let n, s, r
          switch (((this.binding = t), (this.valueSize = i), e)) {
            case 'quaternion':
              ;(n = this._slerp),
                (s = this._slerpAdditive),
                (r = this._setAdditiveIdentityQuaternion),
                (this.buffer = new Float64Array(6 * i)),
                (this._workIndex = 5)
              break
            case 'string':
            case 'bool':
              ;(n = this._select),
                (s = this._select),
                (r = this._setAdditiveIdentityOther),
                (this.buffer = new Array(5 * i))
              break
            default:
              ;(n = this._lerp),
                (s = this._lerpAdditive),
                (r = this._setAdditiveIdentityNumeric),
                (this.buffer = new Float64Array(5 * i))
          }
          ;(this._mixBufferRegion = n),
            (this._mixBufferRegionAdditive = s),
            (this._setIdentity = r),
            (this._origIndex = 3),
            (this._addIndex = 4),
            (this.cumulativeWeight = 0),
            (this.cumulativeWeightAdditive = 0),
            (this.useCount = 0),
            (this.referenceCount = 0)
        }
        accumulate(t, e) {
          const i = this.buffer,
            n = this.valueSize,
            s = t * n + n
          let r = this.cumulativeWeight
          if (0 === r) {
            for (let t = 0; t !== n; ++t) i[s + t] = i[t]
            r = e
          } else {
            r += e
            const t = e / r
            this._mixBufferRegion(i, s, 0, t, n)
          }
          this.cumulativeWeight = r
        }
        accumulateAdditive(t) {
          const e = this.buffer,
            i = this.valueSize,
            n = i * this._addIndex
          0 === this.cumulativeWeightAdditive && this._setIdentity(),
            this._mixBufferRegionAdditive(e, n, 0, t, i),
            (this.cumulativeWeightAdditive += t)
        }
        apply(t) {
          const e = this.valueSize,
            i = this.buffer,
            n = t * e + e,
            s = this.cumulativeWeight,
            r = this.cumulativeWeightAdditive,
            a = this.binding
          if (((this.cumulativeWeight = 0), (this.cumulativeWeightAdditive = 0), s < 1)) {
            const t = e * this._origIndex
            this._mixBufferRegion(i, n, t, 1 - s, e)
          }
          r > 0 && this._mixBufferRegionAdditive(i, n, this._addIndex * e, 1, e)
          for (let o = e, l = e + e; o !== l; ++o)
            if (i[o] !== i[o + e]) {
              a.setValue(i, n)
              break
            }
        }
        saveOriginalState() {
          const t = this.binding,
            e = this.buffer,
            i = this.valueSize,
            n = i * this._origIndex
          t.getValue(e, n)
          for (let s = i, r = n; s !== r; ++s) e[s] = e[n + (s % i)]
          this._setIdentity(), (this.cumulativeWeight = 0), (this.cumulativeWeightAdditive = 0)
        }
        restoreOriginalState() {
          const t = 3 * this.valueSize
          this.binding.setValue(this.buffer, t)
        }
        _setAdditiveIdentityNumeric() {
          const t = this._addIndex * this.valueSize,
            e = t + this.valueSize
          for (let i = t; i < e; i++) this.buffer[i] = 0
        }
        _setAdditiveIdentityQuaternion() {
          this._setAdditiveIdentityNumeric(), (this.buffer[this._addIndex * this.valueSize + 3] = 1)
        }
        _setAdditiveIdentityOther() {
          const t = this._origIndex * this.valueSize,
            e = this._addIndex * this.valueSize
          for (let i = 0; i < this.valueSize; i++) this.buffer[e + i] = this.buffer[t + i]
        }
        _select(t, e, i, n, s) {
          if (n >= 0.5) for (let r = 0; r !== s; ++r) t[e + r] = t[i + r]
        }
        _slerp(t, e, i, n) {
          Mt.slerpFlat(t, e, t, e, t, i, n)
        }
        _slerpAdditive(t, e, i, n, s) {
          const r = this._workIndex * s
          Mt.multiplyQuaternionsFlat(t, r, t, e, t, i), Mt.slerpFlat(t, e, t, e, t, r, n)
        }
        _lerp(t, e, i, n, s) {
          const r = 1 - n
          for (let a = 0; a !== s; ++a) {
            const s = e + a
            t[s] = t[s] * r + t[i + a] * n
          }
        }
        _lerpAdditive(t, e, i, n, s) {
          for (let r = 0; r !== s; ++r) {
            const s = e + r
            t[s] = t[s] + t[i + r] * n
          }
        }
      }
      const bl = new RegExp('[\\[\\]\\.:\\/]', 'g'),
        Sl = '[^' + '\\[\\]\\.:\\/'.replace('\\.', '') + ']',
        Bl = /((?:WC+[\/:])*)/.source.replace('WC', '[^\\[\\]\\.:\\/]'),
        Tl = /(WCOD+)?/.source.replace('WCOD', Sl),
        Ll = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace('WC', '[^\\[\\]\\.:\\/]'),
        Dl = /\.(WC+)(?:\[(.+)\])?/.source.replace('WC', '[^\\[\\]\\.:\\/]'),
        Ql = new RegExp('^' + Bl + Tl + Ll + Dl + '$'),
        Rl = ['material', 'materials', 'bones']
      class Pl {
        constructor(t, e, i) {
          ;(this.path = e),
            (this.parsedPath = i || Pl.parseTrackName(e)),
            (this.node = Pl.findNode(t, this.parsedPath.nodeName) || t),
            (this.rootNode = t),
            (this.getValue = this._getValue_unbound),
            (this.setValue = this._setValue_unbound)
        }
        static create(t, e, i) {
          return t && t.isAnimationObjectGroup ? new Pl.Composite(t, e, i) : new Pl(t, e, i)
        }
        static sanitizeNodeName(t) {
          return t.replace(/\s/g, '_').replace(bl, '')
        }
        static parseTrackName(t) {
          const e = Ql.exec(t)
          if (!e) throw new Error('PropertyBinding: Cannot parse trackName: ' + t)
          const i = { nodeName: e[2], objectName: e[3], objectIndex: e[4], propertyName: e[5], propertyIndex: e[6] },
            n = i.nodeName && i.nodeName.lastIndexOf('.')
          if (void 0 !== n && -1 !== n) {
            const t = i.nodeName.substring(n + 1)
            ;-1 !== Rl.indexOf(t) && ((i.nodeName = i.nodeName.substring(0, n)), (i.objectName = t))
          }
          if (null === i.propertyName || 0 === i.propertyName.length)
            throw new Error('PropertyBinding: can not parse propertyName from trackName: ' + t)
          return i
        }
        static findNode(t, e) {
          if (!e || '' === e || '.' === e || -1 === e || e === t.name || e === t.uuid) return t
          if (t.skeleton) {
            const i = t.skeleton.getBoneByName(e)
            if (void 0 !== i) return i
          }
          if (t.children) {
            const i = function (t) {
                for (let n = 0; n < t.length; n++) {
                  const s = t[n]
                  if (s.name === e || s.uuid === e) return s
                  const r = i(s.children)
                  if (r) return r
                }
                return null
              },
              n = i(t.children)
            if (n) return n
          }
          return null
        }
        _getValue_unavailable() {}
        _setValue_unavailable() {}
        _getValue_direct(t, e) {
          t[e] = this.node[this.propertyName]
        }
        _getValue_array(t, e) {
          const i = this.resolvedProperty
          for (let n = 0, s = i.length; n !== s; ++n) t[e++] = i[n]
        }
        _getValue_arrayElement(t, e) {
          t[e] = this.resolvedProperty[this.propertyIndex]
        }
        _getValue_toArray(t, e) {
          this.resolvedProperty.toArray(t, e)
        }
        _setValue_direct(t, e) {
          this.targetObject[this.propertyName] = t[e]
        }
        _setValue_direct_setNeedsUpdate(t, e) {
          ;(this.targetObject[this.propertyName] = t[e]), (this.targetObject.needsUpdate = !0)
        }
        _setValue_direct_setMatrixWorldNeedsUpdate(t, e) {
          ;(this.targetObject[this.propertyName] = t[e]), (this.targetObject.matrixWorldNeedsUpdate = !0)
        }
        _setValue_array(t, e) {
          const i = this.resolvedProperty
          for (let n = 0, s = i.length; n !== s; ++n) i[n] = t[e++]
        }
        _setValue_array_setNeedsUpdate(t, e) {
          const i = this.resolvedProperty
          for (let n = 0, s = i.length; n !== s; ++n) i[n] = t[e++]
          this.targetObject.needsUpdate = !0
        }
        _setValue_array_setMatrixWorldNeedsUpdate(t, e) {
          const i = this.resolvedProperty
          for (let n = 0, s = i.length; n !== s; ++n) i[n] = t[e++]
          this.targetObject.matrixWorldNeedsUpdate = !0
        }
        _setValue_arrayElement(t, e) {
          this.resolvedProperty[this.propertyIndex] = t[e]
        }
        _setValue_arrayElement_setNeedsUpdate(t, e) {
          ;(this.resolvedProperty[this.propertyIndex] = t[e]), (this.targetObject.needsUpdate = !0)
        }
        _setValue_arrayElement_setMatrixWorldNeedsUpdate(t, e) {
          ;(this.resolvedProperty[this.propertyIndex] = t[e]), (this.targetObject.matrixWorldNeedsUpdate = !0)
        }
        _setValue_fromArray(t, e) {
          this.resolvedProperty.fromArray(t, e)
        }
        _setValue_fromArray_setNeedsUpdate(t, e) {
          this.resolvedProperty.fromArray(t, e), (this.targetObject.needsUpdate = !0)
        }
        _setValue_fromArray_setMatrixWorldNeedsUpdate(t, e) {
          this.resolvedProperty.fromArray(t, e), (this.targetObject.matrixWorldNeedsUpdate = !0)
        }
        _getValue_unbound(t, e) {
          this.bind(), this.getValue(t, e)
        }
        _setValue_unbound(t, e) {
          this.bind(), this.setValue(t, e)
        }
        bind() {
          let t = this.node
          const e = this.parsedPath,
            i = e.objectName,
            n = e.propertyName
          let s = e.propertyIndex
          if (
            (t || ((t = Pl.findNode(this.rootNode, e.nodeName) || this.rootNode), (this.node = t)),
            (this.getValue = this._getValue_unavailable),
            (this.setValue = this._setValue_unavailable),
            !t)
          )
            return
          if (i) {
            let n = e.objectIndex
            switch (i) {
              case 'materials':
                if (!t.material) return
                if (!t.material.materials) return
                t = t.material.materials
                break
              case 'bones':
                if (!t.skeleton) return
                t = t.skeleton.bones
                for (let e = 0; e < t.length; e++)
                  if (t[e].name === n) {
                    n = e
                    break
                  }
                break
              default:
                if (void 0 === t[i]) return
                t = t[i]
            }
            if (void 0 !== n) {
              if (void 0 === t[n]) return
              t = t[n]
            }
          }
          const r = t[n]
          if (void 0 === r) {
            e.nodeName
            return
          }
          let a = this.Versioning.None
          ;(this.targetObject = t),
            void 0 !== t.needsUpdate
              ? (a = this.Versioning.NeedsUpdate)
              : void 0 !== t.matrixWorldNeedsUpdate && (a = this.Versioning.MatrixWorldNeedsUpdate)
          let o = this.BindingType.Direct
          if (void 0 !== s) {
            if ('morphTargetInfluences' === n) {
              if (!t.geometry) return
              if (!t.geometry.isBufferGeometry) return
              if (!t.geometry.morphAttributes) return
              void 0 !== t.morphTargetDictionary[s] && (s = t.morphTargetDictionary[s])
            }
            ;(o = this.BindingType.ArrayElement), (this.resolvedProperty = r), (this.propertyIndex = s)
          } else
            void 0 !== r.fromArray && void 0 !== r.toArray
              ? ((o = this.BindingType.HasFromToArray), (this.resolvedProperty = r))
              : Array.isArray(r)
              ? ((o = this.BindingType.EntireArray), (this.resolvedProperty = r))
              : (this.propertyName = n)
          ;(this.getValue = this.GetterByBindingType[o]), (this.setValue = this.SetterByBindingTypeAndVersioning[o][a])
        }
        unbind() {
          ;(this.node = null), (this.getValue = this._getValue_unbound), (this.setValue = this._setValue_unbound)
        }
      }
      ;(Pl.Composite = class {
        constructor(t, e, i) {
          const n = i || Pl.parseTrackName(e)
          ;(this._targetGroup = t), (this._bindings = t.subscribe_(e, n))
        }
        getValue(t, e) {
          this.bind()
          const i = this._targetGroup.nCachedObjects_,
            n = this._bindings[i]
          void 0 !== n && n.getValue(t, e)
        }
        setValue(t, e) {
          const i = this._bindings
          for (let n = this._targetGroup.nCachedObjects_, s = i.length; n !== s; ++n) i[n].setValue(t, e)
        }
        bind() {
          const t = this._bindings
          for (let e = this._targetGroup.nCachedObjects_, i = t.length; e !== i; ++e) t[e].bind()
        }
        unbind() {
          const t = this._bindings
          for (let e = this._targetGroup.nCachedObjects_, i = t.length; e !== i; ++e) t[e].unbind()
        }
      }),
        (Pl.prototype.BindingType = { Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3 }),
        (Pl.prototype.Versioning = { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 }),
        (Pl.prototype.GetterByBindingType = [
          Pl.prototype._getValue_direct,
          Pl.prototype._getValue_array,
          Pl.prototype._getValue_arrayElement,
          Pl.prototype._getValue_toArray,
        ]),
        (Pl.prototype.SetterByBindingTypeAndVersioning = [
          [
            Pl.prototype._setValue_direct,
            Pl.prototype._setValue_direct_setNeedsUpdate,
            Pl.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
          ],
          [
            Pl.prototype._setValue_array,
            Pl.prototype._setValue_array_setNeedsUpdate,
            Pl.prototype._setValue_array_setMatrixWorldNeedsUpdate,
          ],
          [
            Pl.prototype._setValue_arrayElement,
            Pl.prototype._setValue_arrayElement_setNeedsUpdate,
            Pl.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
          ],
          [
            Pl.prototype._setValue_fromArray,
            Pl.prototype._setValue_fromArray_setNeedsUpdate,
            Pl.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
          ],
        ])
      class Nl {
        constructor(t, e, i = null, n = e.blendMode) {
          ;(this._mixer = t), (this._clip = e), (this._localRoot = i), (this.blendMode = n)
          const s = e.tracks,
            r = s.length,
            a = new Array(r),
            o = { endingStart: 2400, endingEnd: 2400 }
          for (let l = 0; l !== r; ++l) {
            const t = s[l].createInterpolant(null)
            ;(a[l] = t), (t.settings = o)
          }
          ;(this._interpolantSettings = o),
            (this._interpolants = a),
            (this._propertyBindings = new Array(r)),
            (this._cacheIndex = null),
            (this._byClipCacheIndex = null),
            (this._timeScaleInterpolant = null),
            (this._weightInterpolant = null),
            (this.loop = 2201),
            (this._loopCount = -1),
            (this._startTime = null),
            (this.time = 0),
            (this.timeScale = 1),
            (this._effectiveTimeScale = 1),
            (this.weight = 1),
            (this._effectiveWeight = 1),
            (this.repetitions = 1 / 0),
            (this.paused = !1),
            (this.enabled = !0),
            (this.clampWhenFinished = !1),
            (this.zeroSlopeAtStart = !0),
            (this.zeroSlopeAtEnd = !0)
        }
        play() {
          return this._mixer._activateAction(this), this
        }
        stop() {
          return this._mixer._deactivateAction(this), this.reset()
        }
        reset() {
          return (
            (this.paused = !1),
            (this.enabled = !0),
            (this.time = 0),
            (this._loopCount = -1),
            (this._startTime = null),
            this.stopFading().stopWarping()
          )
        }
        isRunning() {
          return (
            this.enabled &&
            !this.paused &&
            0 !== this.timeScale &&
            null === this._startTime &&
            this._mixer._isActiveAction(this)
          )
        }
        isScheduled() {
          return this._mixer._isActiveAction(this)
        }
        startAt(t) {
          return (this._startTime = t), this
        }
        setLoop(t, e) {
          return (this.loop = t), (this.repetitions = e), this
        }
        setEffectiveWeight(t) {
          return (this.weight = t), (this._effectiveWeight = this.enabled ? t : 0), this.stopFading()
        }
        getEffectiveWeight() {
          return this._effectiveWeight
        }
        fadeIn(t) {
          return this._scheduleFading(t, 0, 1)
        }
        fadeOut(t) {
          return this._scheduleFading(t, 1, 0)
        }
        crossFadeFrom(t, e, i) {
          if ((t.fadeOut(e), this.fadeIn(e), i)) {
            const i = this._clip.duration,
              n = t._clip.duration,
              s = n / i,
              r = i / n
            t.warp(1, s, e), this.warp(r, 1, e)
          }
          return this
        }
        crossFadeTo(t, e, i) {
          return t.crossFadeFrom(this, e, i)
        }
        stopFading() {
          const t = this._weightInterpolant
          return null !== t && ((this._weightInterpolant = null), this._mixer._takeBackControlInterpolant(t)), this
        }
        setEffectiveTimeScale(t) {
          return (this.timeScale = t), (this._effectiveTimeScale = this.paused ? 0 : t), this.stopWarping()
        }
        getEffectiveTimeScale() {
          return this._effectiveTimeScale
        }
        setDuration(t) {
          return (this.timeScale = this._clip.duration / t), this.stopWarping()
        }
        syncWith(t) {
          return (this.time = t.time), (this.timeScale = t.timeScale), this.stopWarping()
        }
        halt(t) {
          return this.warp(this._effectiveTimeScale, 0, t)
        }
        warp(t, e, i) {
          const n = this._mixer,
            s = n.time,
            r = this.timeScale
          let a = this._timeScaleInterpolant
          null === a && ((a = n._lendControlInterpolant()), (this._timeScaleInterpolant = a))
          const o = a.parameterPositions,
            l = a.sampleValues
          return (o[0] = s), (o[1] = s + i), (l[0] = t / r), (l[1] = e / r), this
        }
        stopWarping() {
          const t = this._timeScaleInterpolant
          return null !== t && ((this._timeScaleInterpolant = null), this._mixer._takeBackControlInterpolant(t)), this
        }
        getMixer() {
          return this._mixer
        }
        getClip() {
          return this._clip
        }
        getRoot() {
          return this._localRoot || this._mixer._root
        }
        _update(t, e, i, n) {
          if (!this.enabled) return void this._updateWeight(t)
          const s = this._startTime
          if (null !== s) {
            const n = (t - s) * i
            if (n < 0 || 0 === i) return
            ;(this._startTime = null), (e = i * n)
          }
          e *= this._updateTimeScale(t)
          const r = this._updateTime(e),
            a = this._updateWeight(t)
          if (a > 0) {
            const t = this._interpolants,
              e = this._propertyBindings
            switch (this.blendMode) {
              case 2501:
                for (let i = 0, n = t.length; i !== n; ++i) t[i].evaluate(r), e[i].accumulateAdditive(a)
                break
              case 2500:
              default:
                for (let i = 0, s = t.length; i !== s; ++i) t[i].evaluate(r), e[i].accumulate(n, a)
            }
          }
        }
        _updateWeight(t) {
          let e = 0
          if (this.enabled) {
            e = this.weight
            const i = this._weightInterpolant
            if (null !== i) {
              const n = i.evaluate(t)[0]
              ;(e *= n), t > i.parameterPositions[1] && (this.stopFading(), 0 === n && (this.enabled = !1))
            }
          }
          return (this._effectiveWeight = e), e
        }
        _updateTimeScale(t) {
          let e = 0
          if (!this.paused) {
            e = this.timeScale
            const i = this._timeScaleInterpolant
            null !== i &&
              ((e *= i.evaluate(t)[0]),
              t > i.parameterPositions[1] && (this.stopWarping(), 0 === e ? (this.paused = !0) : (this.timeScale = e)))
          }
          return (this._effectiveTimeScale = e), e
        }
        _updateTime(t) {
          const e = this._clip.duration,
            i = this.loop
          let n = this.time + t,
            s = this._loopCount
          const r = 2202 === i
          if (0 === t) return -1 === s ? n : r && 1 == (1 & s) ? e - n : n
          if (2200 === i) {
            ;-1 === s && ((this._loopCount = 0), this._setEndings(!0, !0, !1))
            t: {
              if (n >= e) n = e
              else {
                if (!(n < 0)) {
                  this.time = n
                  break t
                }
                n = 0
              }
              this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
                (this.time = n),
                this._mixer.dispatchEvent({ type: 'finished', action: this, direction: t < 0 ? -1 : 1 })
            }
          } else {
            if (
              (-1 === s &&
                (t >= 0
                  ? ((s = 0), this._setEndings(!0, 0 === this.repetitions, r))
                  : this._setEndings(0 === this.repetitions, !0, r)),
              n >= e || n < 0)
            ) {
              const i = Math.floor(n / e)
              ;(n -= e * i), (s += Math.abs(i))
              const a = this.repetitions - s
              if (a <= 0)
                this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
                  (n = t > 0 ? e : 0),
                  (this.time = n),
                  this._mixer.dispatchEvent({ type: 'finished', action: this, direction: t > 0 ? 1 : -1 })
              else {
                if (1 === a) {
                  const e = t < 0
                  this._setEndings(e, !e, r)
                } else this._setEndings(!1, !1, r)
                ;(this._loopCount = s),
                  (this.time = n),
                  this._mixer.dispatchEvent({ type: 'loop', action: this, loopDelta: i })
              }
            } else this.time = n
            if (r && 1 == (1 & s)) return e - n
          }
          return n
        }
        _setEndings(t, e, i) {
          const n = this._interpolantSettings
          i
            ? ((n.endingStart = 2401), (n.endingEnd = 2401))
            : ((n.endingStart = t ? (this.zeroSlopeAtStart ? 2401 : 2400) : 2402),
              (n.endingEnd = e ? (this.zeroSlopeAtEnd ? 2401 : 2400) : 2402))
        }
        _scheduleFading(t, e, i) {
          const n = this._mixer,
            s = n.time
          let r = this._weightInterpolant
          null === r && ((r = n._lendControlInterpolant()), (this._weightInterpolant = r))
          const a = r.parameterPositions,
            o = r.sampleValues
          return (a[0] = s), (o[0] = e), (a[1] = s + t), (o[1] = i), this
        }
      }
      class Fl extends it {
        constructor(t) {
          super(),
            (this._root = t),
            this._initMemoryManager(),
            (this._accuIndex = 0),
            (this.time = 0),
            (this.timeScale = 1)
        }
        _bindAction(t, e) {
          const i = t._localRoot || this._root,
            n = t._clip.tracks,
            s = n.length,
            r = t._propertyBindings,
            a = t._interpolants,
            o = i.uuid,
            l = this._bindingsByRootAndName
          let c = l[o]
          void 0 === c && ((c = {}), (l[o] = c))
          for (let h = 0; h !== s; ++h) {
            const t = n[h],
              s = t.name
            let l = c[s]
            if (void 0 !== l) r[h] = l
            else {
              if (((l = r[h]), void 0 !== l)) {
                null === l._cacheIndex && (++l.referenceCount, this._addInactiveBinding(l, o, s))
                continue
              }
              const n = e && e._propertyBindings[h].binding.parsedPath
              ;(l = new El(Pl.create(i, s, n), t.ValueTypeName, t.getValueSize())),
                ++l.referenceCount,
                this._addInactiveBinding(l, o, s),
                (r[h] = l)
            }
            a[h].resultBuffer = l.buffer
          }
        }
        _activateAction(t) {
          if (!this._isActiveAction(t)) {
            if (null === t._cacheIndex) {
              const e = (t._localRoot || this._root).uuid,
                i = t._clip.uuid,
                n = this._actionsByClip[i]
              this._bindAction(t, n && n.knownActions[0]), this._addInactiveAction(t, i, e)
            }
            const e = t._propertyBindings
            for (let t = 0, i = e.length; t !== i; ++t) {
              const i = e[t]
              0 == i.useCount++ && (this._lendBinding(i), i.saveOriginalState())
            }
            this._lendAction(t)
          }
        }
        _deactivateAction(t) {
          if (this._isActiveAction(t)) {
            const e = t._propertyBindings
            for (let t = 0, i = e.length; t !== i; ++t) {
              const i = e[t]
              0 == --i.useCount && (i.restoreOriginalState(), this._takeBackBinding(i))
            }
            this._takeBackAction(t)
          }
        }
        _initMemoryManager() {
          ;(this._actions = []),
            (this._nActiveActions = 0),
            (this._actionsByClip = {}),
            (this._bindings = []),
            (this._nActiveBindings = 0),
            (this._bindingsByRootAndName = {}),
            (this._controlInterpolants = []),
            (this._nActiveControlInterpolants = 0)
          const t = this
          this.stats = {
            actions: {
              get total() {
                return t._actions.length
              },
              get inUse() {
                return t._nActiveActions
              },
            },
            bindings: {
              get total() {
                return t._bindings.length
              },
              get inUse() {
                return t._nActiveBindings
              },
            },
            controlInterpolants: {
              get total() {
                return t._controlInterpolants.length
              },
              get inUse() {
                return t._nActiveControlInterpolants
              },
            },
          }
        }
        _isActiveAction(t) {
          const e = t._cacheIndex
          return null !== e && e < this._nActiveActions
        }
        _addInactiveAction(t, e, i) {
          const n = this._actions,
            s = this._actionsByClip
          let r = s[e]
          if (void 0 === r) (r = { knownActions: [t], actionByRoot: {} }), (t._byClipCacheIndex = 0), (s[e] = r)
          else {
            const e = r.knownActions
            ;(t._byClipCacheIndex = e.length), e.push(t)
          }
          ;(t._cacheIndex = n.length), n.push(t), (r.actionByRoot[i] = t)
        }
        _removeInactiveAction(t) {
          const e = this._actions,
            i = e[e.length - 1],
            n = t._cacheIndex
          ;(i._cacheIndex = n), (e[n] = i), e.pop(), (t._cacheIndex = null)
          const s = t._clip.uuid,
            r = this._actionsByClip,
            a = r[s],
            o = a.knownActions,
            l = o[o.length - 1],
            c = t._byClipCacheIndex
          ;(l._byClipCacheIndex = c),
            (o[c] = l),
            o.pop(),
            (t._byClipCacheIndex = null),
            delete a.actionByRoot[(t._localRoot || this._root).uuid],
            0 === o.length && delete r[s],
            this._removeInactiveBindingsForAction(t)
        }
        _removeInactiveBindingsForAction(t) {
          const e = t._propertyBindings
          for (let i = 0, n = e.length; i !== n; ++i) {
            const t = e[i]
            0 == --t.referenceCount && this._removeInactiveBinding(t)
          }
        }
        _lendAction(t) {
          const e = this._actions,
            i = t._cacheIndex,
            n = this._nActiveActions++,
            s = e[n]
          ;(t._cacheIndex = n), (e[n] = t), (s._cacheIndex = i), (e[i] = s)
        }
        _takeBackAction(t) {
          const e = this._actions,
            i = t._cacheIndex,
            n = --this._nActiveActions,
            s = e[n]
          ;(t._cacheIndex = n), (e[n] = t), (s._cacheIndex = i), (e[i] = s)
        }
        _addInactiveBinding(t, e, i) {
          const n = this._bindingsByRootAndName,
            s = this._bindings
          let r = n[e]
          void 0 === r && ((r = {}), (n[e] = r)), (r[i] = t), (t._cacheIndex = s.length), s.push(t)
        }
        _removeInactiveBinding(t) {
          const e = this._bindings,
            i = t.binding,
            n = i.rootNode.uuid,
            s = i.path,
            r = this._bindingsByRootAndName,
            a = r[n],
            o = e[e.length - 1],
            l = t._cacheIndex
          ;(o._cacheIndex = l), (e[l] = o), e.pop(), delete a[s], 0 === Object.keys(a).length && delete r[n]
        }
        _lendBinding(t) {
          const e = this._bindings,
            i = t._cacheIndex,
            n = this._nActiveBindings++,
            s = e[n]
          ;(t._cacheIndex = n), (e[n] = t), (s._cacheIndex = i), (e[i] = s)
        }
        _takeBackBinding(t) {
          const e = this._bindings,
            i = t._cacheIndex,
            n = --this._nActiveBindings,
            s = e[n]
          ;(t._cacheIndex = n), (e[n] = t), (s._cacheIndex = i), (e[i] = s)
        }
        _lendControlInterpolant() {
          const t = this._controlInterpolants,
            e = this._nActiveControlInterpolants++
          let i = t[e]
          return (
            void 0 === i &&
              ((i = new Po(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer)),
              (i.__cacheIndex = e),
              (t[e] = i)),
            i
          )
        }
        _takeBackControlInterpolant(t) {
          const e = this._controlInterpolants,
            i = t.__cacheIndex,
            n = --this._nActiveControlInterpolants,
            s = e[n]
          ;(t.__cacheIndex = n), (e[n] = t), (s.__cacheIndex = i), (e[i] = s)
        }
        clipAction(t, e, i) {
          const n = e || this._root,
            s = n.uuid
          let r = 'string' == typeof t ? Wo.findByName(n, t) : t
          const a = null !== r ? r.uuid : t,
            o = this._actionsByClip[a]
          let l = null
          if ((void 0 === i && (i = null !== r ? r.blendMode : 2500), void 0 !== o)) {
            const t = o.actionByRoot[s]
            if (void 0 !== t && t.blendMode === i) return t
            ;(l = o.knownActions[0]), null === r && (r = l._clip)
          }
          if (null === r) return null
          const c = new Nl(this, r, e, i)
          return this._bindAction(c, l), this._addInactiveAction(c, a, s), c
        }
        existingAction(t, e) {
          const i = e || this._root,
            n = i.uuid,
            s = 'string' == typeof t ? Wo.findByName(i, t) : t,
            r = s ? s.uuid : t,
            a = this._actionsByClip[r]
          return (void 0 !== a && a.actionByRoot[n]) || null
        }
        stopAllAction() {
          const t = this._actions
          for (let e = this._nActiveActions - 1; e >= 0; --e) t[e].stop()
          return this
        }
        update(t) {
          t *= this.timeScale
          const e = this._actions,
            i = this._nActiveActions,
            n = (this.time += t),
            s = Math.sign(t),
            r = (this._accuIndex ^= 1)
          for (let l = 0; l !== i; ++l) e[l]._update(n, t, s, r)
          const a = this._bindings,
            o = this._nActiveBindings
          for (let l = 0; l !== o; ++l) a[l].apply(r)
          return this
        }
        setTime(t) {
          this.time = 0
          for (let e = 0; e < this._actions.length; e++) this._actions[e].time = 0
          return this.update(t)
        }
        getRoot() {
          return this._root
        }
        uncacheClip(t) {
          const e = this._actions,
            i = t.uuid,
            n = this._actionsByClip,
            s = n[i]
          if (void 0 !== s) {
            const t = s.knownActions
            for (let i = 0, n = t.length; i !== n; ++i) {
              const n = t[i]
              this._deactivateAction(n)
              const s = n._cacheIndex,
                r = e[e.length - 1]
              ;(n._cacheIndex = null),
                (n._byClipCacheIndex = null),
                (r._cacheIndex = s),
                (e[s] = r),
                e.pop(),
                this._removeInactiveBindingsForAction(n)
            }
            delete n[i]
          }
        }
        uncacheRoot(t) {
          const e = t.uuid,
            i = this._actionsByClip
          for (const s in i) {
            const t = i[s].actionByRoot[e]
            void 0 !== t && (this._deactivateAction(t), this._removeInactiveAction(t))
          }
          const n = this._bindingsByRootAndName[e]
          if (void 0 !== n)
            for (const s in n) {
              const t = n[s]
              t.restoreOriginalState(), this._removeInactiveBinding(t)
            }
        }
        uncacheAction(t, e) {
          const i = this.existingAction(t, e)
          null !== i && (this._deactivateAction(i), this._removeInactiveAction(i))
        }
      }
      function Ul(t, e) {
        return t.distance - e.distance
      }
      function kl(t, e, i, n) {
        if ((t.layers.test(e.layers) && t.raycast(e, i), !0 === n)) {
          const n = t.children
          for (let t = 0, s = n.length; t < s; t++) kl(n[t], e, i, !0)
        }
      }
      ;(Fl.prototype._controlInterpolantsResultBuffer = new Float32Array(1)),
        (class extends Pr {
          constructor(t, e, i = 1) {
            super(t, e), (this.meshPerAttribute = i)
          }
          copy(t) {
            return super.copy(t), (this.meshPerAttribute = t.meshPerAttribute), this
          }
          clone(t) {
            const e = super.clone(t)
            return (e.meshPerAttribute = this.meshPerAttribute), e
          }
          toJSON(t) {
            const e = super.toJSON(t)
            return (e.isInstancedInterleavedBuffer = !0), (e.meshPerAttribute = this.meshPerAttribute), e
          }
        }.prototype.isInstancedInterleavedBuffer = !0)
      class Ol {
        constructor(t = 1, e = 0, i = 0) {
          return (this.radius = t), (this.phi = e), (this.theta = i), this
        }
        set(t, e, i) {
          return (this.radius = t), (this.phi = e), (this.theta = i), this
        }
        copy(t) {
          return (this.radius = t.radius), (this.phi = t.phi), (this.theta = t.theta), this
        }
        makeSafe() {
          const t = 1e-6
          return (this.phi = Math.max(t, Math.min(Math.PI - t, this.phi))), this
        }
        setFromVector3(t) {
          return this.setFromCartesianCoords(t.x, t.y, t.z)
        }
        setFromCartesianCoords(t, e, i) {
          return (
            (this.radius = Math.sqrt(t * t + e * e + i * i)),
            0 === this.radius
              ? ((this.theta = 0), (this.phi = 0))
              : ((this.theta = Math.atan2(t, i)), (this.phi = Math.acos(lt(e / this.radius, -1, 1)))),
            this
          )
        }
        clone() {
          return new this.constructor().copy(this)
        }
      }
      ;(class extends Se {
        constructor(t) {
          super(),
            (this.material = t),
            (this.render = function () {}),
            (this.hasPositions = !1),
            (this.hasNormals = !1),
            (this.hasColors = !1),
            (this.hasUvs = !1),
            (this.positionArray = null),
            (this.normalArray = null),
            (this.colorArray = null),
            (this.uvArray = null),
            (this.count = 0)
        }
      }.prototype.isImmediateRenderObject = !0)
      const Gl = new Et(),
        zl = new ne(),
        Vl = new ne()
      class Hl extends Ia {
        constructor(t) {
          const e = Wl(t),
            i = new hi(),
            n = [],
            s = [],
            r = new Ye(0, 0, 1),
            a = new Ye(0, 1, 0)
          for (let o = 0; o < e.length; o++) {
            const t = e[o]
            t.parent &&
              t.parent.isBone &&
              (n.push(0, 0, 0), n.push(0, 0, 0), s.push(r.r, r.g, r.b), s.push(a.r, a.g, a.b))
          }
          i.setAttribute('position', new ei(n, 3)),
            i.setAttribute('color', new ei(s, 3)),
            super(i, new Aa({ vertexColors: !0, depthTest: !1, depthWrite: !1, toneMapped: !1, transparent: !0 })),
            (this.type = 'SkeletonHelper'),
            (this.isSkeletonHelper = !0),
            (this.root = t),
            (this.bones = e),
            (this.matrix = t.matrixWorld),
            (this.matrixAutoUpdate = !1)
        }
        updateMatrixWorld(t) {
          const e = this.bones,
            i = this.geometry,
            n = i.getAttribute('position')
          Vl.copy(this.root.matrixWorld).invert()
          for (let s = 0, r = 0; s < e.length; s++) {
            const t = e[s]
            t.parent &&
              t.parent.isBone &&
              (zl.multiplyMatrices(Vl, t.matrixWorld),
              Gl.setFromMatrixPosition(zl),
              n.setXYZ(r, Gl.x, Gl.y, Gl.z),
              zl.multiplyMatrices(Vl, t.parent.matrixWorld),
              Gl.setFromMatrixPosition(zl),
              n.setXYZ(r + 1, Gl.x, Gl.y, Gl.z),
              (r += 2))
          }
          ;(i.getAttribute('position').needsUpdate = !0), super.updateMatrixWorld(t)
        }
      }
      function Wl(t) {
        const e = []
        t && t.isBone && e.push(t)
        for (let i = 0; i < t.children.length; i++) e.push.apply(e, Wl(t.children[i]))
        return e
      }
      const ql = new Float32Array(1),
        jl = new Int32Array(ql.buffer)
      class Yl {
        static toHalfFloat(t) {
          ql[0] = t
          const e = jl[0]
          let i = (e >> 16) & 32768,
            n = (e >> 12) & 2047
          const s = (e >> 23) & 255
          return s < 103
            ? i
            : s > 142
            ? ((i |= 31744), (i |= (255 == s ? 0 : 1) && 8388607 & e), i)
            : s < 113
            ? ((n |= 2048), (i |= (n >> (114 - s)) + ((n >> (113 - s)) & 1)), i)
            : ((i |= ((s - 112) << 10) | (n >> 1)), (i += 1 & n), i)
        }
      }
      ;(Qa.create = function (t, e) {
        return (t.prototype = Object.create(Qa.prototype)), (t.prototype.constructor = t), (t.prototype.getPoint = e), t
      }),
        (sl.prototype.fromPoints = function (t) {
          return this.setFromPoints(t)
        }),
        (class extends Ia {
          constructor(t = 10, e = 10, i = 4473924, n = 8947848) {
            ;(i = new Ye(i)), (n = new Ye(n))
            const s = e / 2,
              r = t / e,
              a = t / 2,
              o = [],
              l = []
            for (let h = 0, u = 0, d = -a; h <= e; h++, d += r) {
              o.push(-a, 0, d, a, 0, d), o.push(d, 0, -a, d, 0, a)
              const t = h === s ? i : n
              t.toArray(l, u), (u += 3), t.toArray(l, u), (u += 3), t.toArray(l, u), (u += 3), t.toArray(l, u), (u += 3)
            }
            const c = new hi()
            c.setAttribute('position', new ei(o, 3)),
              c.setAttribute('color', new ei(l, 3)),
              super(c, new Aa({ vertexColors: !0, toneMapped: !1 })),
              (this.type = 'GridHelper')
          }
        }.prototype.setColors = function () {}),
        (Hl.prototype.update = function () {}),
        (Jo.prototype.extractUrlBase = function (t) {
          return _l.extractUrlBase(t)
        }),
        (Jo.Handlers = { add: function () {}, get: function () {} }),
        (Bt.prototype.center = function (t) {
          return this.getCenter(t)
        }),
        (Bt.prototype.empty = function () {
          return this.isEmpty()
        }),
        (Bt.prototype.isIntersectionBox = function (t) {
          return this.intersectsBox(t)
        }),
        (Bt.prototype.isIntersectionSphere = function (t) {
          return this.intersectsSphere(t)
        }),
        (Bt.prototype.size = function (t) {
          return this.getSize(t)
        }),
        (Yt.prototype.empty = function () {
          return this.isEmpty()
        }),
        (qi.prototype.setFromMatrix = function (t) {
          return this.setFromProjectionMatrix(t)
        }),
        (mt.prototype.flattenToArrayOffset = function (t, e) {
          return this.toArray(t, e)
        }),
        (mt.prototype.multiplyVector3 = function (t) {
          return t.applyMatrix3(this)
        }),
        (mt.prototype.multiplyVector3Array = function () {}),
        (mt.prototype.applyToBufferAttribute = function (t) {
          return t.applyMatrix3(this)
        }),
        (mt.prototype.applyToVector3Array = function () {}),
        (mt.prototype.getInverse = function (t) {
          return this.copy(t).invert()
        }),
        (ne.prototype.extractPosition = function (t) {
          return this.copyPosition(t)
        }),
        (ne.prototype.flattenToArrayOffset = function (t, e) {
          return this.toArray(t, e)
        }),
        (ne.prototype.getPosition = function () {
          return new Et().setFromMatrixColumn(this, 3)
        }),
        (ne.prototype.setRotationFromQuaternion = function (t) {
          return this.makeRotationFromQuaternion(t)
        }),
        (ne.prototype.multiplyToArray = function () {}),
        (ne.prototype.multiplyVector3 = function (t) {
          return t.applyMatrix4(this)
        }),
        (ne.prototype.multiplyVector4 = function (t) {
          return t.applyMatrix4(this)
        }),
        (ne.prototype.multiplyVector3Array = function () {}),
        (ne.prototype.rotateAxis = function (t) {
          t.transformDirection(this)
        }),
        (ne.prototype.crossVector = function (t) {
          return t.applyMatrix4(this)
        }),
        (ne.prototype.translate = function () {}),
        (ne.prototype.rotateX = function () {}),
        (ne.prototype.rotateY = function () {}),
        (ne.prototype.rotateZ = function () {}),
        (ne.prototype.rotateByAxis = function () {}),
        (ne.prototype.applyToBufferAttribute = function (t) {
          return t.applyMatrix4(this)
        }),
        (ne.prototype.applyToVector3Array = function () {}),
        (ne.prototype.makeFrustum = function (t, e, i, n, s, r) {
          return this.makePerspective(t, e, n, i, s, r)
        }),
        (ne.prototype.getInverse = function (t) {
          return this.copy(t).invert()
        }),
        (Vi.prototype.isIntersectionLine = function (t) {
          return this.intersectsLine(t)
        }),
        (Mt.prototype.multiplyVector3 = function (t) {
          return t.applyQuaternion(this)
        }),
        (Mt.prototype.inverse = function () {
          return this.invert()
        }),
        (ie.prototype.isIntersectionBox = function (t) {
          return this.intersectsBox(t)
        }),
        (ie.prototype.isIntersectionPlane = function (t) {
          return this.intersectsPlane(t)
        }),
        (ie.prototype.isIntersectionSphere = function (t) {
          return this.intersectsSphere(t)
        }),
        (ke.prototype.area = function () {
          return this.getArea()
        }),
        (ke.prototype.barycoordFromPoint = function (t, e) {
          return this.getBarycoord(t, e)
        }),
        (ke.prototype.midpoint = function (t) {
          return this.getMidpoint(t)
        }),
        (ke.prototypenormal = function (t) {
          return this.getNormal(t)
        }),
        (ke.prototype.plane = function (t) {
          return this.getPlane(t)
        }),
        (ke.barycoordFromPoint = function (t, e, i, n, s) {
          return ke.getBarycoord(t, e, i, n, s)
        }),
        (ke.normal = function (t, e, i, n) {
          return ke.getNormal(t, e, i, n)
        }),
        (rl.prototype.extractAllPoints = function (t) {
          return this.extractPoints(t)
        }),
        (rl.prototype.extrude = function (t) {
          return new Eo(this, t)
        }),
        (rl.prototype.makeGeometry = function (t) {
          return new So(this, t)
        }),
        (gt.prototype.fromAttribute = function (t, e, i) {
          return this.fromBufferAttribute(t, e, i)
        }),
        (gt.prototype.distanceToManhattan = function (t) {
          return this.manhattanDistanceTo(t)
        }),
        (gt.prototype.lengthManhattan = function () {
          return this.manhattanLength()
        }),
        (Et.prototype.setEulerFromRotationMatrix = function () {}),
        (Et.prototype.setEulerFromQuaternion = function () {}),
        (Et.prototype.getPositionFromMatrix = function (t) {
          return this.setFromMatrixPosition(t)
        }),
        (Et.prototype.getScaleFromMatrix = function (t) {
          return this.setFromMatrixScale(t)
        }),
        (Et.prototype.getColumnFromMatrix = function (t, e) {
          return this.setFromMatrixColumn(e, t)
        }),
        (Et.prototype.applyProjection = function (t) {
          return this.applyMatrix4(t)
        }),
        (Et.prototype.fromAttribute = function (t, e, i) {
          return this.fromBufferAttribute(t, e, i)
        }),
        (Et.prototype.distanceToManhattan = function (t) {
          return this.manhattanDistanceTo(t)
        }),
        (Et.prototype.lengthManhattan = function () {
          return this.manhattanLength()
        }),
        (_t.prototype.fromAttribute = function (t, e, i) {
          return this.fromBufferAttribute(t, e, i)
        }),
        (_t.prototype.lengthManhattan = function () {
          return this.manhattanLength()
        }),
        (Se.prototype.getChildByName = function (t) {
          return this.getObjectByName(t)
        }),
        (Se.prototype.renderDepth = function () {}),
        (Se.prototype.translate = function (t, e) {
          return this.translateOnAxis(e, t)
        }),
        (Se.prototype.getWorldRotation = function () {}),
        (Se.prototype.applyMatrix = function (t) {
          return this.applyMatrix4(t)
        }),
        Object.defineProperties(Se.prototype, {
          eulerOrder: {
            get: function () {
              return this.rotation.order
            },
            set: function (t) {
              this.rotation.order = t
            },
          },
          useQuaternion: { get: function () {}, set: function () {} },
        }),
        (Si.prototype.setDrawMode = function () {}),
        Object.defineProperties(Si.prototype, {
          drawMode: {
            get: function () {
              return 0
            },
            set: function () {},
          },
        }),
        (sa.prototype.initBones = function () {}),
        (Ni.prototype.setLens = function (t, e) {
          void 0 !== e && (this.filmGauge = e), this.setFocalLength(t)
        }),
        Object.defineProperties(al.prototype, {
          onlyShadow: { set: function () {} },
          shadowCameraFov: {
            set: function (t) {
              this.shadow.camera.fov = t
            },
          },
          shadowCameraLeft: {
            set: function (t) {
              this.shadow.camera.left = t
            },
          },
          shadowCameraRight: {
            set: function (t) {
              this.shadow.camera.right = t
            },
          },
          shadowCameraTop: {
            set: function (t) {
              this.shadow.camera.top = t
            },
          },
          shadowCameraBottom: {
            set: function (t) {
              this.shadow.camera.bottom = t
            },
          },
          shadowCameraNear: {
            set: function (t) {
              this.shadow.camera.near = t
            },
          },
          shadowCameraFar: {
            set: function (t) {
              this.shadow.camera.far = t
            },
          },
          shadowCameraVisible: { set: function () {} },
          shadowBias: {
            set: function (t) {
              this.shadow.bias = t
            },
          },
          shadowDarkness: { set: function () {} },
          shadowMapWidth: {
            set: function (t) {
              this.shadow.mapSize.width = t
            },
          },
          shadowMapHeight: {
            set: function (t) {
              this.shadow.mapSize.height = t
            },
          },
        }),
        Object.defineProperties(Ze.prototype, {
          length: {
            get: function () {
              return this.array.length
            },
          },
          dynamic: {
            get: function () {
              return 35048 === this.usage
            },
            set: function () {
              this.setUsage(35048)
            },
          },
        }),
        (Ze.prototype.setDynamic = function (t) {
          return this.setUsage(!0 === t ? 35048 : 35044), this
        }),
        (Ze.prototype.copyIndicesArray = function () {}),
        (Ze.prototype.setArray = function () {}),
        (hi.prototype.addIndex = function (t) {
          this.setIndex(t)
        }),
        (hi.prototype.addAttribute = function (t, e) {
          return (e && e.isBufferAttribute) || (e && e.isInterleavedBufferAttribute)
            ? 'index' === t
              ? (this.setIndex(e), this)
              : this.setAttribute(t, e)
            : this.setAttribute(t, new Ze(arguments[1], arguments[2]))
        }),
        (hi.prototype.addDrawCall = function (t, e, i) {
          this.addGroup(t, e)
        }),
        (hi.prototype.clearDrawCalls = function () {
          this.clearGroups()
        }),
        (hi.prototype.computeOffsets = function () {}),
        (hi.prototype.removeAttribute = function (t) {
          return this.deleteAttribute(t)
        }),
        (hi.prototype.applyMatrix = function (t) {
          return this.applyMatrix4(t)
        }),
        Object.defineProperties(hi.prototype, {
          drawcalls: {
            get: function () {
              return this.groups
            },
          },
          offsets: {
            get: function () {
              return this.groups
            },
          },
        }),
        (Pr.prototype.setDynamic = function (t) {
          return this.setUsage(!0 === t ? 35048 : 35044), this
        }),
        (Pr.prototype.setArray = function () {}),
        (Eo.prototype.getArrays = function () {}),
        (Eo.prototype.addShapeList = function () {}),
        (Eo.prototype.addShape = function () {}),
        (Rr.prototype.dispose = function () {}),
        Object.defineProperties(Ge.prototype, {
          wrapAround: { get: function () {}, set: function () {} },
          overdraw: { get: function () {}, set: function () {} },
          wrapRGB: {
            get: function () {
              return new Ye()
            },
          },
          shading: {
            get: function () {},
            set: function (t) {
              this.flatShading = 1 === t
            },
          },
          stencilMask: {
            get: function () {
              return this.stencilFuncMask
            },
            set: function (t) {
              this.stencilFuncMask = t
            },
          },
          vertexTangents: { get: function () {}, set: function () {} },
        }),
        Object.defineProperties(Ri.prototype, {
          derivatives: {
            get: function () {
              return this.extensions.derivatives
            },
            set: function (t) {
              this.extensions.derivatives = t
            },
          },
        }),
        (Qr.prototype.clearTarget = function (t, e, i, n) {
          this.setRenderTarget(t), this.clear(e, i, n)
        }),
        (Qr.prototype.animate = function (t) {
          this.setAnimationLoop(t)
        }),
        (Qr.prototype.getCurrentRenderTarget = function () {
          return this.getRenderTarget()
        }),
        (Qr.prototype.getMaxAnisotropy = function () {
          return this.capabilities.getMaxAnisotropy()
        }),
        (Qr.prototype.getPrecision = function () {
          return this.capabilities.precision
        }),
        (Qr.prototype.resetGLState = function () {
          return this.state.reset()
        }),
        (Qr.prototype.supportsFloatTextures = function () {
          return this.extensions.get('OES_texture_float')
        }),
        (Qr.prototype.supportsHalfFloatTextures = function () {
          return this.extensions.get('OES_texture_half_float')
        }),
        (Qr.prototype.supportsStandardDerivatives = function () {
          return this.extensions.get('OES_standard_derivatives')
        }),
        (Qr.prototype.supportsCompressedTextureS3TC = function () {
          return this.extensions.get('WEBGL_compressed_texture_s3tc')
        }),
        (Qr.prototype.supportsCompressedTexturePVRTC = function () {
          return this.extensions.get('WEBGL_compressed_texture_pvrtc')
        }),
        (Qr.prototype.supportsBlendMinMax = function () {
          return this.extensions.get('EXT_blend_minmax')
        }),
        (Qr.prototype.supportsVertexTextures = function () {
          return this.capabilities.vertexTextures
        }),
        (Qr.prototype.supportsInstancedArrays = function () {
          return this.extensions.get('ANGLE_instanced_arrays')
        }),
        (Qr.prototype.enableScissorTest = function (t) {
          this.setScissorTest(t)
        }),
        (Qr.prototype.initMaterial = function () {}),
        (Qr.prototype.addPrePlugin = function () {}),
        (Qr.prototype.addPostPlugin = function () {}),
        (Qr.prototype.updateShadowMap = function () {}),
        (Qr.prototype.setFaceCulling = function () {}),
        (Qr.prototype.allocTextureUnit = function () {}),
        (Qr.prototype.setTexture = function () {}),
        (Qr.prototype.setTexture2D = function () {}),
        (Qr.prototype.setTextureCube = function () {}),
        (Qr.prototype.getActiveMipMapLevel = function () {
          return this.getActiveMipmapLevel()
        }),
        Object.defineProperties(Qr.prototype, {
          shadowMapEnabled: {
            get: function () {
              return this.shadowMap.enabled
            },
            set: function (t) {
              this.shadowMap.enabled = t
            },
          },
          shadowMapType: {
            get: function () {
              return this.shadowMap.type
            },
            set: function (t) {
              this.shadowMap.type = t
            },
          },
          shadowMapCullFace: { get: function () {}, set: function () {} },
          context: {
            get: function () {
              return this.getContext()
            },
          },
          vr: {
            get: function () {
              return this.xr
            },
          },
          gammaInput: {
            get: function () {
              return !1
            },
            set: function () {},
          },
          gammaOutput: {
            get: function () {
              return !1
            },
            set: function (t) {
              this.outputEncoding = !0 === t ? 3001 : 3e3
            },
          },
          toneMappingWhitePoint: {
            get: function () {
              return 1
            },
            set: function () {},
          },
        }),
        Object.defineProperties(Ir.prototype, {
          cullFace: { get: function () {}, set: function () {} },
          renderReverseSided: { get: function () {}, set: function () {} },
          renderSingleSided: { get: function () {}, set: function () {} },
        }),
        Object.defineProperties(It.prototype, {
          wrapS: {
            get: function () {
              return this.texture.wrapS
            },
            set: function (t) {
              this.texture.wrapS = t
            },
          },
          wrapT: {
            get: function () {
              return this.texture.wrapT
            },
            set: function (t) {
              this.texture.wrapT = t
            },
          },
          magFilter: {
            get: function () {
              return this.texture.magFilter
            },
            set: function (t) {
              this.texture.magFilter = t
            },
          },
          minFilter: {
            get: function () {
              return this.texture.minFilter
            },
            set: function (t) {
              this.texture.minFilter = t
            },
          },
          anisotropy: {
            get: function () {
              return this.texture.anisotropy
            },
            set: function (t) {
              this.texture.anisotropy = t
            },
          },
          offset: {
            get: function () {
              return this.texture.offset
            },
            set: function (t) {
              this.texture.offset = t
            },
          },
          repeat: {
            get: function () {
              return this.texture.repeat
            },
            set: function (t) {
              this.texture.repeat = t
            },
          },
          format: {
            get: function () {
              return this.texture.format
            },
            set: function (t) {
              this.texture.format = t
            },
          },
          type: {
            get: function () {
              return this.texture.type
            },
            set: function (t) {
              this.texture.type = t
            },
          },
          generateMipmaps: {
            get: function () {
              return this.texture.generateMipmaps
            },
            set: function (t) {
              this.texture.generateMipmaps = t
            },
          },
        }),
        (class extends Se {
          constructor(t) {
            super(),
              (this.type = 'Audio'),
              (this.listener = t),
              (this.context = t.context),
              (this.gain = this.context.createGain()),
              this.gain.connect(t.getInput()),
              (this.autoplay = !1),
              (this.buffer = null),
              (this.detune = 0),
              (this.loop = !1),
              (this.loopStart = 0),
              (this.loopEnd = 0),
              (this.offset = 0),
              (this.duration = void 0),
              (this.playbackRate = 1),
              (this.isPlaying = !1),
              (this.hasPlaybackControl = !0),
              (this.source = null),
              (this.sourceType = 'empty'),
              (this._startedAt = 0),
              (this._progress = 0),
              (this._connected = !1),
              (this.filters = [])
          }
          getOutput() {
            return this.gain
          }
          setNodeSource(t) {
            return (
              (this.hasPlaybackControl = !1), (this.sourceType = 'audioNode'), (this.source = t), this.connect(), this
            )
          }
          setMediaElementSource(t) {
            return (
              (this.hasPlaybackControl = !1),
              (this.sourceType = 'mediaNode'),
              (this.source = this.context.createMediaElementSource(t)),
              this.connect(),
              this
            )
          }
          setMediaStreamSource(t) {
            return (
              (this.hasPlaybackControl = !1),
              (this.sourceType = 'mediaStreamNode'),
              (this.source = this.context.createMediaStreamSource(t)),
              this.connect(),
              this
            )
          }
          setBuffer(t) {
            return (this.buffer = t), (this.sourceType = 'buffer'), this.autoplay && this.play(), this
          }
          play(t = 0) {
            if (!0 === this.isPlaying) return
            if (!1 === this.hasPlaybackControl) return
            this._startedAt = this.context.currentTime + t
            const e = this.context.createBufferSource()
            return (
              (e.buffer = this.buffer),
              (e.loop = this.loop),
              (e.loopStart = this.loopStart),
              (e.loopEnd = this.loopEnd),
              (e.onended = this.onEnded.bind(this)),
              e.start(this._startedAt, this._progress + this.offset, this.duration),
              (this.isPlaying = !0),
              (this.source = e),
              this.setDetune(this.detune),
              this.setPlaybackRate(this.playbackRate),
              this.connect()
            )
          }
          pause() {
            if (!1 !== this.hasPlaybackControl)
              return (
                !0 === this.isPlaying &&
                  ((this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate),
                  !0 === this.loop && (this._progress = this._progress % (this.duration || this.buffer.duration)),
                  this.source.stop(),
                  (this.source.onended = null),
                  (this.isPlaying = !1)),
                this
              )
          }
          stop() {
            if (!1 !== this.hasPlaybackControl)
              return (this._progress = 0), this.source.stop(), (this.source.onended = null), (this.isPlaying = !1), this
          }
          connect() {
            if (this.filters.length > 0) {
              this.source.connect(this.filters[0])
              for (let t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].connect(this.filters[t])
              this.filters[this.filters.length - 1].connect(this.getOutput())
            } else this.source.connect(this.getOutput())
            return (this._connected = !0), this
          }
          disconnect() {
            if (this.filters.length > 0) {
              this.source.disconnect(this.filters[0])
              for (let t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].disconnect(this.filters[t])
              this.filters[this.filters.length - 1].disconnect(this.getOutput())
            } else this.source.disconnect(this.getOutput())
            return (this._connected = !1), this
          }
          getFilters() {
            return this.filters
          }
          setFilters(t) {
            return (
              t || (t = []),
              !0 === this._connected
                ? (this.disconnect(), (this.filters = t.slice()), this.connect())
                : (this.filters = t.slice()),
              this
            )
          }
          setDetune(t) {
            if (((this.detune = t), void 0 !== this.source.detune))
              return (
                !0 === this.isPlaying &&
                  this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01),
                this
              )
          }
          getDetune() {
            return this.detune
          }
          getFilter() {
            return this.getFilters()[0]
          }
          setFilter(t) {
            return this.setFilters(t ? [t] : [])
          }
          setPlaybackRate(t) {
            if (!1 !== this.hasPlaybackControl)
              return (
                (this.playbackRate = t),
                !0 === this.isPlaying &&
                  this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01),
                this
              )
          }
          getPlaybackRate() {
            return this.playbackRate
          }
          onEnded() {
            this.isPlaying = !1
          }
          getLoop() {
            return !1 !== this.hasPlaybackControl && this.loop
          }
          setLoop(t) {
            if (!1 !== this.hasPlaybackControl)
              return (this.loop = t), !0 === this.isPlaying && (this.source.loop = this.loop), this
          }
          setLoopStart(t) {
            return (this.loopStart = t), this
          }
          setLoopEnd(t) {
            return (this.loopEnd = t), this
          }
          getVolume() {
            return this.gain.gain.value
          }
          setVolume(t) {
            return this.gain.gain.setTargetAtTime(t, this.context.currentTime, 0.01), this
          }
        }.prototype.load = function (t) {
          const e = this
          return (
            new Ml().load(t, function (t) {
              e.setBuffer(t)
            }),
            this
          )
        }),
        (Fi.prototype.updateCubeMap = function (t, e) {
          return this.update(t, e)
        }),
        (Fi.prototype.clear = function (t, e, i, n) {
          return this.renderTarget.clear(t, e, i, n)
        }),
        (vt.crossOrigin = void 0),
        (vt.loadTexture = function (t, e, i, n) {
          const s = new il()
          s.setCrossOrigin(this.crossOrigin)
          const r = s.load(t, i, void 0, n)
          return e && (r.mapping = e), r
        }),
        (vt.loadTextureCube = function (t, e, i, n) {
          const s = new tl()
          s.setCrossOrigin(this.crossOrigin)
          const r = s.load(t, i, void 0, n)
          return e && (r.mapping = e), r
        }),
        (vt.loadCompressedTexture = function () {}),
        (vt.loadCompressedTextureCube = function () {}),
        'undefined' != typeof __THREE_DEVTOOLS__ &&
          __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('register', { detail: { revision: '131' } })),
        'undefined' != typeof window && (window.__THREE__ || (window.__THREE__ = '131'))
      const Jl = new WeakMap()
      function Xl() {
        let t, e
        function i(t, e, i, n, s, r) {
          const a = r.num_components(),
            o = i.num_points() * a,
            l = o * s.BYTES_PER_ELEMENT,
            c = (function (t, e) {
              switch (e) {
                case Float32Array:
                  return t.DT_FLOAT32
                case Int8Array:
                  return t.DT_INT8
                case Int16Array:
                  return t.DT_INT16
                case Int32Array:
                  return t.DT_INT32
                case Uint8Array:
                  return t.DT_UINT8
                case Uint16Array:
                  return t.DT_UINT16
                case Uint32Array:
                  return t.DT_UINT32
              }
            })(t, s),
            h = t._malloc(l)
          e.GetAttributeDataArrayForAllPoints(i, r, c, l, h)
          const u = new s(t.HEAPF32.buffer, h, o).slice()
          return t._free(h), { name: n, array: u, itemSize: a }
        }
        onmessage = function (n) {
          const s = n.data
          switch (s.type) {
            case 'init':
              ;(t = s.decoderConfig),
                (e = new Promise(function (e) {
                  ;(t.onModuleLoaded = function (t) {
                    e({ draco: t })
                  }),
                    DracoDecoderModule(t)
                }))
              break
            case 'decode':
              const n = s.buffer,
                r = s.taskConfig
              e.then((t) => {
                const e = t.draco,
                  a = new e.Decoder(),
                  o = new e.DecoderBuffer()
                o.Init(new Int8Array(n), n.byteLength)
                try {
                  const t = (function (t, e, n, s) {
                      const r = s.attributeIDs,
                        a = s.attributeTypes
                      let o, l
                      const c = e.GetEncodedGeometryType(n)
                      if (c === t.TRIANGULAR_MESH) (o = new t.Mesh()), (l = e.DecodeBufferToMesh(n, o))
                      else {
                        if (c !== t.POINT_CLOUD) throw new Error('THREE.DRACOLoader: Unexpected geometry type.')
                        ;(o = new t.PointCloud()), (l = e.DecodeBufferToPointCloud(n, o))
                      }
                      if (!l.ok() || 0 === o.ptr)
                        throw new Error('THREE.DRACOLoader: Decoding failed: ' + l.error_msg())
                      const h = { index: null, attributes: [] }
                      for (const u in r) {
                        const n = self[a[u]]
                        let l, c
                        if (s.useUniqueIDs) (c = r[u]), (l = e.GetAttributeByUniqueId(o, c))
                        else {
                          if (((c = e.GetAttributeId(o, t[r[u]])), -1 === c)) continue
                          l = e.GetAttribute(o, c)
                        }
                        h.attributes.push(i(t, e, o, u, n, l))
                      }
                      return (
                        c === t.TRIANGULAR_MESH &&
                          (h.index = (function (t, e, i) {
                            const n = 3 * i.num_faces(),
                              s = 4 * n,
                              r = t._malloc(s)
                            e.GetTrianglesUInt32Array(i, s, r)
                            const a = new Uint32Array(t.HEAPF32.buffer, r, n).slice()
                            return t._free(r), { array: a, itemSize: 1 }
                          })(t, e, o)),
                        t.destroy(o),
                        h
                      )
                    })(e, a, o, r),
                    n = t.attributes.map((t) => t.array.buffer)
                  t.index && n.push(t.index.array.buffer),
                    self.postMessage({ type: 'decode', id: s.id, geometry: t }, n)
                } catch (t) {
                  self.postMessage({ type: 'error', id: s.id, error: t.message })
                } finally {
                  e.destroy(o), e.destroy(a)
                }
              })
          }
        }
      }
      class Kl extends Jo {
        constructor(t) {
          super(t),
            (this.dracoLoader = null),
            (this.ktx2Loader = null),
            (this.meshoptDecoder = null),
            (this.pluginCallbacks = []),
            this.register(function (t) {
              return new ic(t)
            }),
            this.register(function (t) {
              return new oc(t)
            }),
            this.register(function (t) {
              return new lc(t)
            }),
            this.register(function (t) {
              return new nc(t)
            }),
            this.register(function (t) {
              return new sc(t)
            }),
            this.register(function (t) {
              return new rc(t)
            }),
            this.register(function (t) {
              return new ac(t)
            }),
            this.register(function (t) {
              return new tc(t)
            }),
            this.register(function (t) {
              return new cc(t)
            })
        }
        load(t, e, i, n) {
          const s = this
          let r
          ;(r = '' !== this.resourcePath ? this.resourcePath : '' !== this.path ? this.path : _l.extractUrlBase(t)),
            this.manager.itemStart(t)
          const a = function (e) {
              n && n(e), s.manager.itemError(t), s.manager.itemEnd(t)
            },
            o = new Ko(this.manager)
          o.setPath(this.path),
            o.setResponseType('arraybuffer'),
            o.setRequestHeader(this.requestHeader),
            o.setWithCredentials(this.withCredentials),
            o.load(
              t,
              function (i) {
                try {
                  s.parse(
                    i,
                    r,
                    function (i) {
                      e(i), s.manager.itemEnd(t)
                    },
                    a,
                  )
                } catch (t) {
                  a(t)
                }
              },
              i,
              a,
            )
        }
        setDRACOLoader(t) {
          return (this.dracoLoader = t), this
        }
        setDDSLoader() {
          throw new Error(
            'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".',
          )
        }
        setKTX2Loader(t) {
          return (this.ktx2Loader = t), this
        }
        setMeshoptDecoder(t) {
          return (this.meshoptDecoder = t), this
        }
        register(t) {
          return -1 === this.pluginCallbacks.indexOf(t) && this.pluginCallbacks.push(t), this
        }
        unregister(t) {
          return (
            -1 !== this.pluginCallbacks.indexOf(t) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(t), 1),
            this
          )
        }
        parse(t, e, i, n) {
          let s
          const r = {},
            a = {}
          if ('string' == typeof t) s = t
          else if (_l.decodeText(new Uint8Array(t, 0, 4)) === hc) {
            try {
              r[$l.KHR_BINARY_GLTF] = new uc(t)
            } catch (t) {
              return void (n && n(t))
            }
            s = r[$l.KHR_BINARY_GLTF].content
          } else s = _l.decodeText(new Uint8Array(t))
          const o = JSON.parse(s)
          if (void 0 === o.asset || o.asset.version[0] < 2)
            return void (n && n(new Error('THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.')))
          const l = new Qc(o, {
            path: e || this.resourcePath || '',
            crossOrigin: this.crossOrigin,
            requestHeader: this.requestHeader,
            manager: this.manager,
            ktx2Loader: this.ktx2Loader,
            meshoptDecoder: this.meshoptDecoder,
          })
          l.fileLoader.setRequestHeader(this.requestHeader)
          for (let c = 0; c < this.pluginCallbacks.length; c++) {
            const t = this.pluginCallbacks[c](l)
            ;(a[t.name] = t), (r[t.name] = !0)
          }
          if (o.extensionsUsed)
            for (let c = 0; c < o.extensionsUsed.length; ++c) {
              const t = o.extensionsUsed[c],
                e = o.extensionsRequired || []
              switch (t) {
                case $l.KHR_MATERIALS_UNLIT:
                  r[t] = new ec()
                  break
                case $l.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
                  r[t] = new gc()
                  break
                case $l.KHR_DRACO_MESH_COMPRESSION:
                  r[t] = new dc(o, this.dracoLoader)
                  break
                case $l.KHR_TEXTURE_TRANSFORM:
                  r[t] = new pc()
                  break
                case $l.KHR_MESH_QUANTIZATION:
                  r[t] = new mc()
                  break
                default:
                  e.indexOf(t) >= 0 && a[t]
              }
            }
          l.setExtensions(r), l.setPlugins(a), l.parse(i, n)
        }
      }
      function Zl() {
        let t = {}
        return {
          get: function (e) {
            return t[e]
          },
          add: function (e, i) {
            t[e] = i
          },
          remove: function (e) {
            delete t[e]
          },
          removeAll: function () {
            t = {}
          },
        }
      }
      const $l = {
        KHR_BINARY_GLTF: 'KHR_binary_glTF',
        KHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',
        KHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',
        KHR_MATERIALS_CLEARCOAT: 'KHR_materials_clearcoat',
        KHR_MATERIALS_IOR: 'KHR_materials_ior',
        KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: 'KHR_materials_pbrSpecularGlossiness',
        KHR_MATERIALS_SPECULAR: 'KHR_materials_specular',
        KHR_MATERIALS_TRANSMISSION: 'KHR_materials_transmission',
        KHR_MATERIALS_UNLIT: 'KHR_materials_unlit',
        KHR_MATERIALS_VOLUME: 'KHR_materials_volume',
        KHR_TEXTURE_BASISU: 'KHR_texture_basisu',
        KHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',
        KHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',
        EXT_TEXTURE_WEBP: 'EXT_texture_webp',
        EXT_MESHOPT_COMPRESSION: 'EXT_meshopt_compression',
      }
      class tc {
        constructor(t) {
          ;(this.parser = t), (this.name = $l.KHR_LIGHTS_PUNCTUAL), (this.cache = { refs: {}, uses: {} })
        }
        _markDefs() {
          const t = this.parser,
            e = this.parser.json.nodes || []
          for (let i = 0, n = e.length; i < n; i++) {
            const n = e[i]
            n.extensions &&
              n.extensions[this.name] &&
              void 0 !== n.extensions[this.name].light &&
              t._addNodeRef(this.cache, n.extensions[this.name].light)
          }
        }
        _loadLight(t) {
          const e = this.parser,
            i = 'light:' + t
          let n = e.cache.get(i)
          if (n) return n
          const s = e.json,
            r = (((s.extensions && s.extensions[this.name]) || {}).lights || [])[t]
          let a
          const o = new Ye(16777215)
          void 0 !== r.color && o.fromArray(r.color)
          const l = void 0 !== r.range ? r.range : 0
          switch (r.type) {
            case 'directional':
              ;(a = new yl(o)), a.target.position.set(0, 0, -1), a.add(a.target)
              break
            case 'point':
              ;(a = new fl(o)), (a.distance = l)
              break
            case 'spot':
              ;(a = new dl(o)),
                (a.distance = l),
                (r.spot = r.spot || {}),
                (r.spot.innerConeAngle = void 0 !== r.spot.innerConeAngle ? r.spot.innerConeAngle : 0),
                (r.spot.outerConeAngle = void 0 !== r.spot.outerConeAngle ? r.spot.outerConeAngle : Math.PI / 4),
                (a.angle = r.spot.outerConeAngle),
                (a.penumbra = 1 - r.spot.innerConeAngle / r.spot.outerConeAngle),
                a.target.position.set(0, 0, -1),
                a.add(a.target)
              break
            default:
              throw new Error('THREE.GLTFLoader: Unexpected light type: ' + r.type)
          }
          return (
            a.position.set(0, 0, 0),
            (a.decay = 2),
            void 0 !== r.intensity && (a.intensity = r.intensity),
            (a.name = e.createUniqueName(r.name || 'light_' + t)),
            (n = Promise.resolve(a)),
            e.cache.add(i, n),
            n
          )
        }
        createNodeAttachment(t) {
          const e = this,
            i = this.parser,
            n = i.json.nodes[t],
            s = ((n.extensions && n.extensions[this.name]) || {}).light
          return void 0 === s
            ? null
            : this._loadLight(s).then(function (t) {
                return i._getNodeRef(e.cache, s, t)
              })
        }
      }
      class ec {
        constructor() {
          this.name = $l.KHR_MATERIALS_UNLIT
        }
        getMaterialType() {
          return Je
        }
        extendParams(t, e, i) {
          const n = []
          ;(t.color = new Ye(1, 1, 1)), (t.opacity = 1)
          const s = e.pbrMetallicRoughness
          if (s) {
            if (Array.isArray(s.baseColorFactor)) {
              const e = s.baseColorFactor
              t.color.fromArray(e), (t.opacity = e[3])
            }
            void 0 !== s.baseColorTexture && n.push(i.assignTexture(t, 'map', s.baseColorTexture))
          }
          return Promise.all(n)
        }
      }
      class ic {
        constructor(t) {
          ;(this.parser = t), (this.name = $l.KHR_MATERIALS_CLEARCOAT)
        }
        getMaterialType(t) {
          const e = this.parser.json.materials[t]
          return e.extensions && e.extensions[this.name] ? Lo : null
        }
        extendMaterialParams(t, e) {
          const i = this.parser,
            n = i.json.materials[t]
          if (!n.extensions || !n.extensions[this.name]) return Promise.resolve()
          const s = [],
            r = n.extensions[this.name]
          if (
            (void 0 !== r.clearcoatFactor && (e.clearcoat = r.clearcoatFactor),
            void 0 !== r.clearcoatTexture && s.push(i.assignTexture(e, 'clearcoatMap', r.clearcoatTexture)),
            void 0 !== r.clearcoatRoughnessFactor && (e.clearcoatRoughness = r.clearcoatRoughnessFactor),
            void 0 !== r.clearcoatRoughnessTexture &&
              s.push(i.assignTexture(e, 'clearcoatRoughnessMap', r.clearcoatRoughnessTexture)),
            void 0 !== r.clearcoatNormalTexture &&
              (s.push(i.assignTexture(e, 'clearcoatNormalMap', r.clearcoatNormalTexture)),
              void 0 !== r.clearcoatNormalTexture.scale))
          ) {
            const t = r.clearcoatNormalTexture.scale
            e.clearcoatNormalScale = new gt(t, -t)
          }
          return Promise.all(s)
        }
      }
      class nc {
        constructor(t) {
          ;(this.parser = t), (this.name = $l.KHR_MATERIALS_TRANSMISSION)
        }
        getMaterialType(t) {
          const e = this.parser.json.materials[t]
          return e.extensions && e.extensions[this.name] ? Lo : null
        }
        extendMaterialParams(t, e) {
          const i = this.parser,
            n = i.json.materials[t]
          if (!n.extensions || !n.extensions[this.name]) return Promise.resolve()
          const s = [],
            r = n.extensions[this.name]
          return (
            void 0 !== r.transmissionFactor && (e.transmission = r.transmissionFactor),
            void 0 !== r.transmissionTexture && s.push(i.assignTexture(e, 'transmissionMap', r.transmissionTexture)),
            Promise.all(s)
          )
        }
      }
      class sc {
        constructor(t) {
          ;(this.parser = t), (this.name = $l.KHR_MATERIALS_VOLUME)
        }
        getMaterialType(t) {
          const e = this.parser.json.materials[t]
          return e.extensions && e.extensions[this.name] ? Lo : null
        }
        extendMaterialParams(t, e) {
          const i = this.parser,
            n = i.json.materials[t]
          if (!n.extensions || !n.extensions[this.name]) return Promise.resolve()
          const s = [],
            r = n.extensions[this.name]
          ;(e.thickness = void 0 !== r.thicknessFactor ? r.thicknessFactor : 0),
            void 0 !== r.thicknessTexture && s.push(i.assignTexture(e, 'thicknessMap', r.thicknessTexture)),
            (e.attenuationDistance = r.attenuationDistance || 0)
          const a = r.attenuationColor || [1, 1, 1]
          return (e.attenuationTint = new Ye(a[0], a[1], a[2])), Promise.all(s)
        }
      }
      class rc {
        constructor(t) {
          ;(this.parser = t), (this.name = $l.KHR_MATERIALS_IOR)
        }
        getMaterialType(t) {
          const e = this.parser.json.materials[t]
          return e.extensions && e.extensions[this.name] ? Lo : null
        }
        extendMaterialParams(t, e) {
          const i = this.parser.json.materials[t]
          if (!i.extensions || !i.extensions[this.name]) return Promise.resolve()
          const n = i.extensions[this.name]
          return (e.ior = void 0 !== n.ior ? n.ior : 1.5), Promise.resolve()
        }
      }
      class ac {
        constructor(t) {
          ;(this.parser = t), (this.name = $l.KHR_MATERIALS_SPECULAR)
        }
        getMaterialType(t) {
          const e = this.parser.json.materials[t]
          return e.extensions && e.extensions[this.name] ? Lo : null
        }
        extendMaterialParams(t, e) {
          const i = this.parser,
            n = i.json.materials[t]
          if (!n.extensions || !n.extensions[this.name]) return Promise.resolve()
          const s = [],
            r = n.extensions[this.name]
          ;(e.specularIntensity = void 0 !== r.specularFactor ? r.specularFactor : 1),
            void 0 !== r.specularTexture && s.push(i.assignTexture(e, 'specularIntensityMap', r.specularTexture))
          const a = r.specularColorFactor || [1, 1, 1]
          return (
            (e.specularTint = new Ye(a[0], a[1], a[2])),
            void 0 !== r.specularColorTexture &&
              s.push(
                i.assignTexture(e, 'specularTintMap', r.specularColorTexture).then(function (t) {
                  t.encoding = 3001
                }),
              ),
            Promise.all(s)
          )
        }
      }
      class oc {
        constructor(t) {
          ;(this.parser = t), (this.name = $l.KHR_TEXTURE_BASISU)
        }
        loadTexture(t) {
          const e = this.parser,
            i = e.json,
            n = i.textures[t]
          if (!n.extensions || !n.extensions[this.name]) return null
          const s = n.extensions[this.name],
            r = i.images[s.source],
            a = e.options.ktx2Loader
          if (!a) {
            if (i.extensionsRequired && i.extensionsRequired.indexOf(this.name) >= 0)
              throw new Error('THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures')
            return null
          }
          return e.loadTextureImage(t, r, a)
        }
      }
      class lc {
        constructor(t) {
          ;(this.parser = t), (this.name = $l.EXT_TEXTURE_WEBP), (this.isSupported = null)
        }
        loadTexture(t) {
          const e = this.name,
            i = this.parser,
            n = i.json,
            s = n.textures[t]
          if (!s.extensions || !s.extensions[e]) return null
          const r = s.extensions[e],
            a = n.images[r.source]
          let o = i.textureLoader
          if (a.uri) {
            const t = i.options.manager.getHandler(a.uri)
            null !== t && (o = t)
          }
          return this.detectSupport().then(function (s) {
            if (s) return i.loadTextureImage(t, a, o)
            if (n.extensionsRequired && n.extensionsRequired.indexOf(e) >= 0)
              throw new Error('THREE.GLTFLoader: WebP required by asset but unsupported.')
            return i.loadTexture(t)
          })
        }
        detectSupport() {
          return (
            this.isSupported ||
              (this.isSupported = new Promise(function (t) {
                const e = new Image()
                ;(e.src = 'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA'),
                  (e.onload = e.onerror =
                    function () {
                      t(1 === e.height)
                    })
              })),
            this.isSupported
          )
        }
      }
      class cc {
        constructor(t) {
          ;(this.name = $l.EXT_MESHOPT_COMPRESSION), (this.parser = t)
        }
        loadBufferView(t) {
          const e = this.parser.json,
            i = e.bufferViews[t]
          if (i.extensions && i.extensions[this.name]) {
            const t = i.extensions[this.name],
              n = this.parser.getDependency('buffer', t.buffer),
              s = this.parser.options.meshoptDecoder
            if (!s || !s.supported) {
              if (e.extensionsRequired && e.extensionsRequired.indexOf(this.name) >= 0)
                throw new Error('THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files')
              return null
            }
            return Promise.all([n, s.ready]).then(function (e) {
              const i = t.byteOffset || 0,
                n = t.byteLength || 0,
                r = t.count,
                a = t.byteStride,
                o = new ArrayBuffer(r * a),
                l = new Uint8Array(e[0], i, n)
              return s.decodeGltfBuffer(new Uint8Array(o), r, a, l, t.mode, t.filter), o
            })
          }
          return null
        }
      }
      const hc = 'glTF'
      class uc {
        constructor(t) {
          ;(this.name = $l.KHR_BINARY_GLTF), (this.content = null), (this.body = null)
          const e = new DataView(t, 0, 12)
          if (
            ((this.header = {
              magic: _l.decodeText(new Uint8Array(t.slice(0, 4))),
              version: e.getUint32(4, !0),
              length: e.getUint32(8, !0),
            }),
            this.header.magic !== hc)
          )
            throw new Error('THREE.GLTFLoader: Unsupported glTF-Binary header.')
          if (this.header.version < 2) throw new Error('THREE.GLTFLoader: Legacy binary file detected.')
          const i = this.header.length - 12,
            n = new DataView(t, 12)
          let s = 0
          for (; s < i; ) {
            const e = n.getUint32(s, !0)
            s += 4
            const i = n.getUint32(s, !0)
            if (((s += 4), 1313821514 === i)) {
              const i = new Uint8Array(t, 12 + s, e)
              this.content = _l.decodeText(i)
            } else if (5130562 === i) {
              const i = 12 + s
              this.body = t.slice(i, i + e)
            }
            s += e
          }
          if (null === this.content) throw new Error('THREE.GLTFLoader: JSON content not found.')
        }
      }
      class dc {
        constructor(t, e) {
          if (!e) throw new Error('THREE.GLTFLoader: No DRACOLoader instance provided.')
          ;(this.name = $l.KHR_DRACO_MESH_COMPRESSION),
            (this.json = t),
            (this.dracoLoader = e),
            this.dracoLoader.preload()
        }
        decodePrimitive(t, e) {
          const i = this.json,
            n = this.dracoLoader,
            s = t.extensions[this.name].bufferView,
            r = t.extensions[this.name].attributes,
            a = {},
            o = {},
            l = {}
          for (const c in r) {
            const t = _c[c] || c.toLowerCase()
            a[t] = r[c]
          }
          for (const c in t.attributes) {
            const e = _c[c] || c.toLowerCase()
            if (void 0 !== r[c]) {
              const n = i.accessors[t.attributes[c]],
                s = vc[n.componentType]
              ;(l[e] = s), (o[e] = !0 === n.normalized)
            }
          }
          return e.getDependency('bufferView', s).then(function (t) {
            return new Promise(function (e) {
              n.decodeDracoFile(
                t,
                function (t) {
                  for (const e in t.attributes) {
                    const i = t.attributes[e],
                      n = o[e]
                    void 0 !== n && (i.normalized = n)
                  }
                  e(t)
                },
                a,
                l,
              )
            })
          })
        }
      }
      class pc {
        constructor() {
          this.name = $l.KHR_TEXTURE_TRANSFORM
        }
        extendTexture(t, e) {
          return (
            e.texCoord,
            (void 0 === e.offset && void 0 === e.rotation && void 0 === e.scale) ||
              ((t = t.clone()),
              void 0 !== e.offset && t.offset.fromArray(e.offset),
              void 0 !== e.rotation && (t.rotation = e.rotation),
              void 0 !== e.scale && t.repeat.fromArray(e.scale),
              (t.needsUpdate = !0)),
            t
          )
        }
      }
      class Ac extends To {
        constructor(t) {
          super(), (this.isGLTFSpecularGlossinessMaterial = !0)
          const e = ['#ifdef USE_SPECULARMAP', '\tuniform sampler2D specularMap;', '#endif'].join('\n'),
            i = ['#ifdef USE_GLOSSINESSMAP', '\tuniform sampler2D glossinessMap;', '#endif'].join('\n'),
            n = [
              'vec3 specularFactor = specular;',
              '#ifdef USE_SPECULARMAP',
              '\tvec4 texelSpecular = texture2D( specularMap, vUv );',
              '\ttexelSpecular = sRGBToLinear( texelSpecular );',
              '\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture',
              '\tspecularFactor *= texelSpecular.rgb;',
              '#endif',
            ].join('\n'),
            s = [
              'float glossinessFactor = glossiness;',
              '#ifdef USE_GLOSSINESSMAP',
              '\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );',
              '\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture',
              '\tglossinessFactor *= texelGlossiness.a;',
              '#endif',
            ].join('\n'),
            r = [
              'PhysicalMaterial material;',
              'material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );',
              'vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );',
              'float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );',
              'material.specularRoughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.',
              'material.specularRoughness += geometryRoughness;',
              'material.specularRoughness = min( material.specularRoughness, 1.0 );',
              'material.specularColor = specularFactor;',
            ].join('\n'),
            a = {
              specular: { value: new Ye().setHex(16777215) },
              glossiness: { value: 1 },
              specularMap: { value: null },
              glossinessMap: { value: null },
            }
          ;(this._extraUniforms = a),
            (this.onBeforeCompile = function (t) {
              for (const e in a) t.uniforms[e] = a[e]
              t.fragmentShader = t.fragmentShader
                .replace('uniform float roughness;', 'uniform vec3 specular;')
                .replace('uniform float metalness;', 'uniform float glossiness;')
                .replace('#include <roughnessmap_pars_fragment>', e)
                .replace('#include <metalnessmap_pars_fragment>', i)
                .replace('#include <roughnessmap_fragment>', n)
                .replace('#include <metalnessmap_fragment>', s)
                .replace('#include <lights_physical_fragment>', r)
            }),
            Object.defineProperties(this, {
              specular: {
                get: function () {
                  return a.specular.value
                },
                set: function (t) {
                  a.specular.value = t
                },
              },
              specularMap: {
                get: function () {
                  return a.specularMap.value
                },
                set: function (t) {
                  ;(a.specularMap.value = t),
                    t ? (this.defines.USE_SPECULARMAP = '') : delete this.defines.USE_SPECULARMAP
                },
              },
              glossiness: {
                get: function () {
                  return a.glossiness.value
                },
                set: function (t) {
                  a.glossiness.value = t
                },
              },
              glossinessMap: {
                get: function () {
                  return a.glossinessMap.value
                },
                set: function (t) {
                  ;(a.glossinessMap.value = t),
                    t
                      ? ((this.defines.USE_GLOSSINESSMAP = ''), (this.defines.USE_UV = ''))
                      : (delete this.defines.USE_GLOSSINESSMAP, delete this.defines.USE_UV)
                },
              },
            }),
            delete this.metalness,
            delete this.roughness,
            delete this.metalnessMap,
            delete this.roughnessMap,
            this.setValues(t)
        }
        copy(t) {
          return (
            super.copy(t),
            (this.specularMap = t.specularMap),
            this.specular.copy(t.specular),
            (this.glossinessMap = t.glossinessMap),
            (this.glossiness = t.glossiness),
            delete this.metalness,
            delete this.roughness,
            delete this.metalnessMap,
            delete this.roughnessMap,
            this
          )
        }
      }
      class gc {
        constructor() {
          ;(this.name = $l.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS),
            (this.specularGlossinessParams = [
              'color',
              'map',
              'lightMap',
              'lightMapIntensity',
              'aoMap',
              'aoMapIntensity',
              'emissive',
              'emissiveIntensity',
              'emissiveMap',
              'bumpMap',
              'bumpScale',
              'normalMap',
              'normalMapType',
              'displacementMap',
              'displacementScale',
              'displacementBias',
              'specularMap',
              'specular',
              'glossinessMap',
              'glossiness',
              'alphaMap',
              'envMap',
              'envMapIntensity',
              'refractionRatio',
            ])
        }
        getMaterialType() {
          return Ac
        }
        extendParams(t, e, i) {
          const n = e.extensions[this.name]
          ;(t.color = new Ye(1, 1, 1)), (t.opacity = 1)
          const s = []
          if (Array.isArray(n.diffuseFactor)) {
            const e = n.diffuseFactor
            t.color.fromArray(e), (t.opacity = e[3])
          }
          if (
            (void 0 !== n.diffuseTexture && s.push(i.assignTexture(t, 'map', n.diffuseTexture)),
            (t.emissive = new Ye(0, 0, 0)),
            (t.glossiness = void 0 !== n.glossinessFactor ? n.glossinessFactor : 1),
            (t.specular = new Ye(1, 1, 1)),
            Array.isArray(n.specularFactor) && t.specular.fromArray(n.specularFactor),
            void 0 !== n.specularGlossinessTexture)
          ) {
            const e = n.specularGlossinessTexture
            s.push(i.assignTexture(t, 'glossinessMap', e)), s.push(i.assignTexture(t, 'specularMap', e))
          }
          return Promise.all(s)
        }
        createMaterial(t) {
          const e = new Ac(t)
          return (
            (e.fog = !0),
            (e.color = t.color),
            (e.map = void 0 === t.map ? null : t.map),
            (e.lightMap = null),
            (e.lightMapIntensity = 1),
            (e.aoMap = void 0 === t.aoMap ? null : t.aoMap),
            (e.aoMapIntensity = 1),
            (e.emissive = t.emissive),
            (e.emissiveIntensity = 1),
            (e.emissiveMap = void 0 === t.emissiveMap ? null : t.emissiveMap),
            (e.bumpMap = void 0 === t.bumpMap ? null : t.bumpMap),
            (e.bumpScale = 1),
            (e.normalMap = void 0 === t.normalMap ? null : t.normalMap),
            (e.normalMapType = 0),
            t.normalScale && (e.normalScale = t.normalScale),
            (e.displacementMap = null),
            (e.displacementScale = 1),
            (e.displacementBias = 0),
            (e.specularMap = void 0 === t.specularMap ? null : t.specularMap),
            (e.specular = t.specular),
            (e.glossinessMap = void 0 === t.glossinessMap ? null : t.glossinessMap),
            (e.glossiness = t.glossiness),
            (e.alphaMap = null),
            (e.envMap = void 0 === t.envMap ? null : t.envMap),
            (e.envMapIntensity = 1),
            (e.refractionRatio = 0.98),
            e
          )
        }
      }
      class mc {
        constructor() {
          this.name = $l.KHR_MESH_QUANTIZATION
        }
      }
      class fc extends Qo {
        constructor(t, e, i, n) {
          super(t, e, i, n)
        }
        copySampleValue_(t) {
          const e = this.resultBuffer,
            i = this.sampleValues,
            n = this.valueSize,
            s = t * n * 3 + n
          for (let r = 0; r !== n; r++) e[r] = i[s + r]
          return e
        }
      }
      ;(fc.prototype.beforeStart_ = fc.prototype.copySampleValue_),
        (fc.prototype.afterEnd_ = fc.prototype.copySampleValue_),
        (fc.prototype.interpolate_ = function (t, e, i, n) {
          const s = this.resultBuffer,
            r = this.sampleValues,
            a = this.valueSize,
            o = 2 * a,
            l = 3 * a,
            c = n - e,
            h = (i - e) / c,
            u = h * h,
            d = u * h,
            p = t * l,
            A = p - l,
            g = -2 * d + 3 * u,
            m = d - u,
            f = 1 - g,
            v = m - u + h
          for (let y = 0; y !== a; y++) {
            const t = r[A + y + a],
              e = r[A + y + o] * c,
              i = r[p + y + a],
              n = r[p + y] * c
            s[y] = f * t + v * e + g * i + m * n
          }
          return s
        })
      const vc = {
          5120: Int8Array,
          5121: Uint8Array,
          5122: Int16Array,
          5123: Uint16Array,
          5125: Uint32Array,
          5126: Float32Array,
        },
        yc = { 9728: 1003, 9729: 1006, 9984: 1004, 9985: 1007, 9986: 1005, 9987: 1008 },
        xc = { 33071: 1001, 33648: 1002, 10497: 1e3 },
        wc = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 },
        _c = {
          POSITION: 'position',
          NORMAL: 'normal',
          TANGENT: 'tangent',
          TEXCOORD_0: 'uv',
          TEXCOORD_1: 'uv2',
          COLOR_0: 'color',
          WEIGHTS_0: 'skinWeight',
          JOINTS_0: 'skinIndex',
        },
        Ic = { scale: 'scale', translation: 'position', rotation: 'quaternion', weights: 'morphTargetInfluences' },
        Cc = { CUBICSPLINE: void 0, LINEAR: 2301, STEP: 2300 }
      function Mc(t, e) {
        return 'string' != typeof t || '' === t
          ? ''
          : (/^https?:\/\//i.test(e) && /^\//.test(t) && (e = e.replace(/(^https?:\/\/[^\/]+).*/i, '$1')),
            /^(https?:)?\/\//i.test(t) || /^data:.*,.*$/i.test(t) || /^blob:.*$/i.test(t) ? t : e + t)
      }
      function Ec(t) {
        return (
          void 0 === t.DefaultMaterial &&
            (t.DefaultMaterial = new To({
              color: 16777215,
              emissive: 0,
              metalness: 1,
              roughness: 1,
              transparent: !1,
              depthTest: !0,
              side: 0,
            })),
          t.DefaultMaterial
        )
      }
      function bc(t, e, i) {
        for (const n in i.extensions)
          void 0 === t[n] &&
            ((e.userData.gltfExtensions = e.userData.gltfExtensions || {}),
            (e.userData.gltfExtensions[n] = i.extensions[n]))
      }
      function Sc(t, e) {
        void 0 !== e.extras && 'object' == typeof e.extras && Object.assign(t.userData, e.extras)
      }
      function Bc(t, e) {
        if ((t.updateMorphTargets(), void 0 !== e.weights))
          for (let i = 0, n = e.weights.length; i < n; i++) t.morphTargetInfluences[i] = e.weights[i]
        if (e.extras && Array.isArray(e.extras.targetNames)) {
          const i = e.extras.targetNames
          if (t.morphTargetInfluences.length === i.length) {
            t.morphTargetDictionary = {}
            for (let e = 0, n = i.length; e < n; e++) t.morphTargetDictionary[i[e]] = e
          }
        }
      }
      function Tc(t) {
        const e = t.extensions && t.extensions[$l.KHR_DRACO_MESH_COMPRESSION]
        let i
        return (
          (i = e
            ? 'draco:' + e.bufferView + ':' + e.indices + ':' + Lc(e.attributes)
            : t.indices + ':' + Lc(t.attributes) + ':' + t.mode),
          i
        )
      }
      function Lc(t) {
        let e = ''
        const i = Object.keys(t).sort()
        for (let n = 0, s = i.length; n < s; n++) e += i[n] + ':' + t[i[n]] + ';'
        return e
      }
      function Dc(t) {
        switch (t) {
          case Int8Array:
            return 1 / 127
          case Uint8Array:
            return 1 / 255
          case Int16Array:
            return 1 / 32767
          case Uint16Array:
            return 1 / 65535
          default:
            throw new Error('THREE.GLTFLoader: Unsupported normalized accessor component type.')
        }
      }
      class Qc {
        constructor(t = {}, e = {}) {
          ;(this.json = t),
            (this.extensions = {}),
            (this.plugins = {}),
            (this.options = e),
            (this.cache = new Zl()),
            (this.associations = new Map()),
            (this.primitiveCache = {}),
            (this.meshCache = { refs: {}, uses: {} }),
            (this.cameraCache = { refs: {}, uses: {} }),
            (this.lightCache = { refs: {}, uses: {} }),
            (this.textureCache = {}),
            (this.nodeNamesUsed = {}),
            'undefined' != typeof createImageBitmap && !1 === /Firefox/.test(navigator.userAgent)
              ? (this.textureLoader = new Il(this.options.manager))
              : (this.textureLoader = new il(this.options.manager)),
            this.textureLoader.setCrossOrigin(this.options.crossOrigin),
            this.textureLoader.setRequestHeader(this.options.requestHeader),
            (this.fileLoader = new Ko(this.options.manager)),
            this.fileLoader.setResponseType('arraybuffer'),
            'use-credentials' === this.options.crossOrigin && this.fileLoader.setWithCredentials(!0)
        }
        setExtensions(t) {
          this.extensions = t
        }
        setPlugins(t) {
          this.plugins = t
        }
        parse(t, e) {
          const i = this,
            n = this.json,
            s = this.extensions
          this.cache.removeAll(),
            this._invokeAll(function (t) {
              return t._markDefs && t._markDefs()
            }),
            Promise.all(
              this._invokeAll(function (t) {
                return t.beforeRoot && t.beforeRoot()
              }),
            )
              .then(function () {
                return Promise.all([
                  i.getDependencies('scene'),
                  i.getDependencies('animation'),
                  i.getDependencies('camera'),
                ])
              })
              .then(function (e) {
                const r = {
                  scene: e[0][n.scene || 0],
                  scenes: e[0],
                  animations: e[1],
                  cameras: e[2],
                  asset: n.asset,
                  parser: i,
                  userData: {},
                }
                bc(s, r, n),
                  Sc(r, n),
                  Promise.all(
                    i._invokeAll(function (t) {
                      return t.afterRoot && t.afterRoot(r)
                    }),
                  ).then(function () {
                    t(r)
                  })
              })
              .catch(e)
        }
        _markDefs() {
          const t = this.json.nodes || [],
            e = this.json.skins || [],
            i = this.json.meshes || []
          for (let n = 0, s = e.length; n < s; n++) {
            const i = e[n].joints
            for (let e = 0, n = i.length; e < n; e++) t[i[e]].isBone = !0
          }
          for (let n = 0, s = t.length; n < s; n++) {
            const e = t[n]
            void 0 !== e.mesh &&
              (this._addNodeRef(this.meshCache, e.mesh), void 0 !== e.skin && (i[e.mesh].isSkinnedMesh = !0)),
              void 0 !== e.camera && this._addNodeRef(this.cameraCache, e.camera)
          }
        }
        _addNodeRef(t, e) {
          void 0 !== e && (void 0 === t.refs[e] && (t.refs[e] = t.uses[e] = 0), t.refs[e]++)
        }
        _getNodeRef(t, e, i) {
          if (t.refs[e] <= 1) return i
          const n = i.clone()
          return (n.name += '_instance_' + t.uses[e]++), n
        }
        _invokeOne(t) {
          const e = Object.values(this.plugins)
          e.push(this)
          for (let i = 0; i < e.length; i++) {
            const n = t(e[i])
            if (n) return n
          }
          return null
        }
        _invokeAll(t) {
          const e = Object.values(this.plugins)
          e.unshift(this)
          const i = []
          for (let n = 0; n < e.length; n++) {
            const s = t(e[n])
            s && i.push(s)
          }
          return i
        }
        getDependency(t, e) {
          const i = t + ':' + e
          let n = this.cache.get(i)
          if (!n) {
            switch (t) {
              case 'scene':
                n = this.loadScene(e)
                break
              case 'node':
                n = this.loadNode(e)
                break
              case 'mesh':
                n = this._invokeOne(function (t) {
                  return t.loadMesh && t.loadMesh(e)
                })
                break
              case 'accessor':
                n = this.loadAccessor(e)
                break
              case 'bufferView':
                n = this._invokeOne(function (t) {
                  return t.loadBufferView && t.loadBufferView(e)
                })
                break
              case 'buffer':
                n = this.loadBuffer(e)
                break
              case 'material':
                n = this._invokeOne(function (t) {
                  return t.loadMaterial && t.loadMaterial(e)
                })
                break
              case 'texture':
                n = this._invokeOne(function (t) {
                  return t.loadTexture && t.loadTexture(e)
                })
                break
              case 'skin':
                n = this.loadSkin(e)
                break
              case 'animation':
                n = this.loadAnimation(e)
                break
              case 'camera':
                n = this.loadCamera(e)
                break
              default:
                throw new Error('Unknown type: ' + t)
            }
            this.cache.add(i, n)
          }
          return n
        }
        getDependencies(t) {
          let e = this.cache.get(t)
          if (!e) {
            const i = this,
              n = this.json[t + ('mesh' === t ? 'es' : 's')] || []
            ;(e = Promise.all(
              n.map(function (e, n) {
                return i.getDependency(t, n)
              }),
            )),
              this.cache.add(t, e)
          }
          return e
        }
        loadBuffer(t) {
          const e = this.json.buffers[t],
            i = this.fileLoader
          if (e.type && 'arraybuffer' !== e.type)
            throw new Error('THREE.GLTFLoader: ' + e.type + ' buffer type is not supported.')
          if (void 0 === e.uri && 0 === t) return Promise.resolve(this.extensions[$l.KHR_BINARY_GLTF].body)
          const n = this.options
          return new Promise(function (t, s) {
            i.load(Mc(e.uri, n.path), t, void 0, function () {
              s(new Error('THREE.GLTFLoader: Failed to load buffer "' + e.uri + '".'))
            })
          })
        }
        loadBufferView(t) {
          const e = this.json.bufferViews[t]
          return this.getDependency('buffer', e.buffer).then(function (t) {
            const i = e.byteLength || 0,
              n = e.byteOffset || 0
            return t.slice(n, n + i)
          })
        }
        loadAccessor(t) {
          const e = this,
            i = this.json,
            n = this.json.accessors[t]
          if (void 0 === n.bufferView && void 0 === n.sparse) return Promise.resolve(null)
          const s = []
          return (
            void 0 !== n.bufferView ? s.push(this.getDependency('bufferView', n.bufferView)) : s.push(null),
            void 0 !== n.sparse &&
              (s.push(this.getDependency('bufferView', n.sparse.indices.bufferView)),
              s.push(this.getDependency('bufferView', n.sparse.values.bufferView))),
            Promise.all(s).then(function (t) {
              const s = t[0],
                r = wc[n.type],
                a = vc[n.componentType],
                o = a.BYTES_PER_ELEMENT,
                l = o * r,
                c = n.byteOffset || 0,
                h = void 0 !== n.bufferView ? i.bufferViews[n.bufferView].byteStride : void 0,
                u = !0 === n.normalized
              let d, p
              if (h && h !== l) {
                const t = Math.floor(c / h),
                  i = 'InterleavedBuffer:' + n.bufferView + ':' + n.componentType + ':' + t + ':' + n.count
                let l = e.cache.get(i)
                l || ((d = new a(s, t * h, (n.count * h) / o)), (l = new Pr(d, h / o)), e.cache.add(i, l)),
                  (p = new Fr(l, r, (c % h) / o, u))
              } else (d = null === s ? new a(n.count * r) : new a(s, c, n.count * r)), (p = new Ze(d, r, u))
              if (void 0 !== n.sparse) {
                const e = wc.SCALAR,
                  i = vc[n.sparse.indices.componentType],
                  o = n.sparse.indices.byteOffset || 0,
                  l = n.sparse.values.byteOffset || 0,
                  c = new i(t[1], o, n.sparse.count * e),
                  h = new a(t[2], l, n.sparse.count * r)
                null !== s && (p = new Ze(p.array.slice(), p.itemSize, p.normalized))
                for (let t = 0, n = c.length; t < n; t++) {
                  const e = c[t]
                  if (
                    (p.setX(e, h[t * r]),
                    r >= 2 && p.setY(e, h[t * r + 1]),
                    r >= 3 && p.setZ(e, h[t * r + 2]),
                    r >= 4 && p.setW(e, h[t * r + 3]),
                    r >= 5)
                  )
                    throw new Error('THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.')
                }
              }
              return p
            })
          )
        }
        loadTexture(t) {
          const e = this.json,
            i = this.options,
            n = e.textures[t],
            s = e.images[n.source]
          let r = this.textureLoader
          if (s.uri) {
            const t = i.manager.getHandler(s.uri)
            null !== t && (r = t)
          }
          return this.loadTextureImage(t, s, r)
        }
        loadTextureImage(t, e, i) {
          const n = this,
            s = this.json,
            r = this.options,
            a = s.textures[t],
            o = (e.uri || e.bufferView) + ':' + a.sampler
          if (this.textureCache[o]) return this.textureCache[o]
          const l = self.URL || self.webkitURL
          let c = e.uri || '',
            h = !1,
            u = !0
          const d = c.search(/\.jpe?g($|\?)/i) > 0 || 0 === c.search(/^data\:image\/jpeg/)
          if ((('image/jpeg' === e.mimeType || d) && (u = !1), void 0 !== e.bufferView))
            c = n.getDependency('bufferView', e.bufferView).then(function (t) {
              if ('image/png' === e.mimeType) {
                const e = new DataView(t, 25, 1).getUint8(0, !1)
                u = 6 === e || 4 === e || 3 === e
              }
              h = !0
              const i = new Blob([t], { type: e.mimeType })
              return (c = l.createObjectURL(i)), c
            })
          else if (void 0 === e.uri) throw new Error('THREE.GLTFLoader: Image ' + t + ' is missing URI and bufferView')
          const p = Promise.resolve(c)
            .then(function (t) {
              return new Promise(function (e, n) {
                let s = e
                !0 === i.isImageBitmapLoader &&
                  (s = function (t) {
                    const i = new xt(t)
                    ;(i.needsUpdate = !0), e(i)
                  }),
                  i.load(Mc(t, r.path), s, void 0, n)
              })
            })
            .then(function (e) {
              !0 === h && l.revokeObjectURL(c), (e.flipY = !1), a.name && (e.name = a.name), u || (e.format = 1022)
              const i = (s.samplers || {})[a.sampler] || {}
              return (
                (e.magFilter = yc[i.magFilter] || 1006),
                (e.minFilter = yc[i.minFilter] || 1008),
                (e.wrapS = xc[i.wrapS] || 1e3),
                (e.wrapT = xc[i.wrapT] || 1e3),
                n.associations.set(e, { type: 'textures', index: t }),
                e
              )
            })
            .catch(function () {
              return null
            })
          return (this.textureCache[o] = p), p
        }
        assignTexture(t, e, i) {
          const n = this
          return this.getDependency('texture', i.index).then(function (s) {
            if (
              (void 0 === i.texCoord || 0 == i.texCoord || ('aoMap' === e && i.texCoord),
              n.extensions[$l.KHR_TEXTURE_TRANSFORM])
            ) {
              const t = void 0 !== i.extensions ? i.extensions[$l.KHR_TEXTURE_TRANSFORM] : void 0
              if (t) {
                const e = n.associations.get(s)
                ;(s = n.extensions[$l.KHR_TEXTURE_TRANSFORM].extendTexture(s, t)), n.associations.set(s, e)
              }
            }
            return (t[e] = s), s
          })
        }
        assignFinalMaterial(t) {
          const e = t.geometry
          let i = t.material
          const n = void 0 !== e.attributes.tangent,
            s = void 0 !== e.attributes.color,
            r = void 0 === e.attributes.normal
          if (t.isPoints) {
            const t = 'PointsMaterial:' + i.uuid
            let e = this.cache.get(t)
            e ||
              ((e = new Ma()),
              Ge.prototype.copy.call(e, i),
              e.color.copy(i.color),
              (e.map = i.map),
              (e.sizeAttenuation = !1),
              this.cache.add(t, e)),
              (i = e)
          } else if (t.isLine) {
            const t = 'LineBasicMaterial:' + i.uuid
            let e = this.cache.get(t)
            e || ((e = new Aa()), Ge.prototype.copy.call(e, i), e.color.copy(i.color), this.cache.add(t, e)), (i = e)
          }
          if (n || s || r) {
            let t = 'ClonedMaterial:' + i.uuid + ':'
            i.isGLTFSpecularGlossinessMaterial && (t += 'specular-glossiness:'),
              n && (t += 'vertex-tangents:'),
              s && (t += 'vertex-colors:'),
              r && (t += 'flat-shading:')
            let e = this.cache.get(t)
            e ||
              ((e = i.clone()),
              s && (e.vertexColors = !0),
              r && (e.flatShading = !0),
              n &&
                (e.normalScale && (e.normalScale.y *= -1), e.clearcoatNormalScale && (e.clearcoatNormalScale.y *= -1)),
              this.cache.add(t, e),
              this.associations.set(e, this.associations.get(i))),
              (i = e)
          }
          i.aoMap &&
            void 0 === e.attributes.uv2 &&
            void 0 !== e.attributes.uv &&
            e.setAttribute('uv2', e.attributes.uv),
            (t.material = i)
        }
        getMaterialType() {
          return To
        }
        loadMaterial(t) {
          const e = this,
            i = this.json,
            n = this.extensions,
            s = i.materials[t]
          let r
          const a = {},
            o = s.extensions || {},
            l = []
          if (o[$l.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
            const t = n[$l.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]
            ;(r = t.getMaterialType()), l.push(t.extendParams(a, s, e))
          } else if (o[$l.KHR_MATERIALS_UNLIT]) {
            const t = n[$l.KHR_MATERIALS_UNLIT]
            ;(r = t.getMaterialType()), l.push(t.extendParams(a, s, e))
          } else {
            const i = s.pbrMetallicRoughness || {}
            if (((a.color = new Ye(1, 1, 1)), (a.opacity = 1), Array.isArray(i.baseColorFactor))) {
              const t = i.baseColorFactor
              a.color.fromArray(t), (a.opacity = t[3])
            }
            void 0 !== i.baseColorTexture && l.push(e.assignTexture(a, 'map', i.baseColorTexture)),
              (a.metalness = void 0 !== i.metallicFactor ? i.metallicFactor : 1),
              (a.roughness = void 0 !== i.roughnessFactor ? i.roughnessFactor : 1),
              void 0 !== i.metallicRoughnessTexture &&
                (l.push(e.assignTexture(a, 'metalnessMap', i.metallicRoughnessTexture)),
                l.push(e.assignTexture(a, 'roughnessMap', i.metallicRoughnessTexture))),
              (r = this._invokeOne(function (e) {
                return e.getMaterialType && e.getMaterialType(t)
              })),
              l.push(
                Promise.all(
                  this._invokeAll(function (e) {
                    return e.extendMaterialParams && e.extendMaterialParams(t, a)
                  }),
                ),
              )
          }
          !0 === s.doubleSided && (a.side = 2)
          const c = s.alphaMode || 'OPAQUE'
          return (
            'BLEND' === c
              ? ((a.transparent = !0), (a.depthWrite = !1))
              : ((a.transparent = !1), 'MASK' === c && (a.alphaTest = void 0 !== s.alphaCutoff ? s.alphaCutoff : 0.5)),
            void 0 !== s.normalTexture &&
              r !== Je &&
              (l.push(e.assignTexture(a, 'normalMap', s.normalTexture)),
              (a.normalScale = new gt(1, -1)),
              void 0 !== s.normalTexture.scale && a.normalScale.set(s.normalTexture.scale, -s.normalTexture.scale)),
            void 0 !== s.occlusionTexture &&
              r !== Je &&
              (l.push(e.assignTexture(a, 'aoMap', s.occlusionTexture)),
              void 0 !== s.occlusionTexture.strength && (a.aoMapIntensity = s.occlusionTexture.strength)),
            void 0 !== s.emissiveFactor && r !== Je && (a.emissive = new Ye().fromArray(s.emissiveFactor)),
            void 0 !== s.emissiveTexture && r !== Je && l.push(e.assignTexture(a, 'emissiveMap', s.emissiveTexture)),
            Promise.all(l).then(function () {
              let i
              return (
                (i = r === Ac ? n[$l.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(a) : new r(a)),
                s.name && (i.name = s.name),
                i.map && (i.map.encoding = 3001),
                i.emissiveMap && (i.emissiveMap.encoding = 3001),
                Sc(i, s),
                e.associations.set(i, { type: 'materials', index: t }),
                s.extensions && bc(n, i, s),
                i
              )
            })
          )
        }
        createUniqueName(t) {
          const e = Pl.sanitizeNodeName(t || '')
          let i = e
          for (let n = 1; this.nodeNamesUsed[i]; ++n) i = e + '_' + n
          return (this.nodeNamesUsed[i] = !0), i
        }
        loadGeometries(t) {
          const e = this,
            i = this.extensions,
            n = this.primitiveCache
          function s(t) {
            return i[$l.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(t, e).then(function (i) {
              return Pc(i, t, e)
            })
          }
          const r = []
          for (let a = 0, o = t.length; a < o; a++) {
            const i = t[a],
              o = Tc(i),
              l = n[o]
            if (l) r.push(l.promise)
            else {
              let t
              ;(t = i.extensions && i.extensions[$l.KHR_DRACO_MESH_COMPRESSION] ? s(i) : Pc(new hi(), i, e)),
                (n[o] = { primitive: i, promise: t }),
                r.push(t)
            }
          }
          return Promise.all(r)
        }
        loadMesh(t) {
          const e = this,
            i = this.json,
            n = this.extensions,
            s = i.meshes[t],
            r = s.primitives,
            a = []
          for (let o = 0, l = r.length; o < l; o++) {
            const t = void 0 === r[o].material ? Ec(this.cache) : this.getDependency('material', r[o].material)
            a.push(t)
          }
          return (
            a.push(e.loadGeometries(r)),
            Promise.all(a).then(function (i) {
              const a = i.slice(0, i.length - 1),
                o = i[i.length - 1],
                l = []
              for (let h = 0, u = o.length; h < u; h++) {
                const i = o[h],
                  c = r[h]
                let u
                const d = a[h]
                if (4 === c.mode || 5 === c.mode || 6 === c.mode || void 0 === c.mode)
                  (u = !0 === s.isSkinnedMesh ? new sa(i, d) : new Si(i, d)),
                    !0 !== u.isSkinnedMesh || u.geometry.attributes.skinWeight.normalized || u.normalizeSkinWeights(),
                    5 === c.mode ? (u.geometry = Nc(u.geometry, 1)) : 6 === c.mode && (u.geometry = Nc(u.geometry, 2))
                else if (1 === c.mode) u = new Ia(i, d)
                else if (3 === c.mode) u = new xa(i, d)
                else if (2 === c.mode) u = new Ca(i, d)
                else {
                  if (0 !== c.mode) throw new Error('THREE.GLTFLoader: Primitive mode unsupported: ' + c.mode)
                  u = new Ta(i, d)
                }
                Object.keys(u.geometry.morphAttributes).length > 0 && Bc(u, s),
                  (u.name = e.createUniqueName(s.name || 'mesh_' + t)),
                  Sc(u, s),
                  c.extensions && bc(n, u, c),
                  e.assignFinalMaterial(u),
                  l.push(u)
              }
              if (1 === l.length) return l[0]
              const c = new Sr()
              for (let t = 0, e = l.length; t < e; t++) c.add(l[t])
              return c
            })
          )
        }
        loadCamera(t) {
          let e
          const i = this.json.cameras[t],
            n = i[i.type]
          if (n)
            return (
              'perspective' === i.type
                ? (e = new Ni(At.radToDeg(n.yfov), n.aspectRatio || 1, n.znear || 1, n.zfar || 2e6))
                : 'orthographic' === i.type && (e = new an(-n.xmag, n.xmag, n.ymag, -n.ymag, n.znear, n.zfar)),
              i.name && (e.name = this.createUniqueName(i.name)),
              Sc(e, i),
              Promise.resolve(e)
            )
        }
        loadSkin(t) {
          const e = this.json.skins[t],
            i = { joints: e.joints }
          return void 0 === e.inverseBindMatrices
            ? Promise.resolve(i)
            : this.getDependency('accessor', e.inverseBindMatrices).then(function (t) {
                return (i.inverseBindMatrices = t), i
              })
        }
        loadAnimation(t) {
          const e = this.json.animations[t],
            i = [],
            n = [],
            s = [],
            r = [],
            a = []
          for (let o = 0, l = e.channels.length; o < l; o++) {
            const t = e.channels[o],
              l = e.samplers[t.sampler],
              c = t.target,
              h = void 0 !== c.node ? c.node : c.id,
              u = void 0 !== e.parameters ? e.parameters[l.input] : l.input,
              d = void 0 !== e.parameters ? e.parameters[l.output] : l.output
            i.push(this.getDependency('node', h)),
              n.push(this.getDependency('accessor', u)),
              s.push(this.getDependency('accessor', d)),
              r.push(l),
              a.push(c)
          }
          return Promise.all([Promise.all(i), Promise.all(n), Promise.all(s), Promise.all(r), Promise.all(a)]).then(
            function (i) {
              const n = i[0],
                s = i[1],
                r = i[2],
                a = i[3],
                o = i[4],
                l = []
              for (let t = 0, e = n.length; t < e; t++) {
                const e = n[t],
                  i = s[t],
                  c = r[t],
                  h = a[t],
                  u = o[t]
                if (void 0 === e) continue
                let d
                switch ((e.updateMatrix(), (e.matrixAutoUpdate = !0), Ic[u.path])) {
                  case Ic.weights:
                    d = Oo
                    break
                  case Ic.rotation:
                    d = zo
                    break
                  case Ic.position:
                  case Ic.scale:
                  default:
                    d = Ho
                }
                const p = e.name ? e.name : e.uuid,
                  A = void 0 !== h.interpolation ? Cc[h.interpolation] : 2301,
                  g = []
                Ic[u.path] === Ic.weights
                  ? e.traverse(function (t) {
                      !0 === t.isMesh && t.morphTargetInfluences && g.push(t.name ? t.name : t.uuid)
                    })
                  : g.push(p)
                let m = c.array
                if (c.normalized) {
                  const t = Dc(m.constructor),
                    e = new Float32Array(m.length)
                  for (let i = 0, n = m.length; i < n; i++) e[i] = m[i] * t
                  m = e
                }
                for (let t = 0, n = g.length; t < n; t++) {
                  const e = new d(g[t] + '.' + Ic[u.path], i.array, m, A)
                  'CUBICSPLINE' === h.interpolation &&
                    ((e.createInterpolant = function (t) {
                      return new fc(this.times, this.values, this.getValueSize() / 3, t)
                    }),
                    (e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0)),
                    l.push(e)
                }
              }
              const c = e.name ? e.name : 'animation_' + t
              return new Wo(c, void 0, l)
            },
          )
        }
        createNodeMesh(t) {
          const e = this.json,
            i = this,
            n = e.nodes[t]
          return void 0 === n.mesh
            ? null
            : i.getDependency('mesh', n.mesh).then(function (t) {
                const e = i._getNodeRef(i.meshCache, n.mesh, t)
                return (
                  void 0 !== n.weights &&
                    e.traverse(function (t) {
                      if (t.isMesh)
                        for (let e = 0, i = n.weights.length; e < i; e++) t.morphTargetInfluences[e] = n.weights[e]
                    }),
                  e
                )
              })
        }
        loadNode(t) {
          const e = this.json,
            i = this.extensions,
            n = this,
            s = e.nodes[t],
            r = s.name ? n.createUniqueName(s.name) : ''
          return (function () {
            const e = [],
              i = n._invokeOne(function (e) {
                return e.createNodeMesh && e.createNodeMesh(t)
              })
            return (
              i && e.push(i),
              void 0 !== s.camera &&
                e.push(
                  n.getDependency('camera', s.camera).then(function (t) {
                    return n._getNodeRef(n.cameraCache, s.camera, t)
                  }),
                ),
              n
                ._invokeAll(function (e) {
                  return e.createNodeAttachment && e.createNodeAttachment(t)
                })
                .forEach(function (t) {
                  e.push(t)
                }),
              Promise.all(e)
            )
          })().then(function (e) {
            let a
            if (
              ((a = !0 === s.isBone ? new ra() : e.length > 1 ? new Sr() : 1 === e.length ? e[0] : new Se()),
              a !== e[0])
            )
              for (let t = 0, i = e.length; t < i; t++) a.add(e[t])
            if (
              (s.name && ((a.userData.name = s.name), (a.name = r)),
              Sc(a, s),
              s.extensions && bc(i, a, s),
              void 0 !== s.matrix)
            ) {
              const t = new ne()
              t.fromArray(s.matrix), a.applyMatrix4(t)
            } else void 0 !== s.translation && a.position.fromArray(s.translation), void 0 !== s.rotation && a.quaternion.fromArray(s.rotation), void 0 !== s.scale && a.scale.fromArray(s.scale)
            return n.associations.set(a, { type: 'nodes', index: t }), a
          })
        }
        loadScene(t) {
          const e = this.json,
            i = this.extensions,
            n = this.json.scenes[t],
            s = this,
            r = new Sr()
          n.name && (r.name = s.createUniqueName(n.name)), Sc(r, n), n.extensions && bc(i, r, n)
          const a = n.nodes || [],
            o = []
          for (let l = 0, c = a.length; l < c; l++) o.push(Rc(a[l], r, e, s))
          return Promise.all(o).then(function () {
            return r
          })
        }
      }
      function Rc(t, e, i, n) {
        const s = i.nodes[t]
        return n
          .getDependency('node', t)
          .then(function (t) {
            if (void 0 === s.skin) return t
            let e
            return n
              .getDependency('skin', s.skin)
              .then(function (t) {
                e = t
                const i = []
                for (let s = 0, r = e.joints.length; s < r; s++) i.push(n.getDependency('node', e.joints[s]))
                return Promise.all(i)
              })
              .then(function (i) {
                return (
                  t.traverse(function (t) {
                    if (!t.isMesh) return
                    const n = [],
                      s = []
                    for (let r = 0, a = i.length; r < a; r++) {
                      const t = i[r]
                      if (t) {
                        n.push(t)
                        const i = new ne()
                        void 0 !== e.inverseBindMatrices && i.fromArray(e.inverseBindMatrices.array, 16 * r), s.push(i)
                      }
                    }
                    t.bind(new ca(n, s), t.matrixWorld)
                  }),
                  t
                )
              })
          })
          .then(function (t) {
            e.add(t)
            const r = []
            if (s.children) {
              const e = s.children
              for (let s = 0, a = e.length; s < a; s++) {
                const a = e[s]
                r.push(Rc(a, t, i, n))
              }
            }
            return Promise.all(r)
          })
      }
      function Pc(t, e, i) {
        const n = e.attributes,
          s = []
        function r(e, n) {
          return i.getDependency('accessor', e).then(function (e) {
            t.setAttribute(n, e)
          })
        }
        for (const a in n) {
          const e = _c[a] || a.toLowerCase()
          e in t.attributes || s.push(r(n[a], e))
        }
        if (void 0 !== e.indices && !t.index) {
          const n = i.getDependency('accessor', e.indices).then(function (e) {
            t.setIndex(e)
          })
          s.push(n)
        }
        return (
          Sc(t, e),
          (function (t, e, i) {
            const n = e.attributes,
              s = new Bt()
            if (void 0 === n.POSITION) return
            {
              const t = i.json.accessors[n.POSITION],
                e = t.min,
                r = t.max
              if (void 0 === e || void 0 === r) return
              if ((s.set(new Et(e[0], e[1], e[2]), new Et(r[0], r[1], r[2])), t.normalized)) {
                const e = Dc(vc[t.componentType])
                s.min.multiplyScalar(e), s.max.multiplyScalar(e)
              }
            }
            const r = e.targets
            if (void 0 !== r) {
              const t = new Et(),
                e = new Et()
              for (let n = 0, s = r.length; n < s; n++) {
                const s = r[n]
                if (void 0 !== s.POSITION) {
                  const n = i.json.accessors[s.POSITION],
                    r = n.min,
                    a = n.max
                  if (void 0 !== r && void 0 !== a) {
                    if (
                      (e.setX(Math.max(Math.abs(r[0]), Math.abs(a[0]))),
                      e.setY(Math.max(Math.abs(r[1]), Math.abs(a[1]))),
                      e.setZ(Math.max(Math.abs(r[2]), Math.abs(a[2]))),
                      n.normalized)
                    ) {
                      const t = Dc(vc[n.componentType])
                      e.multiplyScalar(t)
                    }
                    t.max(e)
                  }
                }
              }
              s.expandByVector(t)
            }
            t.boundingBox = s
            const a = new Yt()
            s.getCenter(a.center), (a.radius = s.min.distanceTo(s.max) / 2), (t.boundingSphere = a)
          })(t, e, i),
          Promise.all(s).then(function () {
            return void 0 !== e.targets
              ? (function (t, e, i) {
                  let n = !1,
                    s = !1
                  for (let o = 0, l = e.length; o < l; o++) {
                    const t = e[o]
                    if ((void 0 !== t.POSITION && (n = !0), void 0 !== t.NORMAL && (s = !0), n && s)) break
                  }
                  if (!n && !s) return Promise.resolve(t)
                  const r = [],
                    a = []
                  for (let o = 0, l = e.length; o < l; o++) {
                    const l = e[o]
                    if (n) {
                      const e = void 0 !== l.POSITION ? i.getDependency('accessor', l.POSITION) : t.attributes.position
                      r.push(e)
                    }
                    if (s) {
                      const e = void 0 !== l.NORMAL ? i.getDependency('accessor', l.NORMAL) : t.attributes.normal
                      a.push(e)
                    }
                  }
                  return Promise.all([Promise.all(r), Promise.all(a)]).then(function (e) {
                    const i = e[0],
                      r = e[1]
                    return (
                      n && (t.morphAttributes.position = i),
                      s && (t.morphAttributes.normal = r),
                      (t.morphTargetsRelative = !0),
                      t
                    )
                  })
                })(t, e.targets, i)
              : t
          })
        )
      }
      function Nc(t, e) {
        let i = t.getIndex()
        if (null === i) {
          const e = [],
            n = t.getAttribute('position')
          if (void 0 === n) return t
          for (let t = 0; t < n.count; t++) e.push(t)
          t.setIndex(e), (i = t.getIndex())
        }
        const n = i.count - 2,
          s = []
        if (2 === e) for (let a = 1; a <= n; a++) s.push(i.getX(0)), s.push(i.getX(a)), s.push(i.getX(a + 1))
        else
          for (let a = 0; a < n; a++)
            a % 2 == 0
              ? (s.push(i.getX(a)), s.push(i.getX(a + 1)), s.push(i.getX(a + 2)))
              : (s.push(i.getX(a + 2)), s.push(i.getX(a + 1)), s.push(i.getX(a)))
        s.length
        const r = t.clone()
        return r.setIndex(s), r
      }
      const Fc = [171, 75, 84, 88, 32, 50, 48, 187, 13, 10, 26, 10]
      var Uc, kc, Oc, Gc, zc, Vc, Hc, Wc, qc
      ;((qc = Uc || (Uc = {}))[(qc.NONE = 0)] = 'NONE'),
        (qc[(qc.BASISLZ = 1)] = 'BASISLZ'),
        (qc[(qc.ZSTD = 2)] = 'ZSTD'),
        (qc[(qc.ZLIB = 3)] = 'ZLIB'),
        (function (t) {
          t[(t.BASICFORMAT = 0)] = 'BASICFORMAT'
        })(kc || (kc = {})),
        (function (t) {
          ;(t[(t.UNSPECIFIED = 0)] = 'UNSPECIFIED'), (t[(t.ETC1S = 163)] = 'ETC1S'), (t[(t.UASTC = 166)] = 'UASTC')
        })(Oc || (Oc = {})),
        (function (t) {
          ;(t[(t.UNSPECIFIED = 0)] = 'UNSPECIFIED'), (t[(t.SRGB = 1)] = 'SRGB')
        })(Gc || (Gc = {})),
        (function (t) {
          ;(t[(t.UNSPECIFIED = 0)] = 'UNSPECIFIED'),
            (t[(t.LINEAR = 1)] = 'LINEAR'),
            (t[(t.SRGB = 2)] = 'SRGB'),
            (t[(t.ITU = 3)] = 'ITU'),
            (t[(t.NTSC = 4)] = 'NTSC'),
            (t[(t.SLOG = 5)] = 'SLOG'),
            (t[(t.SLOG2 = 6)] = 'SLOG2')
        })(zc || (zc = {})),
        (function (t) {
          ;(t[(t.ALPHA_STRAIGHT = 0)] = 'ALPHA_STRAIGHT'), (t[(t.ALPHA_PREMULTIPLIED = 1)] = 'ALPHA_PREMULTIPLIED')
        })(Vc || (Vc = {})),
        (function (t) {
          ;(t[(t.RGB = 0)] = 'RGB'), (t[(t.RRR = 3)] = 'RRR'), (t[(t.GGG = 4)] = 'GGG'), (t[(t.AAA = 15)] = 'AAA')
        })(Hc || (Hc = {})),
        (function (t) {
          ;(t[(t.RGB = 0)] = 'RGB'), (t[(t.RGBA = 3)] = 'RGBA'), (t[(t.RRR = 4)] = 'RRR'), (t[(t.RRRG = 5)] = 'RRRG')
        })(Wc || (Wc = {}))
      class jc {
        constructor() {
          ;(this.vkFormat = 0),
            (this.typeSize = 1),
            (this.pixelWidth = 0),
            (this.pixelHeight = 0),
            (this.pixelDepth = 0),
            (this.layerCount = 0),
            (this.faceCount = 1),
            (this.supercompressionScheme = Uc.NONE),
            (this.levels = []),
            (this.dataFormatDescriptor = [
              {
                vendorId: 0,
                descriptorType: kc.BASICFORMAT,
                versionNumber: 2,
                descriptorBlockSize: 40,
                colorModel: Oc.UNSPECIFIED,
                colorPrimaries: Gc.SRGB,
                transferFunction: Gc.SRGB,
                flags: Vc.ALPHA_STRAIGHT,
                texelBlockDimension: { x: 4, y: 4, z: 1, w: 1 },
                bytesPlane: [],
                samples: [],
              },
            ]),
            (this.keyValue = {}),
            (this.globalData = null)
        }
      }
      class Yc {
        constructor(t, e, i, n) {
          ;(this._dataView = new DataView(t.buffer, t.byteOffset + e, i)), (this._littleEndian = n), (this._offset = 0)
        }
        _nextUint8() {
          const t = this._dataView.getUint8(this._offset)
          return (this._offset += 1), t
        }
        _nextUint16() {
          const t = this._dataView.getUint16(this._offset, this._littleEndian)
          return (this._offset += 2), t
        }
        _nextUint32() {
          const t = this._dataView.getUint32(this._offset, this._littleEndian)
          return (this._offset += 4), t
        }
        _nextUint64() {
          const t =
            this._dataView.getUint32(this._offset, this._littleEndian) +
            2 ** 32 * this._dataView.getUint32(this._offset + 4, this._littleEndian)
          return (this._offset += 8), t
        }
        _skip(t) {
          return (this._offset += t), this
        }
        _scan(t, e = 0) {
          const i = this._offset
          let n = 0
          for (; this._dataView.getUint8(this._offset) !== e && n < t; ) n++, this._offset++
          return n < t && this._offset++, new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + i, n)
        }
      }
      function Jc(t) {
        return 'undefined' != typeof TextDecoder ? new TextDecoder().decode(t) : Buffer.from(t).toString('utf8')
      }
      const Xc = new WeakMap()
      class Kc extends Jo {
        constructor(t) {
          super(t),
            (this.transcoderPath = ''),
            (this.transcoderBinary = null),
            (this.transcoderPending = null),
            (this.workerLimit = 4),
            (this.workerPool = []),
            (this.workerNextTaskID = 1),
            (this.workerSourceURL = ''),
            (this.workerConfig = null)
        }
        setTranscoderPath(t) {
          return (this.transcoderPath = t), this
        }
        setWorkerLimit(t) {
          return (this.workerLimit = t), this
        }
        detectSupport(t) {
          return (
            (this.workerConfig = {
              astcSupported: t.extensions.has('WEBGL_compressed_texture_astc'),
              etc1Supported: t.extensions.has('WEBGL_compressed_texture_etc1'),
              etc2Supported: t.extensions.has('WEBGL_compressed_texture_etc'),
              dxtSupported: t.extensions.has('WEBGL_compressed_texture_s3tc'),
              bptcSupported: t.extensions.has('EXT_texture_compression_bptc'),
              pvrtcSupported:
                t.extensions.has('WEBGL_compressed_texture_pvrtc') ||
                t.extensions.has('WEBKIT_WEBGL_compressed_texture_pvrtc'),
            }),
            this
          )
        }
        load(t, e, i, n) {
          const s = new Ko(this.manager)
          s.setResponseType('arraybuffer'), s.setWithCredentials(this.withCredentials)
          const r = new Da()
          return (
            s.load(
              t,
              (t) => {
                if (Xc.has(t)) return Xc.get(t).promise.then(e).catch(n)
                this._createTexture([t])
                  .then(function (t) {
                    r.copy(t), (r.needsUpdate = !0), e && e(r)
                  })
                  .catch(n)
              },
              i,
              n,
            ),
            r
          )
        }
        parseInternalAsync(t) {
          const { levels: e } = t,
            i = new Set()
          for (let n = 0; n < e.length; n++) i.add(e[n].data.buffer)
          return this._createTexture(Array.from(i), { ...t, lowLevel: !0 })
        }
        _createTexture(t, e = {}) {
          let i, n
          const s = e
          let r = 0
          for (let o = 0; o < t.length; o++) r += t[o].byteLength
          const a = this._allocateWorker(r)
            .then(
              (e) => (
                (i = e),
                (n = this.workerNextTaskID++),
                new Promise((e, r) => {
                  ;(i._callbacks[n] = { resolve: e, reject: r }),
                    i.postMessage({ type: 'transcode', id: n, buffers: t, taskConfig: s }, t)
                })
              ),
            )
            .then((t) => {
              const { mipmaps: e, width: i, height: n, format: s } = t,
                r = new Da(e, i, n, s, 1009)
              return (
                (r.minFilter = 1 === e.length ? 1006 : 1008),
                (r.magFilter = 1006),
                (r.generateMipmaps = !1),
                (r.needsUpdate = !0),
                r
              )
            })
          return (
            a
              .catch(() => !0)
              .then(() => {
                i && n && ((i._taskLoad -= r), delete i._callbacks[n])
              }),
            Xc.set(t[0], { promise: a }),
            a
          )
        }
        _initTranscoder() {
          if (!this.transcoderPending) {
            const t = new Ko(this.manager)
            t.setPath(this.transcoderPath), t.setWithCredentials(this.withCredentials)
            const e = new Promise((e, i) => {
                t.load('basis_transcoder.js', e, void 0, i)
              }),
              i = new Ko(this.manager)
            i.setPath(this.transcoderPath), i.setResponseType('arraybuffer'), i.setWithCredentials(this.withCredentials)
            const n = new Promise((t, e) => {
              i.load('basis_transcoder.wasm', t, void 0, e)
            })
            this.transcoderPending = Promise.all([e, n]).then(([t, e]) => {
              const i = Kc.BasisWorker.toString(),
                n = [
                  '/* constants */',
                  'let _EngineFormat = ' + JSON.stringify(Kc.EngineFormat),
                  'let _TranscoderFormat = ' + JSON.stringify(Kc.TranscoderFormat),
                  'let _BasisFormat = ' + JSON.stringify(Kc.BasisFormat),
                  '/* basis_transcoder.js */',
                  t,
                  '/* worker */',
                  i.substring(i.indexOf('{') + 1, i.lastIndexOf('}')),
                ].join('\n')
              ;(this.workerSourceURL = URL.createObjectURL(new Blob([n]))), (this.transcoderBinary = e)
            })
          }
          return this.transcoderPending
        }
        _allocateWorker(t) {
          return this._initTranscoder().then(() => {
            if (this.workerPool.length < this.workerLimit) {
              const t = new Worker(this.workerSourceURL)
              ;(t._callbacks = {}),
                (t._taskLoad = 0),
                t.postMessage({ type: 'init', config: this.workerConfig, transcoderBinary: this.transcoderBinary }),
                (t.onmessage = function (e) {
                  const i = e.data
                  switch (i.type) {
                    case 'transcode':
                      t._callbacks[i.id].resolve(i)
                      break
                    case 'error':
                      t._callbacks[i.id].reject(i)
                  }
                }),
                this.workerPool.push(t)
            } else
              this.workerPool.sort(function (t, e) {
                return t._taskLoad > e._taskLoad ? -1 : 1
              })
            const e = this.workerPool[this.workerPool.length - 1]
            return (e._taskLoad += t), e
          })
        }
        dispose() {
          for (let t = 0; t < this.workerPool.length; t++) this.workerPool[t].terminate()
          return (this.workerPool.length = 0), this
        }
      }
      let Zc, $c, th
      ;(Kc.BasisFormat = { ETC1S: 0, UASTC_4x4: 1 }),
        (Kc.TranscoderFormat = {
          ETC1: 0,
          ETC2: 1,
          BC1: 2,
          BC3: 3,
          BC4: 4,
          BC5: 5,
          BC7_M6_OPAQUE_ONLY: 6,
          BC7_M5: 7,
          PVRTC1_4_RGB: 8,
          PVRTC1_4_RGBA: 9,
          ASTC_4x4: 10,
          ATC_RGB: 11,
          ATC_RGBA_INTERPOLATED_ALPHA: 12,
          RGBA32: 13,
          RGB565: 14,
          BGR565: 15,
          RGBA4444: 16,
        }),
        (Kc.EngineFormat = {
          RGBAFormat: 1023,
          RGBA_ASTC_4x4_Format: 37808,
          RGBA_BPTC_Format: 36492,
          RGBA_ETC2_EAC_Format: 37496,
          RGBA_PVRTC_4BPPV1_Format: 35842,
          RGBA_S3TC_DXT5_Format: 33779,
          RGB_ETC1_Format: 36196,
          RGB_ETC2_Format: 37492,
          RGB_PVRTC_4BPPV1_Format: 35840,
          RGB_S3TC_DXT1_Format: 33776,
        }),
        (Kc.BasisWorker = function () {
          let t, e, i
          const n = _EngineFormat,
            s = _TranscoderFormat,
            r = _BasisFormat
          onmessage = function (n) {
            const s = n.data
            switch (s.type) {
              case 'init':
                ;(t = s.config),
                  (a = s.transcoderBinary),
                  (e = new Promise((t) => {
                    ;(i = { wasmBinary: a, onRuntimeInitialized: t }), BASIS(i)
                  }).then(() => {
                    i.initializeBasis()
                  }))
                break
              case 'transcode':
                e.then(() => {
                  try {
                    const {
                        width: t,
                        height: e,
                        hasAlpha: n,
                        mipmaps: a,
                        format: o,
                      } = s.taskConfig.lowLevel
                        ? (function (t) {
                            const { basisFormat: e, width: n, height: s, hasAlpha: a } = t,
                              { transcoderFormat: o, engineFormat: l } = c(e, n, s, a),
                              A = i.getBytesPerBlockOrPixel(o)
                            h(i.isFormatSupported(o), 'THREE.BasisTextureLoader: Unsupported format.')
                            const g = []
                            if (e === r.ETC1S) {
                              const e = new i.LowLevelETC1SImageTranscoder(),
                                {
                                  endpointCount: n,
                                  endpointsData: s,
                                  selectorCount: r,
                                  selectorsData: l,
                                  tablesData: c,
                                } = t.globalData
                              try {
                                let i
                                ;(i = e.decodePalettes(n, s, r, l)),
                                  h(i, 'THREE.BasisTextureLoader: decodePalettes() failed.'),
                                  (i = e.decodeTables(c)),
                                  h(i, 'THREE.BasisTextureLoader: decodeTables() failed.')
                                for (let n = 0; n < t.levels.length; n++) {
                                  const s = t.levels[n],
                                    r = t.globalData.imageDescs[n],
                                    l = p(o, s.width, s.height),
                                    c = new Uint8Array(l)
                                  ;(i = e.transcodeImage(
                                    o,
                                    c,
                                    l / A,
                                    s.data,
                                    u(o, s.width),
                                    d(o, s.height),
                                    s.width,
                                    s.height,
                                    s.index,
                                    r.rgbSliceByteOffset,
                                    r.rgbSliceByteLength,
                                    r.alphaSliceByteOffset,
                                    r.alphaSliceByteLength,
                                    r.imageFlags,
                                    a,
                                    !1,
                                    0,
                                    0,
                                  )),
                                    h(
                                      i,
                                      'THREE.BasisTextureLoader: transcodeImage() failed for level ' + s.index + '.',
                                    ),
                                    g.push({ data: c, width: s.width, height: s.height })
                                }
                              } finally {
                                e.delete()
                              }
                            } else
                              for (let r = 0; r < t.levels.length; r++) {
                                const e = t.levels[r],
                                  n = p(o, e.width, e.height),
                                  s = new Uint8Array(n)
                                h(
                                  i.transcodeUASTCImage(
                                    o,
                                    s,
                                    n / A,
                                    e.data,
                                    u(o, e.width),
                                    d(o, e.height),
                                    e.width,
                                    e.height,
                                    e.index,
                                    0,
                                    e.data.byteLength,
                                    0,
                                    a,
                                    !1,
                                    0,
                                    0,
                                    -1,
                                    -1,
                                  ),
                                  'THREE.BasisTextureLoader: transcodeUASTCImage() failed for level ' + e.index + '.',
                                ),
                                  g.push({ data: s, width: e.width, height: e.height })
                              }
                            return { width: n, height: s, hasAlpha: a, mipmaps: g, format: l }
                          })(s.taskConfig)
                        : (function (t) {
                            const e = new i.BasisFile(new Uint8Array(t)),
                              n = e.isUASTC() ? r.UASTC_4x4 : r.ETC1S,
                              s = e.getImageWidth(0, 0),
                              a = e.getImageHeight(0, 0),
                              o = e.getNumLevels(0),
                              l = e.getHasAlpha()
                            function h() {
                              e.close(), e.delete()
                            }
                            const { transcoderFormat: u, engineFormat: d } = c(n, s, a, l)
                            if (!s || !a || !o) throw (h(), new Error('THREE.BasisTextureLoader:\tInvalid texture'))
                            if (!e.startTranscoding())
                              throw (h(), new Error('THREE.BasisTextureLoader: .startTranscoding failed'))
                            const p = []
                            for (let i = 0; i < o; i++) {
                              const t = e.getImageWidth(0, i),
                                n = e.getImageHeight(0, i),
                                s = new Uint8Array(e.getImageTranscodedSizeInBytes(0, i, u))
                              if (!e.transcodeImage(s, 0, i, u, 0, l))
                                throw (h(), new Error('THREE.BasisTextureLoader: .transcodeImage failed.'))
                              p.push({ data: s, width: t, height: n })
                            }
                            return h(), { width: s, height: a, hasAlpha: l, mipmaps: p, format: d }
                          })(s.buffers[0]),
                      l = []
                    for (let i = 0; i < a.length; ++i) l.push(a[i].data.buffer)
                    self.postMessage(
                      { type: 'transcode', id: s.id, width: t, height: e, hasAlpha: n, mipmaps: a, format: o },
                      l,
                    )
                  } catch (t) {
                    self.postMessage({ type: 'error', id: s.id, error: t.message })
                  }
                })
            }
            var a
          }
          const a = [
              {
                if: 'astcSupported',
                basisFormat: [r.UASTC_4x4],
                transcoderFormat: [s.ASTC_4x4, s.ASTC_4x4],
                engineFormat: [n.RGBA_ASTC_4x4_Format, n.RGBA_ASTC_4x4_Format],
                priorityETC1S: 1 / 0,
                priorityUASTC: 1,
                needsPowerOfTwo: !1,
              },
              {
                if: 'bptcSupported',
                basisFormat: [r.ETC1S, r.UASTC_4x4],
                transcoderFormat: [s.BC7_M5, s.BC7_M5],
                engineFormat: [n.RGBA_BPTC_Format, n.RGBA_BPTC_Format],
                priorityETC1S: 3,
                priorityUASTC: 2,
                needsPowerOfTwo: !1,
              },
              {
                if: 'dxtSupported',
                basisFormat: [r.ETC1S, r.UASTC_4x4],
                transcoderFormat: [s.BC1, s.BC3],
                engineFormat: [n.RGB_S3TC_DXT1_Format, n.RGBA_S3TC_DXT5_Format],
                priorityETC1S: 4,
                priorityUASTC: 5,
                needsPowerOfTwo: !1,
              },
              {
                if: 'etc2Supported',
                basisFormat: [r.ETC1S, r.UASTC_4x4],
                transcoderFormat: [s.ETC1, s.ETC2],
                engineFormat: [n.RGB_ETC2_Format, n.RGBA_ETC2_EAC_Format],
                priorityETC1S: 1,
                priorityUASTC: 3,
                needsPowerOfTwo: !1,
              },
              {
                if: 'etc1Supported',
                basisFormat: [r.ETC1S, r.UASTC_4x4],
                transcoderFormat: [s.ETC1, s.ETC1],
                engineFormat: [n.RGB_ETC1_Format, n.RGB_ETC1_Format],
                priorityETC1S: 2,
                priorityUASTC: 4,
                needsPowerOfTwo: !1,
              },
              {
                if: 'pvrtcSupported',
                basisFormat: [r.ETC1S, r.UASTC_4x4],
                transcoderFormat: [s.PVRTC1_4_RGB, s.PVRTC1_4_RGBA],
                engineFormat: [n.RGB_PVRTC_4BPPV1_Format, n.RGBA_PVRTC_4BPPV1_Format],
                priorityETC1S: 5,
                priorityUASTC: 6,
                needsPowerOfTwo: !0,
              },
            ],
            o = a.sort(function (t, e) {
              return t.priorityETC1S - e.priorityETC1S
            }),
            l = a.sort(function (t, e) {
              return t.priorityUASTC - e.priorityUASTC
            })
          function c(e, i, a, c) {
            let h, u
            const d = e === r.ETC1S ? o : l
            for (let n = 0; n < d.length; n++) {
              const s = d[n]
              if (t[s.if] && s.basisFormat.includes(e) && (!s.needsPowerOfTwo || (A(i) && A(a))))
                return (
                  (h = s.transcoderFormat[c ? 1 : 0]),
                  (u = s.engineFormat[c ? 1 : 0]),
                  { transcoderFormat: h, engineFormat: u }
                )
            }
            return (h = s.RGBA32), (u = n.RGBAFormat), { transcoderFormat: h, engineFormat: u }
          }
          function h(t, e) {
            if (!t) throw new Error(e)
          }
          function u(t, e) {
            return Math.ceil(e / i.getFormatBlockWidth(t))
          }
          function d(t, e) {
            return Math.ceil(e / i.getFormatBlockHeight(t))
          }
          function p(t, e, n) {
            const r = i.getBytesPerBlockOrPixel(t)
            if (i.formatIsUncompressed(t)) return e * n * r
            if (t === s.PVRTC1_4_RGB || t === s.PVRTC1_4_RGBA) {
              const t = (e + 3) & -4,
                i = (n + 3) & -4
              return (Math.max(8, t) * Math.max(8, i) * 4 + 7) / 8
            }
            return u(t, e) * d(t, n) * r
          }
          function A(t) {
            return t <= 2 || (0 == (t & (t - 1)) && 0 !== t)
          }
        })
      const eh = {
        env: {
          emscripten_notify_memory_growth: function (t) {
            th = new Uint8Array($c.exports.memory.buffer)
          },
        },
      }
      class ih {
        init() {
          return (
            Zc ||
              (Zc = fetch('data:application/wasm;base64,' + nh)
                .then((t) => t.arrayBuffer())
                .then((t) => WebAssembly.instantiate(t, eh))
                .then((t) => {
                  ;($c = t.instance), eh.env.emscripten_notify_memory_growth(0)
                })),
            Zc
          )
        }
        decode(t, e = 0) {
          const i = t.byteLength,
            n = $c.exports.malloc(i)
          th.set(t, n), (e = e || Number($c.exports.ZSTD_findDecompressedSize(n, i)))
          const s = $c.exports.malloc(e),
            r = $c.exports.ZSTD_decompress(s, e, n, i),
            a = th.slice(s, s + r)
          return $c.exports.free(n), $c.exports.free(s), a
        }
      }
      const nh =
        'AGFzbQEAAAABpQEVYAF/AX9gAn9/AGADf39/AX9gBX9/f39/AX9gAX8AYAJ/fwF/YAR/f39/AX9gA39/fwBgBn9/f39/fwF/YAd/f39/f39/AX9gAn9/AX5gAn5+AX5gAABgBX9/f39/AGAGf39/f39/AGAIf39/f39/f38AYAl/f39/f39/f38AYAABf2AIf39/f39/f38Bf2ANf39/f39/f39/f39/fwF/YAF/AX4CJwEDZW52H2Vtc2NyaXB0ZW5fbm90aWZ5X21lbW9yeV9ncm93dGgABANpaAEFAAAFAgEFCwACAQABAgIFBQcAAwABDgsBAQcAEhMHAAUBDAQEAAANBwQCAgYCBAgDAwMDBgEACQkHBgICAAYGAgQUBwYGAwIGAAMCAQgBBwUGCgoEEQAEBAEIAwgDBQgDEA8IAAcABAUBcAECAgUEAQCAAgYJAX8BQaCgwAILB2AHBm1lbW9yeQIABm1hbGxvYwAoBGZyZWUAJgxaU1REX2lzRXJyb3IAaBlaU1REX2ZpbmREZWNvbXByZXNzZWRTaXplAFQPWlNURF9kZWNvbXByZXNzAEoGX3N0YXJ0ACQJBwEAQQELASQKussBaA8AIAAgACgCBCABajYCBAsZACAAKAIAIAAoAgRBH3F0QQAgAWtBH3F2CwgAIABBiH9LC34BBH9BAyEBIAAoAgQiA0EgTQRAIAAoAggiASAAKAIQTwRAIAAQDQ8LIAAoAgwiAiABRgRAQQFBAiADQSBJGw8LIAAgASABIAJrIANBA3YiBCABIARrIAJJIgEbIgJrIgQ2AgggACADIAJBA3RrNgIEIAAgBCgAADYCAAsgAQsUAQF/IAAgARACIQIgACABEAEgAgv3AQECfyACRQRAIABCADcCACAAQQA2AhAgAEIANwIIQbh/DwsgACABNgIMIAAgAUEEajYCECACQQRPBEAgACABIAJqIgFBfGoiAzYCCCAAIAMoAAA2AgAgAUF/ai0AACIBBEAgAEEIIAEQFGs2AgQgAg8LIABBADYCBEF/DwsgACABNgIIIAAgAS0AACIDNgIAIAJBfmoiBEEBTQRAIARBAWtFBEAgACABLQACQRB0IANyIgM2AgALIAAgAS0AAUEIdCADajYCAAsgASACakF/ai0AACIBRQRAIABBADYCBEFsDwsgAEEoIAEQFCACQQN0ams2AgQgAgsWACAAIAEpAAA3AAAgACABKQAINwAICy8BAX8gAUECdEGgHWooAgAgACgCAEEgIAEgACgCBGprQR9xdnEhAiAAIAEQASACCyEAIAFCz9bTvtLHq9lCfiAAfEIfiUKHla+vmLbem55/fgsdAQF/IAAoAgggACgCDEYEfyAAKAIEQSBGBUEACwuCBAEDfyACQYDAAE8EQCAAIAEgAhBnIAAPCyAAIAJqIQMCQCAAIAFzQQNxRQRAAkAgAkEBSARAIAAhAgwBCyAAQQNxRQRAIAAhAgwBCyAAIQIDQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADTw0BIAJBA3ENAAsLAkAgA0F8cSIEQcAASQ0AIAIgBEFAaiIFSw0AA0AgAiABKAIANgIAIAIgASgCBDYCBCACIAEoAgg2AgggAiABKAIMNgIMIAIgASgCEDYCECACIAEoAhQ2AhQgAiABKAIYNgIYIAIgASgCHDYCHCACIAEoAiA2AiAgAiABKAIkNgIkIAIgASgCKDYCKCACIAEoAiw2AiwgAiABKAIwNgIwIAIgASgCNDYCNCACIAEoAjg2AjggAiABKAI8NgI8IAFBQGshASACQUBrIgIgBU0NAAsLIAIgBE8NAQNAIAIgASgCADYCACABQQRqIQEgAkEEaiICIARJDQALDAELIANBBEkEQCAAIQIMAQsgA0F8aiIEIABJBEAgACECDAELIAAhAgNAIAIgAS0AADoAACACIAEtAAE6AAEgAiABLQACOgACIAIgAS0AAzoAAyABQQRqIQEgAkEEaiICIARNDQALCyACIANJBEADQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADRw0ACwsgAAsMACAAIAEpAAA3AAALQQECfyAAKAIIIgEgACgCEEkEQEEDDwsgACAAKAIEIgJBB3E2AgQgACABIAJBA3ZrIgE2AgggACABKAAANgIAQQALDAAgACABKAIANgAAC/cCAQJ/AkAgACABRg0AAkAgASACaiAASwRAIAAgAmoiBCABSw0BCyAAIAEgAhALDwsgACABc0EDcSEDAkACQCAAIAFJBEAgAwRAIAAhAwwDCyAAQQNxRQRAIAAhAwwCCyAAIQMDQCACRQ0EIAMgAS0AADoAACABQQFqIQEgAkF/aiECIANBAWoiA0EDcQ0ACwwBCwJAIAMNACAEQQNxBEADQCACRQ0FIAAgAkF/aiICaiIDIAEgAmotAAA6AAAgA0EDcQ0ACwsgAkEDTQ0AA0AgACACQXxqIgJqIAEgAmooAgA2AgAgAkEDSw0ACwsgAkUNAgNAIAAgAkF/aiICaiABIAJqLQAAOgAAIAINAAsMAgsgAkEDTQ0AIAIhBANAIAMgASgCADYCACABQQRqIQEgA0EEaiEDIARBfGoiBEEDSw0ACyACQQNxIQILIAJFDQADQCADIAEtAAA6AAAgA0EBaiEDIAFBAWohASACQX9qIgINAAsLIAAL8wICAn8BfgJAIAJFDQAgACACaiIDQX9qIAE6AAAgACABOgAAIAJBA0kNACADQX5qIAE6AAAgACABOgABIANBfWogAToAACAAIAE6AAIgAkEHSQ0AIANBfGogAToAACAAIAE6AAMgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBfGogATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQXhqIAE2AgAgAkF0aiABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkFwaiABNgIAIAJBbGogATYCACACQWhqIAE2AgAgAkFkaiABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa0iBUIghiAFhCEFIAMgBGohAQNAIAEgBTcDGCABIAU3AxAgASAFNwMIIAEgBTcDACABQSBqIQEgAkFgaiICQR9LDQALCyAACy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAIajYCACADCy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAFajYCACADCx8AIAAgASACKAIEEAg2AgAgARAEGiAAIAJBCGo2AgQLCAAgAGdBH3MLugUBDX8jAEEQayIKJAACfyAEQQNNBEAgCkEANgIMIApBDGogAyAEEAsaIAAgASACIApBDGpBBBAVIgBBbCAAEAMbIAAgACAESxsMAQsgAEEAIAEoAgBBAXRBAmoQECENQVQgAygAACIGQQ9xIgBBCksNABogAiAAQQVqNgIAIAMgBGoiAkF8aiEMIAJBeWohDiACQXtqIRAgAEEGaiELQQQhBSAGQQR2IQRBICAAdCIAQQFyIQkgASgCACEPQQAhAiADIQYCQANAIAlBAkggAiAPS3JFBEAgAiEHAkAgCARAA0AgBEH//wNxQf//A0YEQCAHQRhqIQcgBiAQSQR/IAZBAmoiBigAACAFdgUgBUEQaiEFIARBEHYLIQQMAQsLA0AgBEEDcSIIQQNGBEAgBUECaiEFIARBAnYhBCAHQQNqIQcMAQsLIAcgCGoiByAPSw0EIAVBAmohBQNAIAIgB0kEQCANIAJBAXRqQQA7AQAgAkEBaiECDAELCyAGIA5LQQAgBiAFQQN1aiIHIAxLG0UEQCAHKAAAIAVBB3EiBXYhBAwCCyAEQQJ2IQQLIAYhBwsCfyALQX9qIAQgAEF/anEiBiAAQQF0QX9qIgggCWsiEUkNABogBCAIcSIEQQAgESAEIABIG2shBiALCyEIIA0gAkEBdGogBkF/aiIEOwEAIAlBASAGayAEIAZBAUgbayEJA0AgCSAASARAIABBAXUhACALQX9qIQsMAQsLAn8gByAOS0EAIAcgBSAIaiIFQQN1aiIGIAxLG0UEQCAFQQdxDAELIAUgDCIGIAdrQQN0awshBSACQQFqIQIgBEUhCCAGKAAAIAVBH3F2IQQMAQsLQWwgCUEBRyAFQSBKcg0BGiABIAJBf2o2AgAgBiAFQQdqQQN1aiADawwBC0FQCyEAIApBEGokACAACwkAQQFBBSAAGwsMACAAIAEoAAA2AAALqgMBCn8jAEHwAGsiCiQAIAJBAWohDiAAQQhqIQtBgIAEIAVBf2p0QRB1IQxBACECQQEhBkEBIAV0IglBf2oiDyEIA0AgAiAORkUEQAJAIAEgAkEBdCINai8BACIHQf//A0YEQCALIAhBA3RqIAI2AgQgCEF/aiEIQQEhBwwBCyAGQQAgDCAHQRB0QRB1ShshBgsgCiANaiAHOwEAIAJBAWohAgwBCwsgACAFNgIEIAAgBjYCACAJQQN2IAlBAXZqQQNqIQxBACEAQQAhBkEAIQIDQCAGIA5GBEADQAJAIAAgCUYNACAKIAsgAEEDdGoiASgCBCIGQQF0aiICIAIvAQAiAkEBajsBACABIAUgAhAUayIIOgADIAEgAiAIQf8BcXQgCWs7AQAgASAEIAZBAnQiAmooAgA6AAIgASACIANqKAIANgIEIABBAWohAAwBCwsFIAEgBkEBdGouAQAhDUEAIQcDQCAHIA1ORQRAIAsgAkEDdGogBjYCBANAIAIgDGogD3EiAiAISw0ACyAHQQFqIQcMAQsLIAZBAWohBgwBCwsgCkHwAGokAAsjAEIAIAEQCSAAhUKHla+vmLbem55/fkLj3MqV/M7y9YV/fAsQACAAQn43AwggACABNgIACyQBAX8gAARAIAEoAgQiAgRAIAEoAgggACACEQEADwsgABAmCwsfACAAIAEgAi8BABAINgIAIAEQBBogACACQQRqNgIEC0oBAX9BoCAoAgAiASAAaiIAQX9MBEBBiCBBMDYCAEF/DwsCQCAAPwBBEHRNDQAgABBmDQBBiCBBMDYCAEF/DwtBoCAgADYCACABC9cBAQh/Qbp/IQoCQCACKAIEIgggAigCACIJaiIOIAEgAGtLDQBBbCEKIAkgBCADKAIAIgtrSw0AIAAgCWoiBCACKAIIIgxrIQ0gACABQWBqIg8gCyAJQQAQKSADIAkgC2o2AgACQAJAIAwgBCAFa00EQCANIQUMAQsgDCAEIAZrSw0CIAcgDSAFayIAaiIBIAhqIAdNBEAgBCABIAgQDxoMAgsgBCABQQAgAGsQDyEBIAIgACAIaiIINgIEIAEgAGshBAsgBCAPIAUgCEEBECkLIA4hCgsgCgubAgEBfyMAQYABayINJAAgDSADNgJ8AkAgAkEDSwRAQX8hCQwBCwJAAkACQAJAIAJBAWsOAwADAgELIAZFBEBBuH8hCQwEC0FsIQkgBS0AACICIANLDQMgACAHIAJBAnQiAmooAgAgAiAIaigCABA7IAEgADYCAEEBIQkMAwsgASAJNgIAQQAhCQwCCyAKRQRAQWwhCQwCC0EAIQkgC0UgDEEZSHINAUEIIAR0QQhqIQBBACECA0AgAiAATw0CIAJBQGshAgwAAAsAC0FsIQkgDSANQfwAaiANQfgAaiAFIAYQFSICEAMNACANKAJ4IgMgBEsNACAAIA0gDSgCfCAHIAggAxAYIAEgADYCACACIQkLIA1BgAFqJAAgCQsLACAAIAEgAhALGgsQACAALwAAIAAtAAJBEHRyCy8AAn9BuH8gAUEISQ0AGkFyIAAoAAQiAEF3Sw0AGkG4fyAAQQhqIgAgACABSxsLCwkAIAAgATsAAAsDAAELigYBBX8gACAAKAIAIgVBfnE2AgBBACAAIAVBAXZqQYQgKAIAIgQgAEYbIQECQAJAIAAoAgQiAkUNACACKAIAIgNBAXENACACQQhqIgUgA0EBdkF4aiIDQQggA0EISxtnQR9zQQJ0QYAfaiIDKAIARgRAIAMgAigCDDYCAAsgAigCCCIDBEAgAyACKAIMNgIECyACKAIMIgMEQCADIAIoAgg2AgALIAIgAigCACAAKAIAQX5xajYCAEGEICEAAkACQCABRQ0AIAEgAjYCBCABKAIAIgNBAXENASADQQF2QXhqIgNBCCADQQhLG2dBH3NBAnRBgB9qIgMoAgAgAUEIakYEQCADIAEoAgw2AgALIAEoAggiAwRAIAMgASgCDDYCBAsgASgCDCIDBEAgAyABKAIINgIAQYQgKAIAIQQLIAIgAigCACABKAIAQX5xajYCACABIARGDQAgASABKAIAQQF2akEEaiEACyAAIAI2AgALIAIoAgBBAXZBeGoiAEEIIABBCEsbZ0Efc0ECdEGAH2oiASgCACEAIAEgBTYCACACIAA2AgwgAkEANgIIIABFDQEgACAFNgIADwsCQCABRQ0AIAEoAgAiAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAigCACABQQhqRgRAIAIgASgCDDYCAAsgASgCCCICBEAgAiABKAIMNgIECyABKAIMIgIEQCACIAEoAgg2AgBBhCAoAgAhBAsgACAAKAIAIAEoAgBBfnFqIgI2AgACQCABIARHBEAgASABKAIAQQF2aiAANgIEIAAoAgAhAgwBC0GEICAANgIACyACQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgIoAgAhASACIABBCGoiAjYCACAAIAE2AgwgAEEANgIIIAFFDQEgASACNgIADwsgBUEBdkF4aiIBQQggAUEISxtnQR9zQQJ0QYAfaiICKAIAIQEgAiAAQQhqIgI2AgAgACABNgIMIABBADYCCCABRQ0AIAEgAjYCAAsLDgAgAARAIABBeGoQJQsLgAIBA38CQCAAQQ9qQXhxQYQgKAIAKAIAQQF2ayICEB1Bf0YNAAJAQYQgKAIAIgAoAgAiAUEBcQ0AIAFBAXZBeGoiAUEIIAFBCEsbZ0Efc0ECdEGAH2oiASgCACAAQQhqRgRAIAEgACgCDDYCAAsgACgCCCIBBEAgASAAKAIMNgIECyAAKAIMIgFFDQAgASAAKAIINgIAC0EBIQEgACAAKAIAIAJBAXRqIgI2AgAgAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAygCACECIAMgAEEIaiIDNgIAIAAgAjYCDCAAQQA2AgggAkUNACACIAM2AgALIAELtwIBA38CQAJAIABBASAAGyICEDgiAA0AAkACQEGEICgCACIARQ0AIAAoAgAiA0EBcQ0AIAAgA0EBcjYCACADQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgAgAEEIakYEQCABIAAoAgw2AgALIAAoAggiAQRAIAEgACgCDDYCBAsgACgCDCIBBEAgASAAKAIINgIACyACECchAkEAIQFBhCAoAgAhACACDQEgACAAKAIAQX5xNgIAQQAPCyACQQ9qQXhxIgMQHSICQX9GDQIgAkEHakF4cSIAIAJHBEAgACACaxAdQX9GDQMLAkBBhCAoAgAiAUUEQEGAICAANgIADAELIAAgATYCBAtBhCAgADYCACAAIANBAXRBAXI2AgAMAQsgAEUNAQsgAEEIaiEBCyABC7kDAQJ/IAAgA2ohBQJAIANBB0wEQANAIAAgBU8NAiAAIAItAAA6AAAgAEEBaiEAIAJBAWohAgwAAAsACyAEQQFGBEACQCAAIAJrIgZBB00EQCAAIAItAAA6AAAgACACLQABOgABIAAgAi0AAjoAAiAAIAItAAM6AAMgAEEEaiACIAZBAnQiBkHAHmooAgBqIgIQFyACIAZB4B5qKAIAayECDAELIAAgAhAMCyACQQhqIQIgAEEIaiEACwJAAkACQAJAIAUgAU0EQCAAIANqIQEgBEEBRyAAIAJrQQ9Kcg0BA0AgACACEAwgAkEIaiECIABBCGoiACABSQ0ACwwFCyAAIAFLBEAgACEBDAQLIARBAUcgACACa0EPSnINASAAIQMgAiEEA0AgAyAEEAwgBEEIaiEEIANBCGoiAyABSQ0ACwwCCwNAIAAgAhAHIAJBEGohAiAAQRBqIgAgAUkNAAsMAwsgACEDIAIhBANAIAMgBBAHIARBEGohBCADQRBqIgMgAUkNAAsLIAIgASAAa2ohAgsDQCABIAVPDQEgASACLQAAOgAAIAFBAWohASACQQFqIQIMAAALAAsLQQECfyAAIAAoArjgASIDNgLE4AEgACgCvOABIQQgACABNgK84AEgACABIAJqNgK44AEgACABIAQgA2tqNgLA4AELpgEBAX8gACAAKALs4QEQFjYCyOABIABCADcD+OABIABCADcDuOABIABBwOABakIANwMAIABBqNAAaiIBQYyAgOAANgIAIABBADYCmOIBIABCADcDiOEBIABCAzcDgOEBIABBrNABakHgEikCADcCACAAQbTQAWpB6BIoAgA2AgAgACABNgIMIAAgAEGYIGo2AgggACAAQaAwajYCBCAAIABBEGo2AgALYQEBf0G4fyEDAkAgAUEDSQ0AIAIgABAhIgFBA3YiADYCCCACIAFBAXE2AgQgAiABQQF2QQNxIgM2AgACQCADQX9qIgFBAksNAAJAIAFBAWsOAgEAAgtBbA8LIAAhAwsgAwsMACAAIAEgAkEAEC4LiAQCA38CfiADEBYhBCAAQQBBKBAQIQAgBCACSwRAIAQPCyABRQRAQX8PCwJAAkAgA0EBRg0AIAEoAAAiBkGo6r5pRg0AQXYhAyAGQXBxQdDUtMIBRw0BQQghAyACQQhJDQEgAEEAQSgQECEAIAEoAAQhASAAQQE2AhQgACABrTcDAEEADwsgASACIAMQLyIDIAJLDQAgACADNgIYQXIhAyABIARqIgVBf2otAAAiAkEIcQ0AIAJBIHEiBkUEQEFwIQMgBS0AACIFQacBSw0BIAVBB3GtQgEgBUEDdkEKaq2GIgdCA4h+IAd8IQggBEEBaiEECyACQQZ2IQMgAkECdiEFAkAgAkEDcUF/aiICQQJLBEBBACECDAELAkACQAJAIAJBAWsOAgECAAsgASAEai0AACECIARBAWohBAwCCyABIARqLwAAIQIgBEECaiEEDAELIAEgBGooAAAhAiAEQQRqIQQLIAVBAXEhBQJ+AkACQAJAIANBf2oiA0ECTQRAIANBAWsOAgIDAQtCfyAGRQ0DGiABIARqMQAADAMLIAEgBGovAACtQoACfAwCCyABIARqKAAArQwBCyABIARqKQAACyEHIAAgBTYCICAAIAI2AhwgACAHNwMAQQAhAyAAQQA2AhQgACAHIAggBhsiBzcDCCAAIAdCgIAIIAdCgIAIVBs+AhALIAMLWwEBf0G4fyEDIAIQFiICIAFNBH8gACACakF/ai0AACIAQQNxQQJ0QaAeaigCACACaiAAQQZ2IgFBAnRBsB5qKAIAaiAAQSBxIgBFaiABRSAAQQV2cWoFQbh/CwsdACAAKAKQ4gEQWiAAQQA2AqDiASAAQgA3A5DiAQu1AwEFfyMAQZACayIKJABBuH8hBgJAIAVFDQAgBCwAACIIQf8BcSEHAkAgCEF/TARAIAdBgn9qQQF2IgggBU8NAkFsIQYgB0GBf2oiBUGAAk8NAiAEQQFqIQdBACEGA0AgBiAFTwRAIAUhBiAIIQcMAwUgACAGaiAHIAZBAXZqIgQtAABBBHY6AAAgACAGQQFyaiAELQAAQQ9xOgAAIAZBAmohBgwBCwAACwALIAcgBU8NASAAIARBAWogByAKEFMiBhADDQELIAYhBEEAIQYgAUEAQTQQECEJQQAhBQNAIAQgBkcEQCAAIAZqIggtAAAiAUELSwRAQWwhBgwDBSAJIAFBAnRqIgEgASgCAEEBajYCACAGQQFqIQZBASAILQAAdEEBdSAFaiEFDAILAAsLQWwhBiAFRQ0AIAUQFEEBaiIBQQxLDQAgAyABNgIAQQFBASABdCAFayIDEBQiAXQgA0cNACAAIARqIAFBAWoiADoAACAJIABBAnRqIgAgACgCAEEBajYCACAJKAIEIgBBAkkgAEEBcXINACACIARBAWo2AgAgB0EBaiEGCyAKQZACaiQAIAYLxhEBDH8jAEHwAGsiBSQAQWwhCwJAIANBCkkNACACLwAAIQogAi8AAiEJIAIvAAQhByAFQQhqIAQQDgJAIAMgByAJIApqakEGaiIMSQ0AIAUtAAohCCAFQdgAaiACQQZqIgIgChAGIgsQAw0BIAVBQGsgAiAKaiICIAkQBiILEAMNASAFQShqIAIgCWoiAiAHEAYiCxADDQEgBUEQaiACIAdqIAMgDGsQBiILEAMNASAAIAFqIg9BfWohECAEQQRqIQZBASELIAAgAUEDakECdiIDaiIMIANqIgIgA2oiDiEDIAIhBCAMIQcDQCALIAMgEElxBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgCS0AAyELIAcgBiAFQUBrIAgQAkECdGoiCS8BADsAACAFQUBrIAktAAIQASAJLQADIQogBCAGIAVBKGogCBACQQJ0aiIJLwEAOwAAIAVBKGogCS0AAhABIAktAAMhCSADIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgDS0AAyENIAAgC2oiCyAGIAVB2ABqIAgQAkECdGoiAC8BADsAACAFQdgAaiAALQACEAEgAC0AAyEAIAcgCmoiCiAGIAVBQGsgCBACQQJ0aiIHLwEAOwAAIAVBQGsgBy0AAhABIActAAMhByAEIAlqIgkgBiAFQShqIAgQAkECdGoiBC8BADsAACAFQShqIAQtAAIQASAELQADIQQgAyANaiIDIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgACALaiEAIAcgCmohByAEIAlqIQQgAyANLQADaiEDIAVB2ABqEA0gBUFAaxANciAFQShqEA1yIAVBEGoQDXJFIQsMAQsLIAQgDksgByACS3INAEFsIQsgACAMSw0BIAxBfWohCQNAQQAgACAJSSAFQdgAahAEGwRAIAAgBiAFQdgAaiAIEAJBAnRqIgovAQA7AAAgBUHYAGogCi0AAhABIAAgCi0AA2oiACAGIAVB2ABqIAgQAkECdGoiCi8BADsAACAFQdgAaiAKLQACEAEgACAKLQADaiEADAEFIAxBfmohCgNAIAVB2ABqEAQgACAKS3JFBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgACAJLQADaiEADAELCwNAIAAgCk0EQCAAIAYgBUHYAGogCBACQQJ0aiIJLwEAOwAAIAVB2ABqIAktAAIQASAAIAktAANqIQAMAQsLAkAgACAMTw0AIAAgBiAFQdgAaiAIEAIiAEECdGoiDC0AADoAACAMLQADQQFGBEAgBUHYAGogDC0AAhABDAELIAUoAlxBH0sNACAFQdgAaiAGIABBAnRqLQACEAEgBSgCXEEhSQ0AIAVBIDYCXAsgAkF9aiEMA0BBACAHIAxJIAVBQGsQBBsEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiIAIAYgBUFAayAIEAJBAnRqIgcvAQA7AAAgBUFAayAHLQACEAEgACAHLQADaiEHDAEFIAJBfmohDANAIAVBQGsQBCAHIAxLckUEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwNAIAcgDE0EQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwJAIAcgAk8NACAHIAYgBUFAayAIEAIiAEECdGoiAi0AADoAACACLQADQQFGBEAgBUFAayACLQACEAEMAQsgBSgCREEfSw0AIAVBQGsgBiAAQQJ0ai0AAhABIAUoAkRBIUkNACAFQSA2AkQLIA5BfWohAgNAQQAgBCACSSAFQShqEAQbBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2oiACAGIAVBKGogCBACQQJ0aiIELwEAOwAAIAVBKGogBC0AAhABIAAgBC0AA2ohBAwBBSAOQX5qIQIDQCAFQShqEAQgBCACS3JFBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsDQCAEIAJNBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsCQCAEIA5PDQAgBCAGIAVBKGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBKGogAi0AAhABDAELIAUoAixBH0sNACAFQShqIAYgAEECdGotAAIQASAFKAIsQSFJDQAgBUEgNgIsCwNAQQAgAyAQSSAFQRBqEAQbBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2oiACAGIAVBEGogCBACQQJ0aiICLwEAOwAAIAVBEGogAi0AAhABIAAgAi0AA2ohAwwBBSAPQX5qIQIDQCAFQRBqEAQgAyACS3JFBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsDQCADIAJNBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsCQCADIA9PDQAgAyAGIAVBEGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBEGogAi0AAhABDAELIAUoAhRBH0sNACAFQRBqIAYgAEECdGotAAIQASAFKAIUQSFJDQAgBUEgNgIUCyABQWwgBUHYAGoQCiAFQUBrEApxIAVBKGoQCnEgBUEQahAKcRshCwwJCwAACwALAAALAAsAAAsACwAACwALQWwhCwsgBUHwAGokACALC7UEAQ5/IwBBEGsiBiQAIAZBBGogABAOQVQhBQJAIARB3AtJDQAgBi0ABCEHIANB8ARqQQBB7AAQECEIIAdBDEsNACADQdwJaiIJIAggBkEIaiAGQQxqIAEgAhAxIhAQA0UEQCAGKAIMIgQgB0sNASADQdwFaiEPIANBpAVqIREgAEEEaiESIANBqAVqIQEgBCEFA0AgBSICQX9qIQUgCCACQQJ0aigCAEUNAAsgAkEBaiEOQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgASALaiAKNgIAIAVBAWohBSAKIAxqIQoMAQsLIAEgCjYCAEEAIQUgBigCCCELA0AgBSALRkUEQCABIAUgCWotAAAiDEECdGoiDSANKAIAIg1BAWo2AgAgDyANQQF0aiINIAw6AAEgDSAFOgAAIAVBAWohBQwBCwtBACEBIANBADYCqAUgBEF/cyAHaiEJQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgAyALaiABNgIAIAwgBSAJanQgAWohASAFQQFqIQUMAQsLIAcgBEEBaiIBIAJrIgRrQQFqIQgDQEEBIQUgBCAIT0UEQANAIAUgDk9FBEAgBUECdCIJIAMgBEE0bGpqIAMgCWooAgAgBHY2AgAgBUEBaiEFDAELCyAEQQFqIQQMAQsLIBIgByAPIAogESADIAIgARBkIAZBAToABSAGIAc6AAYgACAGKAIENgIACyAQIQULIAZBEGokACAFC8ENAQt/IwBB8ABrIgUkAEFsIQkCQCADQQpJDQAgAi8AACEKIAIvAAIhDCACLwAEIQYgBUEIaiAEEA4CQCADIAYgCiAMampBBmoiDUkNACAFLQAKIQcgBUHYAGogAkEGaiICIAoQBiIJEAMNASAFQUBrIAIgCmoiAiAMEAYiCRADDQEgBUEoaiACIAxqIgIgBhAGIgkQAw0BIAVBEGogAiAGaiADIA1rEAYiCRADDQEgACABaiIOQX1qIQ8gBEEEaiEGQQEhCSAAIAFBA2pBAnYiAmoiCiACaiIMIAJqIg0hAyAMIQQgCiECA0AgCSADIA9JcQRAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAACAGIAVBQGsgBxACQQF0aiIILQAAIQsgBUFAayAILQABEAEgAiALOgAAIAYgBUEoaiAHEAJBAXRqIggtAAAhCyAFQShqIAgtAAEQASAEIAs6AAAgBiAFQRBqIAcQAkEBdGoiCC0AACELIAVBEGogCC0AARABIAMgCzoAACAGIAVB2ABqIAcQAkEBdGoiCC0AACELIAVB2ABqIAgtAAEQASAAIAs6AAEgBiAFQUBrIAcQAkEBdGoiCC0AACELIAVBQGsgCC0AARABIAIgCzoAASAGIAVBKGogBxACQQF0aiIILQAAIQsgBUEoaiAILQABEAEgBCALOgABIAYgBUEQaiAHEAJBAXRqIggtAAAhCyAFQRBqIAgtAAEQASADIAs6AAEgA0ECaiEDIARBAmohBCACQQJqIQIgAEECaiEAIAkgBUHYAGoQDUVxIAVBQGsQDUVxIAVBKGoQDUVxIAVBEGoQDUVxIQkMAQsLIAQgDUsgAiAMS3INAEFsIQkgACAKSw0BIApBfWohCQNAIAVB2ABqEAQgACAJT3JFBEAgBiAFQdgAaiAHEAJBAXRqIggtAAAhCyAFQdgAaiAILQABEAEgACALOgAAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAASAAQQJqIQAMAQsLA0AgBUHYAGoQBCAAIApPckUEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCwNAIAAgCkkEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCyAMQX1qIQADQCAFQUBrEAQgAiAAT3JFBEAgBiAFQUBrIAcQAkEBdGoiCi0AACEJIAVBQGsgCi0AARABIAIgCToAACAGIAVBQGsgBxACQQF0aiIKLQAAIQkgBUFAayAKLQABEAEgAiAJOgABIAJBAmohAgwBCwsDQCAFQUBrEAQgAiAMT3JFBEAgBiAFQUBrIAcQAkEBdGoiAC0AACEKIAVBQGsgAC0AARABIAIgCjoAACACQQFqIQIMAQsLA0AgAiAMSQRAIAYgBUFAayAHEAJBAXRqIgAtAAAhCiAFQUBrIAAtAAEQASACIAo6AAAgAkEBaiECDAELCyANQX1qIQADQCAFQShqEAQgBCAAT3JFBEAgBiAFQShqIAcQAkEBdGoiAi0AACEKIAVBKGogAi0AARABIAQgCjoAACAGIAVBKGogBxACQQF0aiICLQAAIQogBUEoaiACLQABEAEgBCAKOgABIARBAmohBAwBCwsDQCAFQShqEAQgBCANT3JFBEAgBiAFQShqIAcQAkEBdGoiAC0AACECIAVBKGogAC0AARABIAQgAjoAACAEQQFqIQQMAQsLA0AgBCANSQRAIAYgBUEoaiAHEAJBAXRqIgAtAAAhAiAFQShqIAAtAAEQASAEIAI6AAAgBEEBaiEEDAELCwNAIAVBEGoQBCADIA9PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIAYgBUEQaiAHEAJBAXRqIgAtAAAhAiAFQRBqIAAtAAEQASADIAI6AAEgA0ECaiEDDAELCwNAIAVBEGoQBCADIA5PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIANBAWohAwwBCwsDQCADIA5JBEAgBiAFQRBqIAcQAkEBdGoiAC0AACECIAVBEGogAC0AARABIAMgAjoAACADQQFqIQMMAQsLIAFBbCAFQdgAahAKIAVBQGsQCnEgBUEoahAKcSAFQRBqEApxGyEJDAELQWwhCQsgBUHwAGokACAJC8oCAQR/IwBBIGsiBSQAIAUgBBAOIAUtAAIhByAFQQhqIAIgAxAGIgIQA0UEQCAEQQRqIQIgACABaiIDQX1qIQQDQCAFQQhqEAQgACAET3JFBEAgAiAFQQhqIAcQAkEBdGoiBi0AACEIIAVBCGogBi0AARABIAAgCDoAACACIAVBCGogBxACQQF0aiIGLQAAIQggBUEIaiAGLQABEAEgACAIOgABIABBAmohAAwBCwsDQCAFQQhqEAQgACADT3JFBEAgAiAFQQhqIAcQAkEBdGoiBC0AACEGIAVBCGogBC0AARABIAAgBjoAACAAQQFqIQAMAQsLA0AgACADT0UEQCACIAVBCGogBxACQQF0aiIELQAAIQYgBUEIaiAELQABEAEgACAGOgAAIABBAWohAAwBCwsgAUFsIAVBCGoQChshAgsgBUEgaiQAIAILtgMBCX8jAEEQayIGJAAgBkEANgIMIAZBADYCCEFUIQQCQAJAIANBQGsiDCADIAZBCGogBkEMaiABIAIQMSICEAMNACAGQQRqIAAQDiAGKAIMIgcgBi0ABEEBaksNASAAQQRqIQogBkEAOgAFIAYgBzoABiAAIAYoAgQ2AgAgB0EBaiEJQQEhBANAIAQgCUkEQCADIARBAnRqIgEoAgAhACABIAU2AgAgACAEQX9qdCAFaiEFIARBAWohBAwBCwsgB0EBaiEHQQAhBSAGKAIIIQkDQCAFIAlGDQEgAyAFIAxqLQAAIgRBAnRqIgBBASAEdEEBdSILIAAoAgAiAWoiADYCACAHIARrIQhBACEEAkAgC0EDTQRAA0AgBCALRg0CIAogASAEakEBdGoiACAIOgABIAAgBToAACAEQQFqIQQMAAALAAsDQCABIABPDQEgCiABQQF0aiIEIAg6AAEgBCAFOgAAIAQgCDoAAyAEIAU6AAIgBCAIOgAFIAQgBToABCAEIAg6AAcgBCAFOgAGIAFBBGohAQwAAAsACyAFQQFqIQUMAAALAAsgAiEECyAGQRBqJAAgBAutAQECfwJAQYQgKAIAIABHIAAoAgBBAXYiAyABa0F4aiICQXhxQQhHcgR/IAIFIAMQJ0UNASACQQhqC0EQSQ0AIAAgACgCACICQQFxIAAgAWpBD2pBeHEiASAAa0EBdHI2AgAgASAANgIEIAEgASgCAEEBcSAAIAJBAXZqIAFrIgJBAXRyNgIAQYQgIAEgAkH/////B3FqQQRqQYQgKAIAIABGGyABNgIAIAEQJQsLygIBBX8CQAJAAkAgAEEIIABBCEsbZ0EfcyAAaUEBR2oiAUEESSAAIAF2cg0AIAFBAnRB/B5qKAIAIgJFDQADQCACQXhqIgMoAgBBAXZBeGoiBSAATwRAIAIgBUEIIAVBCEsbZ0Efc0ECdEGAH2oiASgCAEYEQCABIAIoAgQ2AgALDAMLIARBHksNASAEQQFqIQQgAigCBCICDQALC0EAIQMgAUEgTw0BA0AgAUECdEGAH2ooAgAiAkUEQCABQR5LIQIgAUEBaiEBIAJFDQEMAwsLIAIgAkF4aiIDKAIAQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgBGBEAgASACKAIENgIACwsgAigCACIBBEAgASACKAIENgIECyACKAIEIgEEQCABIAIoAgA2AgALIAMgAygCAEEBcjYCACADIAAQNwsgAwvhCwINfwV+IwBB8ABrIgckACAHIAAoAvDhASIINgJcIAEgAmohDSAIIAAoAoDiAWohDwJAAkAgBUUEQCABIQQMAQsgACgCxOABIRAgACgCwOABIREgACgCvOABIQ4gAEEBNgKM4QFBACEIA0AgCEEDRwRAIAcgCEECdCICaiAAIAJqQazQAWooAgA2AkQgCEEBaiEIDAELC0FsIQwgB0EYaiADIAQQBhADDQEgB0EsaiAHQRhqIAAoAgAQEyAHQTRqIAdBGGogACgCCBATIAdBPGogB0EYaiAAKAIEEBMgDUFgaiESIAEhBEEAIQwDQCAHKAIwIAcoAixBA3RqKQIAIhRCEIinQf8BcSEIIAcoAkAgBygCPEEDdGopAgAiFUIQiKdB/wFxIQsgBygCOCAHKAI0QQN0aikCACIWQiCIpyEJIBVCIIghFyAUQiCIpyECAkAgFkIQiKdB/wFxIgNBAk8EQAJAIAZFIANBGUlyRQRAIAkgB0EYaiADQSAgBygCHGsiCiAKIANLGyIKEAUgAyAKayIDdGohCSAHQRhqEAQaIANFDQEgB0EYaiADEAUgCWohCQwBCyAHQRhqIAMQBSAJaiEJIAdBGGoQBBoLIAcpAkQhGCAHIAk2AkQgByAYNwNIDAELAkAgA0UEQCACBEAgBygCRCEJDAMLIAcoAkghCQwBCwJAAkAgB0EYakEBEAUgCSACRWpqIgNBA0YEQCAHKAJEQX9qIgMgA0VqIQkMAQsgA0ECdCAHaigCRCIJIAlFaiEJIANBAUYNAQsgByAHKAJINgJMCwsgByAHKAJENgJIIAcgCTYCRAsgF6chAyALBEAgB0EYaiALEAUgA2ohAwsgCCALakEUTwRAIAdBGGoQBBoLIAgEQCAHQRhqIAgQBSACaiECCyAHQRhqEAQaIAcgB0EYaiAUQhiIp0H/AXEQCCAUp0H//wNxajYCLCAHIAdBGGogFUIYiKdB/wFxEAggFadB//8DcWo2AjwgB0EYahAEGiAHIAdBGGogFkIYiKdB/wFxEAggFqdB//8DcWo2AjQgByACNgJgIAcoAlwhCiAHIAk2AmggByADNgJkAkACQAJAIAQgAiADaiILaiASSw0AIAIgCmoiEyAPSw0AIA0gBGsgC0Egak8NAQsgByAHKQNoNwMQIAcgBykDYDcDCCAEIA0gB0EIaiAHQdwAaiAPIA4gESAQEB4hCwwBCyACIARqIQggBCAKEAcgAkERTwRAIARBEGohAgNAIAIgCkEQaiIKEAcgAkEQaiICIAhJDQALCyAIIAlrIQIgByATNgJcIAkgCCAOa0sEQCAJIAggEWtLBEBBbCELDAILIBAgAiAOayICaiIKIANqIBBNBEAgCCAKIAMQDxoMAgsgCCAKQQAgAmsQDyEIIAcgAiADaiIDNgJkIAggAmshCCAOIQILIAlBEE8EQCADIAhqIQMDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALDAELAkAgCUEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgCUECdCIDQcAeaigCAGoiAhAXIAIgA0HgHmooAgBrIQIgBygCZCEDDAELIAggAhAMCyADQQlJDQAgAyAIaiEDIAhBCGoiCCACQQhqIgJrQQ9MBEADQCAIIAIQDCACQQhqIQIgCEEIaiIIIANJDQAMAgALAAsDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALCyAHQRhqEAQaIAsgDCALEAMiAhshDCAEIAQgC2ogAhshBCAFQX9qIgUNAAsgDBADDQFBbCEMIAdBGGoQBEECSQ0BQQAhCANAIAhBA0cEQCAAIAhBAnQiAmpBrNABaiACIAdqKAJENgIAIAhBAWohCAwBCwsgBygCXCEIC0G6fyEMIA8gCGsiACANIARrSw0AIAQEfyAEIAggABALIABqBUEACyABayEMCyAHQfAAaiQAIAwLkRcCFn8FfiMAQdABayIHJAAgByAAKALw4QEiCDYCvAEgASACaiESIAggACgCgOIBaiETAkACQCAFRQRAIAEhAwwBCyAAKALE4AEhESAAKALA4AEhFSAAKAK84AEhDyAAQQE2AozhAUEAIQgDQCAIQQNHBEAgByAIQQJ0IgJqIAAgAmpBrNABaigCADYCVCAIQQFqIQgMAQsLIAcgETYCZCAHIA82AmAgByABIA9rNgJoQWwhECAHQShqIAMgBBAGEAMNASAFQQQgBUEESBshFyAHQTxqIAdBKGogACgCABATIAdBxABqIAdBKGogACgCCBATIAdBzABqIAdBKGogACgCBBATQQAhBCAHQeAAaiEMIAdB5ABqIQoDQCAHQShqEARBAksgBCAXTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEJIAcoAkggBygCREEDdGopAgAiH0IgiKchCCAeQiCIISAgHUIgiKchAgJAIB9CEIinQf8BcSIDQQJPBEACQCAGRSADQRlJckUEQCAIIAdBKGogA0EgIAcoAixrIg0gDSADSxsiDRAFIAMgDWsiA3RqIQggB0EoahAEGiADRQ0BIAdBKGogAxAFIAhqIQgMAQsgB0EoaiADEAUgCGohCCAHQShqEAQaCyAHKQJUISEgByAINgJUIAcgITcDWAwBCwJAIANFBEAgAgRAIAcoAlQhCAwDCyAHKAJYIQgMAQsCQAJAIAdBKGpBARAFIAggAkVqaiIDQQNGBEAgBygCVEF/aiIDIANFaiEIDAELIANBAnQgB2ooAlQiCCAIRWohCCADQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAg2AlQLICCnIQMgCQRAIAdBKGogCRAFIANqIQMLIAkgC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgAmohAgsgB0EoahAEGiAHIAcoAmggAmoiCSADajYCaCAKIAwgCCAJSxsoAgAhDSAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogB0EoaiAfQhiIp0H/AXEQCCEOIAdB8ABqIARBBHRqIgsgCSANaiAIazYCDCALIAg2AgggCyADNgIEIAsgAjYCACAHIA4gH6dB//8DcWo2AkQgBEEBaiEEDAELCyAEIBdIDQEgEkFgaiEYIAdB4ABqIRogB0HkAGohGyABIQMDQCAHQShqEARBAksgBCAFTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEIIAcoAkggBygCREEDdGopAgAiH0IgiKchCSAeQiCIISAgHUIgiKchDAJAIB9CEIinQf8BcSICQQJPBEACQCAGRSACQRlJckUEQCAJIAdBKGogAkEgIAcoAixrIgogCiACSxsiChAFIAIgCmsiAnRqIQkgB0EoahAEGiACRQ0BIAdBKGogAhAFIAlqIQkMAQsgB0EoaiACEAUgCWohCSAHQShqEAQaCyAHKQJUISEgByAJNgJUIAcgITcDWAwBCwJAIAJFBEAgDARAIAcoAlQhCQwDCyAHKAJYIQkMAQsCQAJAIAdBKGpBARAFIAkgDEVqaiICQQNGBEAgBygCVEF/aiICIAJFaiEJDAELIAJBAnQgB2ooAlQiCSAJRWohCSACQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAk2AlQLICCnIRQgCARAIAdBKGogCBAFIBRqIRQLIAggC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgDGohDAsgB0EoahAEGiAHIAcoAmggDGoiGSAUajYCaCAbIBogCSAZSxsoAgAhHCAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogByAHQShqIB9CGIinQf8BcRAIIB+nQf//A3FqNgJEIAcgB0HwAGogBEEDcUEEdGoiDSkDCCIdNwPIASAHIA0pAwAiHjcDwAECQAJAAkAgBygCvAEiDiAepyICaiIWIBNLDQAgAyAHKALEASIKIAJqIgtqIBhLDQAgEiADayALQSBqTw0BCyAHIAcpA8gBNwMQIAcgBykDwAE3AwggAyASIAdBCGogB0G8AWogEyAPIBUgERAeIQsMAQsgAiADaiEIIAMgDhAHIAJBEU8EQCADQRBqIQIDQCACIA5BEGoiDhAHIAJBEGoiAiAISQ0ACwsgCCAdpyIOayECIAcgFjYCvAEgDiAIIA9rSwRAIA4gCCAVa0sEQEFsIQsMAgsgESACIA9rIgJqIhYgCmogEU0EQCAIIBYgChAPGgwCCyAIIBZBACACaxAPIQggByACIApqIgo2AsQBIAggAmshCCAPIQILIA5BEE8EQCAIIApqIQoDQCAIIAIQByACQRBqIQIgCEEQaiIIIApJDQALDAELAkAgDkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgDkECdCIKQcAeaigCAGoiAhAXIAIgCkHgHmooAgBrIQIgBygCxAEhCgwBCyAIIAIQDAsgCkEJSQ0AIAggCmohCiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAKSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAKSQ0ACwsgCxADBEAgCyEQDAQFIA0gDDYCACANIBkgHGogCWs2AgwgDSAJNgIIIA0gFDYCBCAEQQFqIQQgAyALaiEDDAILAAsLIAQgBUgNASAEIBdrIQtBACEEA0AgCyAFSARAIAcgB0HwAGogC0EDcUEEdGoiAikDCCIdNwPIASAHIAIpAwAiHjcDwAECQAJAAkAgBygCvAEiDCAepyICaiIKIBNLDQAgAyAHKALEASIJIAJqIhBqIBhLDQAgEiADayAQQSBqTw0BCyAHIAcpA8gBNwMgIAcgBykDwAE3AxggAyASIAdBGGogB0G8AWogEyAPIBUgERAeIRAMAQsgAiADaiEIIAMgDBAHIAJBEU8EQCADQRBqIQIDQCACIAxBEGoiDBAHIAJBEGoiAiAISQ0ACwsgCCAdpyIGayECIAcgCjYCvAEgBiAIIA9rSwRAIAYgCCAVa0sEQEFsIRAMAgsgESACIA9rIgJqIgwgCWogEU0EQCAIIAwgCRAPGgwCCyAIIAxBACACaxAPIQggByACIAlqIgk2AsQBIAggAmshCCAPIQILIAZBEE8EQCAIIAlqIQYDQCAIIAIQByACQRBqIQIgCEEQaiIIIAZJDQALDAELAkAgBkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgBkECdCIGQcAeaigCAGoiAhAXIAIgBkHgHmooAgBrIQIgBygCxAEhCQwBCyAIIAIQDAsgCUEJSQ0AIAggCWohBiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAGSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAGSQ0ACwsgEBADDQMgC0EBaiELIAMgEGohAwwBCwsDQCAEQQNHBEAgACAEQQJ0IgJqQazQAWogAiAHaigCVDYCACAEQQFqIQQMAQsLIAcoArwBIQgLQbp/IRAgEyAIayIAIBIgA2tLDQAgAwR/IAMgCCAAEAsgAGoFQQALIAFrIRALIAdB0AFqJAAgEAslACAAQgA3AgAgAEEAOwEIIABBADoACyAAIAE2AgwgACACOgAKC7QFAQN/IwBBMGsiBCQAIABB/wFqIgVBfWohBgJAIAMvAQIEQCAEQRhqIAEgAhAGIgIQAw0BIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahASOgAAIAMgBEEIaiAEQRhqEBI6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0FIAEgBEEQaiAEQRhqEBI6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBSABIARBCGogBEEYahASOgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEjoAACABIAJqIABrIQIMAwsgAyAEQRBqIARBGGoQEjoAAiADIARBCGogBEEYahASOgADIANBBGohAwwAAAsACyAEQRhqIAEgAhAGIgIQAw0AIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahAROgAAIAMgBEEIaiAEQRhqEBE6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0EIAEgBEEQaiAEQRhqEBE6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBCABIARBCGogBEEYahAROgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEToAACABIAJqIABrIQIMAgsgAyAEQRBqIARBGGoQEToAAiADIARBCGogBEEYahAROgADIANBBGohAwwAAAsACyAEQTBqJAAgAgtpAQF/An8CQAJAIAJBB00NACABKAAAQbfIwuF+Rw0AIAAgASgABDYCmOIBQWIgAEEQaiABIAIQPiIDEAMNAhogAEKBgICAEDcDiOEBIAAgASADaiACIANrECoMAQsgACABIAIQKgtBAAsLrQMBBn8jAEGAAWsiAyQAQWIhCAJAIAJBCUkNACAAQZjQAGogAUEIaiIEIAJBeGogAEGY0AAQMyIFEAMiBg0AIANBHzYCfCADIANB/ABqIANB+ABqIAQgBCAFaiAGGyIEIAEgAmoiAiAEaxAVIgUQAw0AIAMoAnwiBkEfSw0AIAMoAngiB0EJTw0AIABBiCBqIAMgBkGAC0GADCAHEBggA0E0NgJ8IAMgA0H8AGogA0H4AGogBCAFaiIEIAIgBGsQFSIFEAMNACADKAJ8IgZBNEsNACADKAJ4IgdBCk8NACAAQZAwaiADIAZBgA1B4A4gBxAYIANBIzYCfCADIANB/ABqIANB+ABqIAQgBWoiBCACIARrEBUiBRADDQAgAygCfCIGQSNLDQAgAygCeCIHQQpPDQAgACADIAZBwBBB0BEgBxAYIAQgBWoiBEEMaiIFIAJLDQAgAiAFayEFQQAhAgNAIAJBA0cEQCAEKAAAIgZBf2ogBU8NAiAAIAJBAnRqQZzQAWogBjYCACACQQFqIQIgBEEEaiEEDAELCyAEIAFrIQgLIANBgAFqJAAgCAtGAQN/IABBCGohAyAAKAIEIQJBACEAA0AgACACdkUEQCABIAMgAEEDdGotAAJBFktqIQEgAEEBaiEADAELCyABQQggAmt0C4YDAQV/Qbh/IQcCQCADRQ0AIAItAAAiBEUEQCABQQA2AgBBAUG4fyADQQFGGw8LAn8gAkEBaiIFIARBGHRBGHUiBkF/Sg0AGiAGQX9GBEAgA0EDSA0CIAUvAABBgP4BaiEEIAJBA2oMAQsgA0ECSA0BIAItAAEgBEEIdHJBgIB+aiEEIAJBAmoLIQUgASAENgIAIAVBAWoiASACIANqIgNLDQBBbCEHIABBEGogACAFLQAAIgVBBnZBI0EJIAEgAyABa0HAEEHQEUHwEiAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBmCBqIABBCGogBUEEdkEDcUEfQQggASABIAZqIAgbIgEgAyABa0GAC0GADEGAFyAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBoDBqIABBBGogBUECdkEDcUE0QQkgASABIAZqIAgbIgEgAyABa0GADUHgDkGQGSAAKAKM4QEgACgCnOIBIAQQHyIAEAMNACAAIAFqIAJrIQcLIAcLrQMBCn8jAEGABGsiCCQAAn9BUiACQf8BSw0AGkFUIANBDEsNABogAkEBaiELIABBBGohCUGAgAQgA0F/anRBEHUhCkEAIQJBASEEQQEgA3QiB0F/aiIMIQUDQCACIAtGRQRAAkAgASACQQF0Ig1qLwEAIgZB//8DRgRAIAkgBUECdGogAjoAAiAFQX9qIQVBASEGDAELIARBACAKIAZBEHRBEHVKGyEECyAIIA1qIAY7AQAgAkEBaiECDAELCyAAIAQ7AQIgACADOwEAIAdBA3YgB0EBdmpBA2ohBkEAIQRBACECA0AgBCALRkUEQCABIARBAXRqLgEAIQpBACEAA0AgACAKTkUEQCAJIAJBAnRqIAQ6AAIDQCACIAZqIAxxIgIgBUsNAAsgAEEBaiEADAELCyAEQQFqIQQMAQsLQX8gAg0AGkEAIQIDfyACIAdGBH9BAAUgCCAJIAJBAnRqIgAtAAJBAXRqIgEgAS8BACIBQQFqOwEAIAAgAyABEBRrIgU6AAMgACABIAVB/wFxdCAHazsBACACQQFqIQIMAQsLCyEFIAhBgARqJAAgBQvjBgEIf0FsIQcCQCACQQNJDQACQAJAAkACQCABLQAAIgNBA3EiCUEBaw4DAwEAAgsgACgCiOEBDQBBYg8LIAJBBUkNAkEDIQYgASgAACEFAn8CQAJAIANBAnZBA3EiCEF+aiIEQQFNBEAgBEEBaw0BDAILIAVBDnZB/wdxIQQgBUEEdkH/B3EhAyAIRQwCCyAFQRJ2IQRBBCEGIAVBBHZB//8AcSEDQQAMAQsgBUEEdkH//w9xIgNBgIAISw0DIAEtAARBCnQgBUEWdnIhBEEFIQZBAAshBSAEIAZqIgogAksNAgJAIANBgQZJDQAgACgCnOIBRQ0AQQAhAgNAIAJBg4ABSw0BIAJBQGshAgwAAAsACwJ/IAlBA0YEQCABIAZqIQEgAEHw4gFqIQIgACgCDCEGIAUEQCACIAMgASAEIAYQXwwCCyACIAMgASAEIAYQXQwBCyAAQbjQAWohAiABIAZqIQEgAEHw4gFqIQYgAEGo0ABqIQggBQRAIAggBiADIAEgBCACEF4MAQsgCCAGIAMgASAEIAIQXAsQAw0CIAAgAzYCgOIBIABBATYCiOEBIAAgAEHw4gFqNgLw4QEgCUECRgRAIAAgAEGo0ABqNgIMCyAAIANqIgBBiOMBakIANwAAIABBgOMBakIANwAAIABB+OIBakIANwAAIABB8OIBakIANwAAIAoPCwJ/AkACQAJAIANBAnZBA3FBf2oiBEECSw0AIARBAWsOAgACAQtBASEEIANBA3YMAgtBAiEEIAEvAABBBHYMAQtBAyEEIAEQIUEEdgsiAyAEaiIFQSBqIAJLBEAgBSACSw0CIABB8OIBaiABIARqIAMQCyEBIAAgAzYCgOIBIAAgATYC8OEBIAEgA2oiAEIANwAYIABCADcAECAAQgA3AAggAEIANwAAIAUPCyAAIAM2AoDiASAAIAEgBGo2AvDhASAFDwsCfwJAAkACQCADQQJ2QQNxQX9qIgRBAksNACAEQQFrDgIAAgELQQEhByADQQN2DAILQQIhByABLwAAQQR2DAELIAJBBEkgARAhIgJBj4CAAUtyDQFBAyEHIAJBBHYLIQIgAEHw4gFqIAEgB2otAAAgAkEgahAQIQEgACACNgKA4gEgACABNgLw4QEgB0EBaiEHCyAHC0sAIABC+erQ0OfJoeThADcDICAAQgA3AxggAELP1tO+0ser2UI3AxAgAELW64Lu6v2J9eAANwMIIABCADcDACAAQShqQQBBKBAQGgviAgICfwV+IABBKGoiASAAKAJIaiECAn4gACkDACIDQiBaBEAgACkDECIEQgeJIAApAwgiBUIBiXwgACkDGCIGQgyJfCAAKQMgIgdCEol8IAUQGSAEEBkgBhAZIAcQGQwBCyAAKQMYQsXP2bLx5brqJ3wLIAN8IQMDQCABQQhqIgAgAk0EQEIAIAEpAAAQCSADhUIbiUKHla+vmLbem55/fkLj3MqV/M7y9YV/fCEDIAAhAQwBCwsCQCABQQRqIgAgAksEQCABIQAMAQsgASgAAK1Ch5Wvr5i23puef34gA4VCF4lCz9bTvtLHq9lCfkL5893xmfaZqxZ8IQMLA0AgACACSQRAIAAxAABCxc/ZsvHluuonfiADhUILiUKHla+vmLbem55/fiEDIABBAWohAAwBCwsgA0IhiCADhULP1tO+0ser2UJ+IgNCHYggA4VC+fPd8Zn2masWfiIDQiCIIAOFC+8CAgJ/BH4gACAAKQMAIAKtfDcDAAJAAkAgACgCSCIDIAJqIgRBH00EQCABRQ0BIAAgA2pBKGogASACECAgACgCSCACaiEEDAELIAEgAmohAgJ/IAMEQCAAQShqIgQgA2ogAUEgIANrECAgACAAKQMIIAQpAAAQCTcDCCAAIAApAxAgACkAMBAJNwMQIAAgACkDGCAAKQA4EAk3AxggACAAKQMgIABBQGspAAAQCTcDICAAKAJIIQMgAEEANgJIIAEgA2tBIGohAQsgAUEgaiACTQsEQCACQWBqIQMgACkDICEFIAApAxghBiAAKQMQIQcgACkDCCEIA0AgCCABKQAAEAkhCCAHIAEpAAgQCSEHIAYgASkAEBAJIQYgBSABKQAYEAkhBSABQSBqIgEgA00NAAsgACAFNwMgIAAgBjcDGCAAIAc3AxAgACAINwMICyABIAJPDQEgAEEoaiABIAIgAWsiBBAgCyAAIAQ2AkgLCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQEBogAwVBun8LCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQCxogAwVBun8LC6gCAQZ/IwBBEGsiByQAIABB2OABaikDAEKAgIAQViEIQbh/IQUCQCAEQf//B0sNACAAIAMgBBBCIgUQAyIGDQAgACgCnOIBIQkgACAHQQxqIAMgAyAFaiAGGyIKIARBACAFIAYbayIGEEAiAxADBEAgAyEFDAELIAcoAgwhBCABRQRAQbp/IQUgBEEASg0BCyAGIANrIQUgAyAKaiEDAkAgCQRAIABBADYCnOIBDAELAkACQAJAIARBBUgNACAAQdjgAWopAwBCgICACFgNAAwBCyAAQQA2ApziAQwBCyAAKAIIED8hBiAAQQA2ApziASAGQRRPDQELIAAgASACIAMgBSAEIAgQOSEFDAELIAAgASACIAMgBSAEIAgQOiEFCyAHQRBqJAAgBQtnACAAQdDgAWogASACIAAoAuzhARAuIgEQAwRAIAEPC0G4fyECAkAgAQ0AIABB7OABaigCACIBBEBBYCECIAAoApjiASABRw0BC0EAIQIgAEHw4AFqKAIARQ0AIABBkOEBahBDCyACCycBAX8QVyIERQRAQUAPCyAEIAAgASACIAMgBBBLEE8hACAEEFYgAAs/AQF/AkACQAJAIAAoAqDiAUEBaiIBQQJLDQAgAUEBaw4CAAECCyAAEDBBAA8LIABBADYCoOIBCyAAKAKU4gELvAMCB38BfiMAQRBrIgkkAEG4fyEGAkAgBCgCACIIQQVBCSAAKALs4QEiBRtJDQAgAygCACIHQQFBBSAFGyAFEC8iBRADBEAgBSEGDAELIAggBUEDakkNACAAIAcgBRBJIgYQAw0AIAEgAmohCiAAQZDhAWohCyAIIAVrIQIgBSAHaiEHIAEhBQNAIAcgAiAJECwiBhADDQEgAkF9aiICIAZJBEBBuH8hBgwCCyAJKAIAIghBAksEQEFsIQYMAgsgB0EDaiEHAn8CQAJAAkAgCEEBaw4CAgABCyAAIAUgCiAFayAHIAYQSAwCCyAFIAogBWsgByAGEEcMAQsgBSAKIAVrIActAAAgCSgCCBBGCyIIEAMEQCAIIQYMAgsgACgC8OABBEAgCyAFIAgQRQsgAiAGayECIAYgB2ohByAFIAhqIQUgCSgCBEUNAAsgACkD0OABIgxCf1IEQEFsIQYgDCAFIAFrrFINAQsgACgC8OABBEBBaiEGIAJBBEkNASALEEQhDCAHKAAAIAynRw0BIAdBBGohByACQXxqIQILIAMgBzYCACAEIAI2AgAgBSABayEGCyAJQRBqJAAgBgsuACAAECsCf0EAQQAQAw0AGiABRSACRXJFBEBBYiAAIAEgAhA9EAMNARoLQQALCzcAIAEEQCAAIAAoAsTgASABKAIEIAEoAghqRzYCnOIBCyAAECtBABADIAFFckUEQCAAIAEQWwsL0QIBB38jAEEQayIGJAAgBiAENgIIIAYgAzYCDCAFBEAgBSgCBCEKIAUoAgghCQsgASEIAkACQANAIAAoAuzhARAWIQsCQANAIAQgC0kNASADKAAAQXBxQdDUtMIBRgRAIAMgBBAiIgcQAw0EIAQgB2shBCADIAdqIQMMAQsLIAYgAzYCDCAGIAQ2AggCQCAFBEAgACAFEE5BACEHQQAQA0UNAQwFCyAAIAogCRBNIgcQAw0ECyAAIAgQUCAMQQFHQQAgACAIIAIgBkEMaiAGQQhqEEwiByIDa0EAIAMQAxtBCkdyRQRAQbh/IQcMBAsgBxADDQMgAiAHayECIAcgCGohCEEBIQwgBigCDCEDIAYoAgghBAwBCwsgBiADNgIMIAYgBDYCCEG4fyEHIAQNASAIIAFrIQcMAQsgBiADNgIMIAYgBDYCCAsgBkEQaiQAIAcLRgECfyABIAAoArjgASICRwRAIAAgAjYCxOABIAAgATYCuOABIAAoArzgASEDIAAgATYCvOABIAAgASADIAJrajYCwOABCwutAgIEfwF+IwBBQGoiBCQAAkACQCACQQhJDQAgASgAAEFwcUHQ1LTCAUcNACABIAIQIiEBIABCADcDCCAAQQA2AgQgACABNgIADAELIARBGGogASACEC0iAxADBEAgACADEBoMAQsgAwRAIABBuH8QGgwBCyACIAQoAjAiA2shAiABIANqIQMDQAJAIAAgAyACIARBCGoQLCIFEAMEfyAFBSACIAVBA2oiBU8NAUG4fwsQGgwCCyAGQQFqIQYgAiAFayECIAMgBWohAyAEKAIMRQ0ACyAEKAI4BEAgAkEDTQRAIABBuH8QGgwCCyADQQRqIQMLIAQoAighAiAEKQMYIQcgAEEANgIEIAAgAyABazYCACAAIAIgBmytIAcgB0J/URs3AwgLIARBQGskAAslAQF/IwBBEGsiAiQAIAIgACABEFEgAigCACEAIAJBEGokACAAC30BBH8jAEGQBGsiBCQAIARB/wE2AggCQCAEQRBqIARBCGogBEEMaiABIAIQFSIGEAMEQCAGIQUMAQtBVCEFIAQoAgwiB0EGSw0AIAMgBEEQaiAEKAIIIAcQQSIFEAMNACAAIAEgBmogAiAGayADEDwhBQsgBEGQBGokACAFC4cBAgJ/An5BABAWIQMCQANAIAEgA08EQAJAIAAoAABBcHFB0NS0wgFGBEAgACABECIiAhADRQ0BQn4PCyAAIAEQVSIEQn1WDQMgBCAFfCIFIARUIQJCfiEEIAINAyAAIAEQUiICEAMNAwsgASACayEBIAAgAmohAAwBCwtCfiAFIAEbIQQLIAQLPwIBfwF+IwBBMGsiAiQAAn5CfiACQQhqIAAgARAtDQAaQgAgAigCHEEBRg0AGiACKQMICyEDIAJBMGokACADC40BAQJ/IwBBMGsiASQAAkAgAEUNACAAKAKI4gENACABIABB/OEBaigCADYCKCABIAApAvThATcDICAAEDAgACgCqOIBIQIgASABKAIoNgIYIAEgASkDIDcDECACIAFBEGoQGyAAQQA2AqjiASABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALKgECfyMAQRBrIgAkACAAQQA2AgggAEIANwMAIAAQWCEBIABBEGokACABC4cBAQN/IwBBEGsiAiQAAkAgACgCAEUgACgCBEVzDQAgAiAAKAIINgIIIAIgACkCADcDAAJ/IAIoAgAiAQRAIAIoAghBqOMJIAERBQAMAQtBqOMJECgLIgFFDQAgASAAKQIANwL04QEgAUH84QFqIAAoAgg2AgAgARBZIAEhAwsgAkEQaiQAIAMLywEBAn8jAEEgayIBJAAgAEGBgIDAADYCtOIBIABBADYCiOIBIABBADYC7OEBIABCADcDkOIBIABBADYCpOMJIABBADYC3OIBIABCADcCzOIBIABBADYCvOIBIABBADYCxOABIABCADcCnOIBIABBpOIBakIANwIAIABBrOIBakEANgIAIAFCADcCECABQgA3AhggASABKQMYNwMIIAEgASkDEDcDACABKAIIQQh2QQFxIQIgAEEANgLg4gEgACACNgKM4gEgAUEgaiQAC3YBA38jAEEwayIBJAAgAARAIAEgAEHE0AFqIgIoAgA2AiggASAAKQK80AE3AyAgACgCACEDIAEgAigCADYCGCABIAApArzQATcDECADIAFBEGoQGyABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALzAEBAX8gACABKAK00AE2ApjiASAAIAEoAgQiAjYCwOABIAAgAjYCvOABIAAgAiABKAIIaiICNgK44AEgACACNgLE4AEgASgCuNABBEAgAEKBgICAEDcDiOEBIAAgAUGk0ABqNgIMIAAgAUGUIGo2AgggACABQZwwajYCBCAAIAFBDGo2AgAgAEGs0AFqIAFBqNABaigCADYCACAAQbDQAWogAUGs0AFqKAIANgIAIABBtNABaiABQbDQAWooAgA2AgAPCyAAQgA3A4jhAQs7ACACRQRAQbp/DwsgBEUEQEFsDwsgAiAEEGAEQCAAIAEgAiADIAQgBRBhDwsgACABIAIgAyAEIAUQZQtGAQF/IwBBEGsiBSQAIAVBCGogBBAOAn8gBS0ACQRAIAAgASACIAMgBBAyDAELIAAgASACIAMgBBA0CyEAIAVBEGokACAACzQAIAAgAyAEIAUQNiIFEAMEQCAFDwsgBSAESQR/IAEgAiADIAVqIAQgBWsgABA1BUG4fwsLRgEBfyMAQRBrIgUkACAFQQhqIAQQDgJ/IAUtAAkEQCAAIAEgAiADIAQQYgwBCyAAIAEgAiADIAQQNQshACAFQRBqJAAgAAtZAQF/QQ8hAiABIABJBEAgAUEEdCAAbiECCyAAQQh2IgEgAkEYbCIAQYwIaigCAGwgAEGICGooAgBqIgJBA3YgAmogAEGACGooAgAgAEGECGooAgAgAWxqSQs3ACAAIAMgBCAFQYAQEDMiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQMgVBuH8LC78DAQN/IwBBIGsiBSQAIAVBCGogAiADEAYiAhADRQRAIAAgAWoiB0F9aiEGIAUgBBAOIARBBGohAiAFLQACIQMDQEEAIAAgBkkgBUEIahAEGwRAIAAgAiAFQQhqIAMQAkECdGoiBC8BADsAACAFQQhqIAQtAAIQASAAIAQtAANqIgQgAiAFQQhqIAMQAkECdGoiAC8BADsAACAFQQhqIAAtAAIQASAEIAAtAANqIQAMAQUgB0F+aiEEA0AgBUEIahAEIAAgBEtyRQRAIAAgAiAFQQhqIAMQAkECdGoiBi8BADsAACAFQQhqIAYtAAIQASAAIAYtAANqIQAMAQsLA0AgACAES0UEQCAAIAIgBUEIaiADEAJBAnRqIgYvAQA7AAAgBUEIaiAGLQACEAEgACAGLQADaiEADAELCwJAIAAgB08NACAAIAIgBUEIaiADEAIiA0ECdGoiAC0AADoAACAALQADQQFGBEAgBUEIaiAALQACEAEMAQsgBSgCDEEfSw0AIAVBCGogAiADQQJ0ai0AAhABIAUoAgxBIUkNACAFQSA2AgwLIAFBbCAFQQhqEAobIQILCwsgBUEgaiQAIAILkgIBBH8jAEFAaiIJJAAgCSADQTQQCyEDAkAgBEECSA0AIAMgBEECdGooAgAhCSADQTxqIAgQIyADQQE6AD8gAyACOgA+QQAhBCADKAI8IQoDQCAEIAlGDQEgACAEQQJ0aiAKNgEAIARBAWohBAwAAAsAC0EAIQkDQCAGIAlGRQRAIAMgBSAJQQF0aiIKLQABIgtBAnRqIgwoAgAhBCADQTxqIAotAABBCHQgCGpB//8DcRAjIANBAjoAPyADIAcgC2siCiACajoAPiAEQQEgASAKa3RqIQogAygCPCELA0AgACAEQQJ0aiALNgEAIARBAWoiBCAKSQ0ACyAMIAo2AgAgCUEBaiEJDAELCyADQUBrJAALowIBCX8jAEHQAGsiCSQAIAlBEGogBUE0EAsaIAcgBmshDyAHIAFrIRADQAJAIAMgCkcEQEEBIAEgByACIApBAXRqIgYtAAEiDGsiCGsiC3QhDSAGLQAAIQ4gCUEQaiAMQQJ0aiIMKAIAIQYgCyAPTwRAIAAgBkECdGogCyAIIAUgCEE0bGogCCAQaiIIQQEgCEEBShsiCCACIAQgCEECdGooAgAiCEEBdGogAyAIayAHIA4QYyAGIA1qIQgMAgsgCUEMaiAOECMgCUEBOgAPIAkgCDoADiAGIA1qIQggCSgCDCELA0AgBiAITw0CIAAgBkECdGogCzYBACAGQQFqIQYMAAALAAsgCUHQAGokAA8LIAwgCDYCACAKQQFqIQoMAAALAAs0ACAAIAMgBCAFEDYiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQNAVBuH8LCyMAIAA/AEEQdGtB//8DakEQdkAAQX9GBEBBAA8LQQAQAEEBCzsBAX8gAgRAA0AgACABIAJBgCAgAkGAIEkbIgMQCyEAIAFBgCBqIQEgAEGAIGohACACIANrIgINAAsLCwYAIAAQAwsLqBUJAEGICAsNAQAAAAEAAAACAAAAAgBBoAgLswYBAAAAAQAAAAIAAAACAAAAJgAAAIIAAAAhBQAASgAAAGcIAAAmAAAAwAEAAIAAAABJBQAASgAAAL4IAAApAAAALAIAAIAAAABJBQAASgAAAL4IAAAvAAAAygIAAIAAAACKBQAASgAAAIQJAAA1AAAAcwMAAIAAAACdBQAASgAAAKAJAAA9AAAAgQMAAIAAAADrBQAASwAAAD4KAABEAAAAngMAAIAAAABNBgAASwAAAKoKAABLAAAAswMAAIAAAADBBgAATQAAAB8NAABNAAAAUwQAAIAAAAAjCAAAUQAAAKYPAABUAAAAmQQAAIAAAABLCQAAVwAAALESAABYAAAA2gQAAIAAAABvCQAAXQAAACMUAABUAAAARQUAAIAAAABUCgAAagAAAIwUAABqAAAArwUAAIAAAAB2CQAAfAAAAE4QAAB8AAAA0gIAAIAAAABjBwAAkQAAAJAHAACSAAAAAAAAAAEAAAABAAAABQAAAA0AAAAdAAAAPQAAAH0AAAD9AAAA/QEAAP0DAAD9BwAA/Q8AAP0fAAD9PwAA/X8AAP3/AAD9/wEA/f8DAP3/BwD9/w8A/f8fAP3/PwD9/38A/f//AP3//wH9//8D/f//B/3//w/9//8f/f//P/3//38AAAAAAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABEAAAASAAAAEwAAABQAAAAVAAAAFgAAABcAAAAYAAAAGQAAABoAAAAbAAAAHAAAAB0AAAAeAAAAHwAAAAMAAAAEAAAABQAAAAYAAAAHAAAACAAAAAkAAAAKAAAACwAAAAwAAAANAAAADgAAAA8AAAAQAAAAEQAAABIAAAATAAAAFAAAABUAAAAWAAAAFwAAABgAAAAZAAAAGgAAABsAAAAcAAAAHQAAAB4AAAAfAAAAIAAAACEAAAAiAAAAIwAAACUAAAAnAAAAKQAAACsAAAAvAAAAMwAAADsAAABDAAAAUwAAAGMAAACDAAAAAwEAAAMCAAADBAAAAwgAAAMQAAADIAAAA0AAAAOAAAADAAEAQeAPC1EBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAEAAAABQAAAAcAAAAIAAAACQAAAAoAAAALAAAADAAAAA0AAAAOAAAADwAAABAAQcQQC4sBAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABIAAAAUAAAAFgAAABgAAAAcAAAAIAAAACgAAAAwAAAAQAAAAIAAAAAAAQAAAAIAAAAEAAAACAAAABAAAAAgAAAAQAAAAIAAAAAAAQBBkBIL5gQBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAAAEAAAAEAAAACAAAAAAAAAABAAEBBgAAAAAAAAQAAAAAEAAABAAAAAAgAAAFAQAAAAAAAAUDAAAAAAAABQQAAAAAAAAFBgAAAAAAAAUHAAAAAAAABQkAAAAAAAAFCgAAAAAAAAUMAAAAAAAABg4AAAAAAAEFEAAAAAAAAQUUAAAAAAABBRYAAAAAAAIFHAAAAAAAAwUgAAAAAAAEBTAAAAAgAAYFQAAAAAAABwWAAAAAAAAIBgABAAAAAAoGAAQAAAAADAYAEAAAIAAABAAAAAAAAAAEAQAAAAAAAAUCAAAAIAAABQQAAAAAAAAFBQAAACAAAAUHAAAAAAAABQgAAAAgAAAFCgAAAAAAAAULAAAAAAAABg0AAAAgAAEFEAAAAAAAAQUSAAAAIAABBRYAAAAAAAIFGAAAACAAAwUgAAAAAAADBSgAAAAAAAYEQAAAABAABgRAAAAAIAAHBYAAAAAAAAkGAAIAAAAACwYACAAAMAAABAAAAAAQAAAEAQAAACAAAAUCAAAAIAAABQMAAAAgAAAFBQAAACAAAAUGAAAAIAAABQgAAAAgAAAFCQAAACAAAAULAAAAIAAABQwAAAAAAAAGDwAAACAAAQUSAAAAIAABBRQAAAAgAAIFGAAAACAAAgUcAAAAIAADBSgAAAAgAAQFMAAAAAAAEAYAAAEAAAAPBgCAAAAAAA4GAEAAAAAADQYAIABBgBcLhwIBAAEBBQAAAAAAAAUAAAAAAAAGBD0AAAAAAAkF/QEAAAAADwX9fwAAAAAVBf3/HwAAAAMFBQAAAAAABwR9AAAAAAAMBf0PAAAAABIF/f8DAAAAFwX9/38AAAAFBR0AAAAAAAgE/QAAAAAADgX9PwAAAAAUBf3/DwAAAAIFAQAAABAABwR9AAAAAAALBf0HAAAAABEF/f8BAAAAFgX9/z8AAAAEBQ0AAAAQAAgE/QAAAAAADQX9HwAAAAATBf3/BwAAAAEFAQAAABAABgQ9AAAAAAAKBf0DAAAAABAF/f8AAAAAHAX9//8PAAAbBf3//wcAABoF/f//AwAAGQX9//8BAAAYBf3//wBBkBkLhgQBAAEBBgAAAAAAAAYDAAAAAAAABAQAAAAgAAAFBQAAAAAAAAUGAAAAAAAABQgAAAAAAAAFCQAAAAAAAAULAAAAAAAABg0AAAAAAAAGEAAAAAAAAAYTAAAAAAAABhYAAAAAAAAGGQAAAAAAAAYcAAAAAAAABh8AAAAAAAAGIgAAAAAAAQYlAAAAAAABBikAAAAAAAIGLwAAAAAAAwY7AAAAAAAEBlMAAAAAAAcGgwAAAAAACQYDAgAAEAAABAQAAAAAAAAEBQAAACAAAAUGAAAAAAAABQcAAAAgAAAFCQAAAAAAAAUKAAAAAAAABgwAAAAAAAAGDwAAAAAAAAYSAAAAAAAABhUAAAAAAAAGGAAAAAAAAAYbAAAAAAAABh4AAAAAAAAGIQAAAAAAAQYjAAAAAAABBicAAAAAAAIGKwAAAAAAAwYzAAAAAAAEBkMAAAAAAAUGYwAAAAAACAYDAQAAIAAABAQAAAAwAAAEBAAAABAAAAQFAAAAIAAABQcAAAAgAAAFCAAAACAAAAUKAAAAIAAABQsAAAAAAAAGDgAAAAAAAAYRAAAAAAAABhQAAAAAAAAGFwAAAAAAAAYaAAAAAAAABh0AAAAAAAAGIAAAAAAAEAYDAAEAAAAPBgOAAAAAAA4GA0AAAAAADQYDIAAAAAAMBgMQAAAAAAsGAwgAAAAACgYDBABBpB0L2QEBAAAAAwAAAAcAAAAPAAAAHwAAAD8AAAB/AAAA/wAAAP8BAAD/AwAA/wcAAP8PAAD/HwAA/z8AAP9/AAD//wAA//8BAP//AwD//wcA//8PAP//HwD//z8A//9/AP///wD///8B////A////wf///8P////H////z////9/AAAAAAEAAAACAAAABAAAAAAAAAACAAAABAAAAAgAAAAAAAAAAQAAAAIAAAABAAAABAAAAAQAAAAEAAAABAAAAAgAAAAIAAAACAAAAAcAAAAIAAAACQAAAAoAAAALAEGgIAsDwBBQ'
      var sh,
        rh,
        ah = {
          createLevels: async function (t, e) {
            t.supercompressionScheme === Uc.ZSTD && (await e.init())
            for (var i = [], n = t.pixelWidth, s = t.pixelHeight, r = 0; r < t.levels.length; r++) {
              var a = Math.max(1, Math.floor(n / Math.pow(2, r))),
                o = Math.max(1, Math.floor(s / Math.pow(2, r))),
                l = t.levels[r].levelData
              t.supercompressionScheme === Uc.ZSTD && (l = e.decode(l, t.levels[r].uncompressedByteLength)),
                i.push({ index: r, width: a, height: o, data: l })
            }
            return i
          },
          getBasicDFD: function (t) {
            return t.dataFormatDescriptor[0]
          },
          getAlpha: function (t) {
            var e = this.getBasicDFD(t)
            return e.colorModel === Oc.UASTC
              ? (15 & e.samples[0].channelID) === Wc.RGBA
              : 2 === e.samples.length && (15 & e.samples[1].channelID) === Hc.AAA
          },
          getPremultiplyAlpha: function (t) {
            return !!(this.getBasicDFD(t).flags & Vc.ALPHA_PREMULTIPLIED)
          },
        }
      /* @license
       * Copyright 2019 Google LLC. All Rights Reserved.
       * Licensed under the Apache License, Version 2.0 (the 'License');
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *     http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an 'AS IS' BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ const oh = Symbol('retainerCount'),
        lh = Symbol('recentlyUsed'),
        ch = Symbol('evict'),
        hh = Symbol('evictionThreshold'),
        uh = Symbol('cache')
      class dh {
        constructor(t, e = 5) {
          ;(this[sh] = new Map()), (this[rh] = []), (this[uh] = t), (this[hh] = e)
        }
        set evictionThreshold(t) {
          ;(this[hh] = t), this[ch]()
        }
        get evictionThreshold() {
          return this[hh]
        }
        get cache() {
          return this[uh]
        }
        retainerCount(t) {
          return this[oh].get(t) || 0
        }
        reset() {
          this[oh].clear(), (this[lh] = [])
        }
        retain(t) {
          this[oh].has(t) || this[oh].set(t, 0), this[oh].set(t, this[oh].get(t) + 1)
          const e = this[lh].indexOf(t)
          ;-1 !== e && this[lh].splice(e, 1), this[lh].unshift(t), this[ch]()
        }
        release(t) {
          this[oh].has(t) && this[oh].set(t, Math.max(this[oh].get(t) - 1, 0)), this[ch]()
        }
        [((sh = oh), (rh = lh), ch)]() {
          if (!(this[lh].length < this[hh]))
            for (let t = this[lh].length - 1; t >= this[hh]; --t) {
              const e = this[lh][t]
              0 === this[oh].get(e) && (this[uh].delete(e), this[lh].splice(t, 1))
            }
        }
      }
      /* @license
       * Copyright 2021 Google LLC. All Rights Reserved.
       * Licensed under the Apache License, Version 2.0 (the 'License');
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *     http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an 'AS IS' BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ const ph = (t, e) => {
          const i = new Map()
          for (const n of t.mappings)
            for (const t of n.variants) i.set(e[t], { material: null, gltfMaterialIndex: n.material })
          return i
        },
        Ah = (t) => 'material' in t && t.userData && t.userData.variantMaterials
      class gh {
        constructor(t) {
          ;(this.parser = t), (this.name = 'KHR_materials_variants')
        }
        afterRoot(t) {
          const e = this.parser,
            i = e.json
          if (void 0 === i.extensions || void 0 === i.extensions[this.name]) return null
          const n = ((t) => {
            const e = [],
              i = new Set()
            for (const n of t) {
              let t = n,
                s = 0
              for (; i.has(t); ) t = n + '.' + ++s
              i.add(t), e.push(t)
            }
            return e
          })((i.extensions[this.name].variants || []).map((t) => t.name))
          for (const a of t.scenes)
            a.traverse((t) => {
              const s = e.associations.get(t)
              if (!s || 'nodes' !== s.type) return
              const r = i.nodes[s.index].mesh
              if (void 0 === r) return
              const a = i.meshes[r].primitives,
                o = 'isMesh' in t ? [t] : t.children
              for (let e = 0; e < a.length; e++) {
                const t = a[e].extensions
                t && t[this.name] && (o[e].userData.variantMaterials = ph(t[this.name], n))
              }
            })
          ;(t.userData.variants = n), (t.userData.functions = t.userData.functions || {})
          const s = async (t, i, n) => {
              t.userData.originalMaterial || (t.userData.originalMaterial = t.material)
              const s = t.material
              let r = null
              if (null !== i && t.userData.variantMaterials.has(i)) {
                const n = t.userData.variantMaterials.get(i)
                n.material
                  ? ((t.material = n.material), 'gltfMaterialIndex' in n && (r = n.gltfMaterialIndex))
                  : ((r = n.gltfMaterialIndex),
                    (t.material = await e.getDependency('material', r)),
                    e.assignFinalMaterial(t),
                    (n.material = t.material))
              } else
                (t.material = t.userData.originalMaterial),
                  e.associations.has(t.material) && (r = e.associations.get(t.material).index)
              null !== n && n(t, s, r)
            },
            r = (t) => {
              const i = t.material,
                n = t.userData.variantMaterials,
                s = []
              for (const r of n.keys()) {
                const i = n.get(r)
                if (i.material) continue
                const a = i.gltfMaterialIndex
                s.push(
                  e.getDependency('material', a).then((i) => {
                    ;(t.material = i), e.assignFinalMaterial(t), (n.get(r).material = t.material)
                  }),
                )
              }
              return Promise.all(s).then(() => {
                t.material = i
              })
            }
          return (
            (t.userData.functions.selectVariant = (t, e, i = !0, n = null) => {
              const r = []
              return i ? t.traverse((t) => Ah(t) && r.push(s(t, e, n))) : Ah(t) && r.push(s(t, e, n)), Promise.all(r)
            }),
            (t.userData.functions.ensureLoadVariants = (t, e = !0) => {
              const i = []
              return e ? t.traverse((t) => Ah(t) && i.push(r(t))) : Ah(t) && i.push(r(t)), Promise.all(i)
            }),
            Promise.resolve()
          )
          /* @license
           * Copyright 2019 Google LLC. All Rights Reserved.
           * Licensed under the Apache License, Version 2.0 (the 'License');
           * you may not use this file except in compliance with the License.
           * You may obtain a copy of the License at
           *
           *     http://www.apache.org/licenses/LICENSE-2.0
           *
           * Unless required by applicable law or agreed to in writing, software
           * distributed under the License is distributed on an 'AS IS' BASIS,
           * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
           * See the License for the specific language governing permissions and
           * limitations under the License.
           */
        }
      }
      var mh, fh
      const vh = new Map(),
        yh = new Map()
      let xh
      const wh = new (class extends Jo {
        constructor(t) {
          super(t),
            (this.decoderPath = ''),
            (this.decoderConfig = {}),
            (this.decoderBinary = null),
            (this.decoderPending = null),
            (this.workerLimit = 4),
            (this.workerPool = []),
            (this.workerNextTaskID = 1),
            (this.workerSourceURL = ''),
            (this.defaultAttributeIDs = { position: 'POSITION', normal: 'NORMAL', color: 'COLOR', uv: 'TEX_COORD' }),
            (this.defaultAttributeTypes = {
              position: 'Float32Array',
              normal: 'Float32Array',
              color: 'Float32Array',
              uv: 'Float32Array',
            })
        }
        setDecoderPath(t) {
          return (this.decoderPath = t), this
        }
        setDecoderConfig(t) {
          return (this.decoderConfig = t), this
        }
        setWorkerLimit(t) {
          return (this.workerLimit = t), this
        }
        load(t, e, i, n) {
          const s = new Ko(this.manager)
          s.setPath(this.path),
            s.setResponseType('arraybuffer'),
            s.setRequestHeader(this.requestHeader),
            s.setWithCredentials(this.withCredentials),
            s.load(
              t,
              (t) => {
                const i = {
                  attributeIDs: this.defaultAttributeIDs,
                  attributeTypes: this.defaultAttributeTypes,
                  useUniqueIDs: !1,
                }
                this.decodeGeometry(t, i).then(e).catch(n)
              },
              i,
              n,
            )
        }
        decodeDracoFile(t, e, i, n) {
          const s = {
            attributeIDs: i || this.defaultAttributeIDs,
            attributeTypes: n || this.defaultAttributeTypes,
            useUniqueIDs: !!i,
          }
          this.decodeGeometry(t, s).then(e)
        }
        decodeGeometry(t, e) {
          for (const o in e.attributeTypes) {
            const t = e.attributeTypes[o]
            void 0 !== t.BYTES_PER_ELEMENT && (e.attributeTypes[o] = t.name)
          }
          const i = JSON.stringify(e)
          if (Jl.has(t)) {
            const e = Jl.get(t)
            if (e.key === i) return e.promise
            if (0 === t.byteLength)
              throw new Error(
                'THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.',
              )
          }
          let n
          const s = this.workerNextTaskID++,
            r = t.byteLength,
            a = this._getWorker(s, r)
              .then(
                (i) => (
                  (n = i),
                  new Promise((i, r) => {
                    ;(n._callbacks[s] = { resolve: i, reject: r }),
                      n.postMessage({ type: 'decode', id: s, taskConfig: e, buffer: t }, [t])
                  })
                ),
              )
              .then((t) => this._createGeometry(t.geometry))
          return (
            a
              .catch(() => !0)
              .then(() => {
                n && s && this._releaseTask(n, s)
              }),
            Jl.set(t, { key: i, promise: a }),
            a
          )
        }
        _createGeometry(t) {
          const e = new hi()
          t.index && e.setIndex(new Ze(t.index.array, 1))
          for (let i = 0; i < t.attributes.length; i++) {
            const n = t.attributes[i],
              s = n.name,
              r = n.array,
              a = n.itemSize
            e.setAttribute(s, new Ze(r, a))
          }
          return e
        }
        _loadLibrary(t, e) {
          const i = new Ko(this.manager)
          return (
            i.setPath(this.decoderPath),
            i.setResponseType(e),
            i.setWithCredentials(this.withCredentials),
            new Promise((e, n) => {
              i.load(t, e, void 0, n)
            })
          )
        }
        preload() {
          return this._initDecoder(), this
        }
        _initDecoder() {
          if (this.decoderPending) return this.decoderPending
          const t = 'object' != typeof WebAssembly || 'js' === this.decoderConfig.type,
            e = []
          return (
            t
              ? e.push(this._loadLibrary('draco_decoder.js', 'text'))
              : (e.push(this._loadLibrary('draco_wasm_wrapper.js', 'text')),
                e.push(this._loadLibrary('draco_decoder.wasm', 'arraybuffer'))),
            (this.decoderPending = Promise.all(e).then((e) => {
              const i = e[0]
              t || (this.decoderConfig.wasmBinary = e[1])
              const n = Xl.toString(),
                s = [
                  '/* draco decoder */',
                  i,
                  '',
                  '/* worker */',
                  n.substring(n.indexOf('{') + 1, n.lastIndexOf('}')),
                ].join('\n')
              this.workerSourceURL = URL.createObjectURL(new Blob([s]))
            })),
            this.decoderPending
          )
        }
        _getWorker(t, e) {
          return this._initDecoder().then(() => {
            if (this.workerPool.length < this.workerLimit) {
              const t = new Worker(this.workerSourceURL)
              ;(t._callbacks = {}),
                (t._taskCosts = {}),
                (t._taskLoad = 0),
                t.postMessage({ type: 'init', decoderConfig: this.decoderConfig }),
                (t.onmessage = function (e) {
                  const i = e.data
                  switch (i.type) {
                    case 'decode':
                      t._callbacks[i.id].resolve(i)
                      break
                    case 'error':
                      t._callbacks[i.id].reject(i)
                  }
                }),
                this.workerPool.push(t)
            } else
              this.workerPool.sort(function (t, e) {
                return t._taskLoad > e._taskLoad ? -1 : 1
              })
            const i = this.workerPool[this.workerPool.length - 1]
            return (i._taskCosts[t] = e), (i._taskLoad += e), i
          })
        }
        _releaseTask(t, e) {
          ;(t._taskLoad -= t._taskCosts[e]), delete t._callbacks[e], delete t._taskCosts[e]
        }
        debug() {}
        dispose() {
          for (let t = 0; t < this.workerPool.length; ++t) this.workerPool[t].terminate()
          return (this.workerPool.length = 0), this
        }
      })()
      let _h
      const Ih = new (class extends Zo {
          constructor(t) {
            super(t), (this.basisLoader = new Kc(t)), (this.zstd = new ih()), this.zstd.init()
          }
          setTranscoderPath(t) {
            return this.basisLoader.setTranscoderPath(t), this
          }
          setWorkerLimit(t) {
            return this.basisLoader.setWorkerLimit(t), this
          }
          detectSupport(t) {
            return this.basisLoader.detectSupport(t), this
          }
          dispose() {
            return this.basisLoader.dispose(), this
          }
          load(t, e, i, n) {
            var s = this,
              r = new Da()
            return (
              new Promise(function (e, n) {
                new Ko(s.manager).setPath(s.path).setResponseType('arraybuffer').load(t, e, i, n)
              })
                .then(function (t) {
                  s.parse(
                    t,
                    function (t) {
                      r.copy(t), (r.needsUpdate = !0), e && e(r)
                    },
                    n,
                  )
                })
                .catch(n),
              r
            )
          }
          parse(t, e, i) {
            var n = this,
              s = (function (t) {
                const e = new Uint8Array(t.buffer, t.byteOffset, Fc.length)
                if (
                  e[0] !== Fc[0] ||
                  e[1] !== Fc[1] ||
                  e[2] !== Fc[2] ||
                  e[3] !== Fc[3] ||
                  e[4] !== Fc[4] ||
                  e[5] !== Fc[5] ||
                  e[6] !== Fc[6] ||
                  e[7] !== Fc[7] ||
                  e[8] !== Fc[8] ||
                  e[9] !== Fc[9] ||
                  e[10] !== Fc[10] ||
                  e[11] !== Fc[11]
                )
                  throw new Error('Missing KTX 2.0 identifier.')
                const i = new jc(),
                  n = 17 * Uint32Array.BYTES_PER_ELEMENT,
                  s = new Yc(t, Fc.length, n, !0)
                ;(i.vkFormat = s._nextUint32()),
                  (i.typeSize = s._nextUint32()),
                  (i.pixelWidth = s._nextUint32()),
                  (i.pixelHeight = s._nextUint32()),
                  (i.pixelDepth = s._nextUint32()),
                  (i.layerCount = s._nextUint32()),
                  (i.faceCount = s._nextUint32())
                const r = s._nextUint32()
                i.supercompressionScheme = s._nextUint32()
                const a = s._nextUint32(),
                  o = s._nextUint32(),
                  l = s._nextUint32(),
                  c = s._nextUint32(),
                  h = s._nextUint64(),
                  u = s._nextUint64(),
                  d = new Yc(t, Fc.length + n, 3 * r * 8, !0)
                for (let Q = 0; Q < r; Q++)
                  i.levels.push({
                    levelData: new Uint8Array(t.buffer, t.byteOffset + d._nextUint64(), d._nextUint64()),
                    uncompressedByteLength: d._nextUint64(),
                  })
                const p = new Yc(t, a, o, !0),
                  A = {
                    vendorId: p._skip(4)._nextUint16(),
                    descriptorType: p._nextUint16(),
                    versionNumber: p._nextUint16(),
                    descriptorBlockSize: p._nextUint16(),
                    colorModel: p._nextUint8(),
                    colorPrimaries: p._nextUint8(),
                    transferFunction: p._nextUint8(),
                    flags: p._nextUint8(),
                    texelBlockDimension: {
                      x: p._nextUint8() + 1,
                      y: p._nextUint8() + 1,
                      z: p._nextUint8() + 1,
                      w: p._nextUint8() + 1,
                    },
                    bytesPlane: [
                      p._nextUint8(),
                      p._nextUint8(),
                      p._nextUint8(),
                      p._nextUint8(),
                      p._nextUint8(),
                      p._nextUint8(),
                      p._nextUint8(),
                      p._nextUint8(),
                    ],
                    samples: [],
                  },
                  g = (A.descriptorBlockSize / 4 - 6) / 4
                for (let Q = 0; Q < g; Q++)
                  A.samples[Q] = {
                    bitOffset: p._nextUint16(),
                    bitLength: p._nextUint8(),
                    channelID: p._nextUint8(),
                    samplePosition: [p._nextUint8(), p._nextUint8(), p._nextUint8(), p._nextUint8()],
                    sampleLower: p._nextUint32(),
                    sampleUpper: p._nextUint32(),
                  }
                ;(i.dataFormatDescriptor.length = 0), i.dataFormatDescriptor.push(A)
                const m = new Yc(t, l, c, !0)
                for (; m._offset < c; ) {
                  const t = m._nextUint32(),
                    e = m._scan(t),
                    n = Jc(e),
                    s = m._scan(t - e.byteLength)
                  ;(i.keyValue[n] = n.match(/^ktx/i) ? Jc(s) : s), m._offset % 4 && m._skip(4 - (m._offset % 4))
                }
                if (u <= 0) return i
                const f = new Yc(t, h, u, !0),
                  v = f._nextUint16(),
                  y = f._nextUint16(),
                  x = f._nextUint32(),
                  w = f._nextUint32(),
                  _ = f._nextUint32(),
                  I = f._nextUint32(),
                  C = []
                for (let Q = 0; Q < r; Q++)
                  C.push({
                    imageFlags: f._nextUint32(),
                    rgbSliceByteOffset: f._nextUint32(),
                    rgbSliceByteLength: f._nextUint32(),
                    alphaSliceByteOffset: f._nextUint32(),
                    alphaSliceByteLength: f._nextUint32(),
                  })
                const M = h + f._offset,
                  E = M + x,
                  b = E + w,
                  S = b + _,
                  B = new Uint8Array(t.buffer, t.byteOffset + M, x),
                  T = new Uint8Array(t.buffer, t.byteOffset + E, w),
                  L = new Uint8Array(t.buffer, t.byteOffset + b, _),
                  D = new Uint8Array(t.buffer, t.byteOffset + S, I)
                return (
                  (i.globalData = {
                    endpointCount: v,
                    selectorCount: y,
                    imageDescs: C,
                    endpointsData: B,
                    selectorsData: T,
                    tablesData: L,
                    extendedData: D,
                  }),
                  i
                )
              })(new Uint8Array(t))
            if (s.pixelDepth > 0) throw new Error('THREE.KTX2Loader: Only 2D textures are currently supported.')
            if (s.layerCount > 1) throw new Error('THREE.KTX2Loader: Array textures are not currently supported.')
            if (s.faceCount > 1) throw new Error('THREE.KTX2Loader: Cube textures are not currently supported.')
            var r = ah.getBasicDFD(s)
            return (
              ah
                .createLevels(s, this.zstd)
                .then(function (t) {
                  var e = r.colorModel === Oc.UASTC ? Kc.BasisFormat.UASTC_4x4 : Kc.BasisFormat.ETC1S,
                    i = {
                      levels: t,
                      width: s.pixelWidth,
                      height: s.pixelHeight,
                      basisFormat: e,
                      hasAlpha: ah.getAlpha(s),
                    }
                  return (
                    e === Kc.BasisFormat.ETC1S && (i.globalData = s.globalData), n.basisLoader.parseInternalAsync(i)
                  )
                })
                .then(function (t) {
                  ;(t.encoding = r.transferFunction === zc.SRGB ? 3001 : 3e3),
                    (t.premultiplyAlpha = ah.getPremultiplyAlpha(s)),
                    e(t)
                })
                .catch(i),
              this
            )
          }
        })(),
        Ch = Symbol('loader'),
        Mh = Symbol('evictionPolicy'),
        Eh = Symbol('GLTFInstance')
      class bh extends it {
        constructor(t) {
          super(),
            (this[fh] = new Kl().register((t) => new gh(t))),
            (this[Eh] = t),
            this[Ch].setDRACOLoader(wh),
            this[Ch].setKTX2Loader(Ih)
        }
        static setDRACODecoderLocation(t) {
          ;(xh = t), wh.setDecoderPath(t)
        }
        static getDRACODecoderLocation() {
          return xh
        }
        static setKTX2TranscoderLocation(t) {
          ;(_h = t), Ih.setTranscoderPath(t)
        }
        static getKTX2TranscoderLocation() {
          return _h
        }
        static initializeKTX2Loader(t) {
          Ih.detectSupport(t)
        }
        static get cache() {
          return vh
        }
        static clearCache() {
          vh.forEach((t, e) => {
            this.delete(e)
          }),
            this[Mh].reset()
        }
        static has(t) {
          return vh.has(t)
        }
        static async delete(t) {
          if (!this.has(t)) return
          const e = vh.get(t)
          yh.delete(t), vh.delete(t), (await e).dispose()
        }
        static hasFinishedLoading(t) {
          return !!yh.get(t)
        }
        get [((mh = Mh), (fh = Ch), Mh)]() {
          return this.constructor[Mh]
        }
        async preload(t, e, i = () => {}) {
          if ((this.dispatchEvent({ type: 'preload', element: e, src: t }), !vh.has(t))) {
            const e = ((t, e, i = () => {}) => {
                const n = (t) => {
                  const e = t.loaded / t.total
                  i(Math.max(0, Math.min(1, isFinite(e) ? e : 1)))
                }
                return new Promise((i, s) => {
                  e.load(t, i, n, s)
                })
              })(t, this[Ch], (t) => {
                i(0.8 * t)
              }),
              n = this[Eh],
              s = e.then((t) => n.prepare(t)).then((t) => (i(0.9), new n(t)))
            vh.set(t, s)
          }
          await vh.get(t), yh.set(t, !0), i && i(1)
        }
        async load(t, e, i = () => {}) {
          await this.preload(t, e, i)
          const n = await vh.get(t),
            s = await n.clone()
          return (
            this[Mh].retain(t),
            (s.dispose = (() => {
              const e = s.dispose
              let i = !1
              return () => {
                i || ((i = !0), e.apply(s), this[Mh].release(t))
              }
            })()),
            s
          )
        }
      }
      bh[mh] = new dh(bh)
      class Sh extends Se {
        constructor(t) {
          super(),
            (this.element = t || document.createElement('div')),
            (this.element.style.position = 'absolute'),
            (this.element.style.userSelect = 'none'),
            this.element.setAttribute('draggable', !1),
            this.addEventListener('removed', function () {
              this.traverse(function (t) {
                t.element instanceof Element &&
                  null !== t.element.parentNode &&
                  t.element.parentNode.removeChild(t.element)
              })
            })
        }
        copy(t, e) {
          return super.copy(t, e), (this.element = t.element.cloneNode(!0)), this
        }
      }
      Sh.prototype.isCSS2DObject = !0
      const Bh = new Et(),
        Th = new ne(),
        Lh = new ne(),
        Dh = new Et(),
        Qh = new Et()
      class Rh {
        constructor() {
          const t = this
          let e, i, n, s
          const r = { objects: new WeakMap() },
            a = document.createElement('div')
          function o(e, i, c) {
            if (e.isCSS2DObject) {
              e.onBeforeRender(t, i, c), Bh.setFromMatrixPosition(e.matrixWorld), Bh.applyMatrix4(Lh)
              const o = e.element
              ;/apple/i.test(navigator.vendor)
                ? (o.style.transform =
                    'translate(-50%,-50%) translate(' +
                    Math.round(Bh.x * n + n) +
                    'px,' +
                    Math.round(-Bh.y * s + s) +
                    'px)')
                : (o.style.transform =
                    'translate(-50%,-50%) translate(' + (Bh.x * n + n) + 'px,' + (-Bh.y * s + s) + 'px)'),
                (o.style.display = e.visible && Bh.z >= -1 && Bh.z <= 1 ? '' : 'none')
              const h = { distanceToCameraSquared: l(c, e) }
              r.objects.set(e, h), o.parentNode !== a && a.appendChild(o), e.onAfterRender(t, i, c)
            }
            for (let t = 0, n = e.children.length; t < n; t++) o(e.children[t], i, c)
          }
          function l(t, e) {
            return (
              Dh.setFromMatrixPosition(t.matrixWorld), Qh.setFromMatrixPosition(e.matrixWorld), Dh.distanceToSquared(Qh)
            )
          }
          ;(a.style.overflow = 'hidden'),
            (this.domElement = a),
            (this.getSize = function () {
              return { width: e, height: i }
            }),
            (this.render = function (t, e) {
              !0 === t.autoUpdate && t.updateMatrixWorld(),
                null === e.parent && e.updateMatrixWorld(),
                Th.copy(e.matrixWorldInverse),
                Lh.multiplyMatrices(e.projectionMatrix, Th),
                o(t, t, e),
                (function (t) {
                  const e = (function (t) {
                      const e = []
                      return (
                        t.traverse(function (t) {
                          t.isCSS2DObject && e.push(t)
                        }),
                        e
                      )
                    })(t).sort(function (t, e) {
                      return r.objects.get(t).distanceToCameraSquared - r.objects.get(e).distanceToCameraSquared
                    }),
                    i = e.length
                  for (let n = 0, s = e.length; n < s; n++) e[n].element.style.zIndex = i - n
                })(t)
            }),
            (this.setSize = function (t, r) {
              ;(e = t), (i = r), (n = e / 2), (s = i / 2), (a.style.width = t + 'px'), (a.style.height = r + 'px')
            })
        }
      }
      /* @license
       * Copyright 2019 Google LLC. All Rights Reserved.
       * Licensed under the Apache License, Version 2.0 (the 'License');
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *     http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an 'AS IS' BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ const Ph = (t) => (t && 'null' !== t ? Fh(t) : null),
        Nh = () => {
          if (Y) return
          const t = []
          throw (
            (H || t.push('WebXR Device API'),
            W || t.push('WebXR Hit Test API'),
            new Error(`The following APIs are required for AR, but are missing in this browser: ${t.join(', ')}`))
          )
        },
        Fh = (t) => new URL(t, window.location.toString()).toString(),
        Uh = (t, e) => {
          let i = null
          return (...n) => {
            null != i && self.clearTimeout(i),
              (i = self.setTimeout(() => {
                ;(i = null), t(...n)
              }, e))
          }
        },
        kh = (t, e, i) => Math.max(e, Math.min(i, t)),
        Oh = (() => {
          const t = (() => {
            const t = null != document.head ? Array.from(document.head.querySelectorAll('meta')) : []
            for (const e of t) if ('viewport' === e.name) return !0
            return !1
          })()
          return () => (t ? window.devicePixelRatio : 1)
        })(),
        Gh = (() => {
          const t = new RegExp('[?&]model-viewer-debug-mode(&|$)')
          return () =>
            (self.ModelViewerElement && self.ModelViewerElement.debugMode) ||
            (self.location && self.location.search && self.location.search.match(t))
        })()
      class zh {
        constructor(t = 50) {
          ;(this.velocity = 0), (this.naturalFrequency = 0), this.setDecayTime(t)
        }
        setDecayTime(t) {
          this.naturalFrequency = 1 / Math.max(0.001, t)
        }
        update(t, e, i, n) {
          const s = 2e-4 * this.naturalFrequency
          if (null == t || 0 === n) return e
          if (t === e && 0 === this.velocity) return e
          if (i < 0) return t
          const r = t - e,
            a = this.velocity + this.naturalFrequency * r,
            o = r + i * a,
            l = Math.exp(-this.naturalFrequency * i),
            c = (a - this.naturalFrequency * o) * l,
            h = -this.naturalFrequency * (c + a * l)
          return Math.abs(c) < s * Math.abs(n) && h * r >= 0
            ? ((this.velocity = 0), e)
            : ((this.velocity = c), e + o * l)
        }
      }
      /* @license
       * Copyright 2019 Google LLC. All Rights Reserved.
       * Licensed under the Apache License, Version 2.0 (the 'License');
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *     http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an 'AS IS' BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ const Vh = (t, e) => ({ type: 'number', number: t, unit: e }),
        Hh = (() => {
          const t = {}
          return (e) => {
            const i = e
            if (i in t) return t[i]
            const n = []
            let s = 0
            for (; e; ) {
              if (++s > 1e3) {
                e = ''
                break
              }
              const t = Wh(e),
                i = t.nodes[0]
              if (null == i || 0 === i.terms.length) break
              n.push(i), (e = t.remainingInput)
            }
            return (t[i] = n)
          }
        })(),
        Wh = (() => {
          const t = /^(\-\-|[a-z\u0240-\uffff])/i,
            e = /^([\*\+\/]|[\-]\s)/i,
            i = /^[\),]/
          return (n) => {
            const s = []
            for (; n.length && ((n = n.trim()), !i.test(n)); )
              if ('(' === n[0]) {
                const { nodes: t, remainingInput: e } = Jh(n)
                ;(n = e), s.push({ type: 'function', name: { type: 'ident', value: 'calc' }, arguments: t })
              } else if (t.test(n)) {
                const t = qh(n),
                  e = t.nodes[0]
                if ('(' === (n = t.remainingInput)[0]) {
                  const { nodes: t, remainingInput: i } = Jh(n)
                  s.push({ type: 'function', name: e, arguments: t }), (n = i)
                } else s.push(e)
              } else if (e.test(n)) s.push({ type: 'operator', value: n[0] }), (n = n.slice(1))
              else {
                const { nodes: t, remainingInput: e } = '#' === n[0] ? Yh(n) : jh(n)
                if (0 === t.length) break
                s.push(t[0]), (n = e)
              }
            return { nodes: [{ type: 'expression', terms: s }], remainingInput: n }
          }
        })(),
        qh = (() => {
          const t = /[^a-z0-9_\-\u0240-\uffff]/i
          return (e) => {
            const i = e.match(t)
            return {
              nodes: [{ type: 'ident', value: null == i ? e : e.substr(0, i.index) }],
              remainingInput: null == i ? '' : e.substr(i.index),
            }
          }
        })(),
        jh = (() => {
          const t = /[\+\-]?(\d+[\.]\d+|\d+|[\.]\d+)([eE][\+\-]?\d+)?/,
            e = /^[a-z%]+/i,
            i = /^(m|mm|cm|rad|deg|[%])$/
          return (n) => {
            const s = n.match(t),
              r = null == s ? '0' : s[0],
              a = (n = null == r ? n : n.slice(r.length)).match(e)
            let o = null != a && '' !== a[0] ? a[0] : null
            const l = null == a ? n : n.slice(o.length)
            return (
              null == o || i.test(o) || (o = null),
              { nodes: [{ type: 'number', number: parseFloat(r) || 0, unit: o }], remainingInput: l }
            )
          }
        })(),
        Yh = (() => {
          const t = /^[a-f0-9]*/i
          return (e) => {
            const i = (e = e.slice(1).trim()).match(t)
            return {
              nodes: null == i ? [] : [{ type: 'hex', value: i[0] }],
              remainingInput: null == i ? e : e.slice(i[0].length),
            }
          }
        })(),
        Jh = (t) => {
          const e = []
          for (t = t.slice(1).trim(); t.length; ) {
            const i = Wh(t)
            if ((e.push(i.nodes[0]), ',' === (t = i.remainingInput.trim())[0])) t = t.slice(1).trim()
            else if (')' === t[0]) {
              t = t.slice(1)
              break
            }
          }
          return { nodes: e, remainingInput: t }
        },
        Xh = Symbol('visitedTypes')
      class Kh {
        constructor(t) {
          this[Xh] = t
        }
        walk(t, e) {
          const i = t.slice()
          for (; i.length; ) {
            const t = i.shift()
            switch ((this[Xh].indexOf(t.type) > -1 && e(t), t.type)) {
              case 'expression':
                i.unshift(...t.terms)
                break
              case 'function':
                i.unshift(t.name, ...t.arguments)
            }
          }
        }
      }
      const Zh = Object.freeze({ type: 'number', number: 0, unit: null }),
        $h = (t, e = 0) => {
          let { number: i, unit: n } = t
          if (isFinite(i)) {
            if ('rad' === t.unit || null == t.unit) return t
          } else (i = e), (n = 'rad')
          return { type: 'number', number: (('deg' === n && null != i ? i : 0) * Math.PI) / 180, unit: 'rad' }
        },
        tu = (t, e = 0) => {
          let i,
            { number: n, unit: s } = t
          if (isFinite(n)) {
            if ('m' === t.unit) return t
          } else (n = e), (s = 'm')
          switch (s) {
            default:
              i = 1
              break
            case 'cm':
              i = 0.01
              break
            case 'mm':
              i = 0.001
          }
          return { type: 'number', number: i * n, unit: 'm' }
        },
        eu = (() => {
          const t = (t) => t,
            e = { rad: t, deg: $h, m: t, mm: tu, cm: tu }
          return (t, i = Zh) => {
            isFinite(t.number) || ((t.number = i.number), (t.unit = i.unit))
            const { unit: n } = t
            if (null == n) return t
            const s = e[n]
            return null == s ? i : s(t)
          }
        })()
      /* @license
       * Copyright 2019 Google LLC. All Rights Reserved.
       * Licensed under the Apache License, Version 2.0 (the 'License');
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *     http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an 'AS IS' BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */
      /* @license
       * Copyright 2020 Google LLC. All Rights Reserved.
       * Licensed under the Apache License, Version 2.0 (the 'License');
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *     http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an 'AS IS' BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class iu extends Sh {
        constructor(t) {
          super(document.createElement('div')),
            (this.normal = new Et(0, 1, 0)),
            (this.initialized = !1),
            (this.referenceCount = 1),
            (this.pivot = document.createElement('div')),
            (this.slot = document.createElement('slot')),
            this.element.classList.add('annotation-wrapper'),
            (this.slot.name = t.name),
            this.element.appendChild(this.pivot),
            this.pivot.appendChild(this.slot),
            this.updatePosition(t.position),
            this.updateNormal(t.normal)
        }
        get facingCamera() {
          return !this.element.classList.contains('hide')
        }
        show() {
          ;(this.facingCamera && this.initialized) || this.updateVisibility(!0)
        }
        hide() {
          ;(!this.facingCamera && this.initialized) || this.updateVisibility(!1)
        }
        increment() {
          this.referenceCount++
        }
        decrement() {
          return this.referenceCount > 0 && --this.referenceCount, 0 === this.referenceCount
        }
        updatePosition(t) {
          if (null == t) return
          const e = Hh(t)[0].terms
          for (let i = 0; i < 3; ++i) this.position.setComponent(i, eu(e[i]).number)
          this.updateMatrixWorld()
        }
        updateNormal(t) {
          if (null == t) return
          const e = Hh(t)[0].terms
          for (let i = 0; i < 3; ++i) this.normal.setComponent(i, eu(e[i]).number)
        }
        orient(t) {
          this.pivot.style.transform = `rotate(${t}rad)`
        }
        updateVisibility(t) {
          t ? this.element.classList.remove('hide') : this.element.classList.add('hide'),
            this.slot.assignedNodes().forEach((e) => {
              if (e.nodeType !== Node.ELEMENT_NODE) return
              const i = e,
                n = i.dataset.visibilityAttribute
              if (null != n) {
                const e = `data-${n}`
                t ? i.setAttribute(e, '') : i.removeAttribute(e)
              }
              i.dispatchEvent(new CustomEvent('hotspot-visibility', { detail: { visible: t } }))
            }),
            (this.initialized = !0)
          /* @license
           * Copyright 2019 Google LLC. All Rights Reserved.
           * Licensed under the Apache License, Version 2.0 (the 'License');
           * you may not use this file except in compliance with the License.
           * You may obtain a copy of the License at
           *
           *     http://www.apache.org/licenses/LICENSE-2.0
           *
           * Unless required by applicable law or agreed to in writing, software
           * distributed under the License is distributed on an 'AS IS' BASIS,
           * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
           * See the License for the specific language governing permissions and
           * limitations under the License.
           */
        }
      }
      const nu = (t, e, i) => {
        let n = i
        const s = new Et()
        return (
          t.traverse((t) => {
            let i, r
            t.updateWorldMatrix(!1, !1)
            const a = t.geometry
            if (void 0 !== a)
              if (a.isGeometry) {
                const o = a.vertices
                for (i = 0, r = o.length; i < r; i++) s.copy(o[i]), s.applyMatrix4(t.matrixWorld), (n = e(n, s))
              } else if (a.isBufferGeometry) {
                const { position: o } = a.attributes
                if (void 0 !== o) {
                  const a = ((t) => {
                    if (!t.normalized) return 1
                    const e = t.array
                    return e instanceof Int8Array
                      ? 1 / 127
                      : e instanceof Uint8Array
                      ? 1 / 255
                      : e instanceof Int16Array
                      ? 1 / 32767
                      : e instanceof Uint16Array
                      ? 1 / 65535
                      : 1
                  })(o)
                  for (i = 0, r = o.count; i < r; i++)
                    s.fromBufferAttribute(o, i), s.multiplyScalar(a), s.applyMatrix4(t.matrixWorld), (n = e(n, s))
                }
              }
          }),
          n
        )
      }
      class su extends yl {
        constructor(t, e, i) {
          super(),
            (this.shadowMaterial = new Bo()),
            (this.boundingBox = new Bt()),
            (this.size = new Et()),
            (this.shadowScale = 1),
            (this.isAnimated = !1),
            (this.side = 'bottom'),
            (this.needsUpdate = !1),
            (this.intensity = 0),
            (this.castShadow = !0),
            (this.frustumCulled = !1),
            (this.floor = new Si(new Ji(), this.shadowMaterial)),
            this.floor.rotateX(-Math.PI / 2),
            (this.floor.receiveShadow = !0),
            (this.floor.castShadow = !1),
            (this.floor.frustumCulled = !1),
            this.add(this.floor),
            t.target.add(this),
            (this.target = t.target),
            this.setScene(t, e, i)
        }
        setScene(t, e, i) {
          if (
            ((this.side = i),
            (this.isAnimated = t.animationNames.length > 0),
            this.boundingBox.copy(t.boundingBox),
            this.size.copy(t.size),
            'back' === this.side)
          ) {
            const { min: t, max: e } = this.boundingBox
            ;([t.y, t.z] = [t.z, t.y]),
              ([e.y, e.z] = [e.z, e.y]),
              ([this.size.y, this.size.z] = [this.size.z, this.size.y]),
              (this.rotation.x = Math.PI / 2),
              (this.rotation.y = Math.PI)
          }
          const { boundingBox: n, size: s } = this
          if (this.isAnimated) {
            const t = 2 * Math.max(s.x, s.y, s.z)
            ;(s.y = t), n.expandByVector(s.subScalar(t).multiplyScalar(-0.5)), (n.max.y = n.min.y + t), s.set(t, t, t)
          }
          n.getCenter(this.floor.position)
          const r = n.max.y + 0.002 * s.y
          'bottom' === i
            ? ((this.position.y = r), this.shadow.camera.up.set(0, 0, 1))
            : ((this.position.y = 0), (this.position.z = r), this.shadow.camera.up.set(0, 1, 0)),
            this.setSoftness(e)
        }
        setSoftness(t) {
          const e = Math.pow(2, 9 - 3 * t)
          this.setMapSize(e)
        }
        setMapSize(t) {
          const { camera: e, mapSize: i, map: n } = this.shadow,
            { size: s, boundingBox: r } = this
          null != n && (n.dispose(), (this.shadow.map = null)), this.isAnimated && (t *= 2)
          const a = Math.floor(s.x > s.z ? t : (t * s.x) / s.z),
            o = Math.floor(s.x > s.z ? (t * s.z) / s.x : t)
          i.set(a, o)
          const l = (2.5 * s.x) / a,
            c = (2.5 * s.z) / o
          ;(e.left = -r.max.x - l),
            (e.right = -r.min.x + l),
            (e.bottom = r.min.z - c),
            (e.top = r.max.z + c),
            this.setScaleAndOffset(this.shadowScale, 0),
            this.floor.scale.set(s.x + 2 * l, s.z + 2 * c, 1),
            (this.needsUpdate = !0)
        }
        setIntensity(t) {
          ;(this.shadowMaterial.opacity = t),
            t > 0 ? ((this.visible = !0), (this.floor.visible = !0)) : ((this.visible = !1), (this.floor.visible = !1))
        }
        getIntensity() {
          return this.shadowMaterial.opacity
        }
        setRotation(t) {
          'bottom' === this.side
            ? (this.shadow.camera.up.set(Math.sin(t), 0, Math.cos(t)), this.shadow.updateMatrices(this))
            : this.shadow.updateMatrices(this)
        }
        setScaleAndOffset(t, e) {
          const i = this.size.y,
            { camera: n } = this.shadow
          ;(this.shadowScale = t), (n.near = 0), (n.far = i - e / t), n.updateProjectionMatrix(), n.scale.setScalar(t)
          const s = 0.002 * i
          this.floor.position.y = 2 * s - n.far
        }
      }
      /* @license
       * Copyright 2019 Google LLC. All Rights Reserved.
       * Licensed under the Apache License, Version 2.0 (the 'License');
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *     http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an 'AS IS' BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ const ru = (22.5 * Math.PI) / 180,
        au = Math.sin(ru),
        ou = Math.tan(ru),
        lu = new Et(),
        cu = new Et(),
        hu = new Et(),
        uu = new (class {
          constructor(t, e, i = 0, n = 1 / 0) {
            ;(this.ray = new ie(t, e)),
              (this.near = i),
              (this.far = n),
              (this.camera = null),
              (this.layers = new Ae()),
              (this.params = { Mesh: {}, Line: { threshold: 1 }, LOD: {}, Points: { threshold: 1 }, Sprite: {} })
          }
          set(t, e) {
            this.ray.set(t, e)
          }
          setFromCamera(t, e) {
            e && e.isPerspectiveCamera
              ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld),
                this.ray.direction.set(t.x, t.y, 0.5).unproject(e).sub(this.ray.origin).normalize(),
                (this.camera = e))
              : e &&
                e.isOrthographicCamera &&
                (this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e),
                this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld),
                (this.camera = e))
          }
          intersectObject(t, e = !1, i = []) {
            return kl(t, this, i, e), i.sort(Ul), i
          }
          intersectObjects(t, e = !1, i = []) {
            for (let n = 0, s = t.length; n < s; n++) kl(t[n], this, i, e)
            return i.sort(Ul), i
          }
        })(),
        du = new Et()
      class pu extends Rr {
        constructor({ canvas: t, element: e, width: i, height: n }) {
          super(),
            (this.context = null),
            (this.annotationRenderer = new Rh()),
            (this.width = 1),
            (this.height = 1),
            (this.aspect = 1),
            (this.isDirty = !1),
            (this.renderCount = 0),
            (this.externalRenderer = null),
            (this.camera = new Ni(45, 1, 0.1, 100)),
            (this.xrCamera = null),
            (this.url = null),
            (this.target = new Se()),
            (this.modelContainer = new Se()),
            (this.animationNames = []),
            (this.boundingBox = new Bt()),
            (this.size = new Et()),
            (this.idealCameraDistance = 0),
            (this.fieldOfViewAspect = 0),
            (this.framedFieldOfView = 45),
            (this.shadow = null),
            (this.shadowIntensity = 0),
            (this.shadowSoftness = 1),
            (this.exposure = 1),
            (this.canScale = !0),
            (this.tightBounds = !1),
            (this.goalTarget = new Et()),
            (this.targetDamperX = new zh()),
            (this.targetDamperY = new zh()),
            (this.targetDamperZ = new zh()),
            (this._currentGLTF = null),
            (this.cancelPendingSourceChange = null),
            (this.animationsByName = new Map()),
            (this.currentAnimationAction = null),
            (this.name = 'ModelScene'),
            (this.element = e),
            (this.canvas = t),
            (this.camera = new Ni(45, 1, 0.1, 100)),
            (this.camera.name = 'MainCamera'),
            this.add(this.target),
            this.setSize(i, n),
            (this.target.name = 'Target'),
            (this.modelContainer.name = 'ModelContainer'),
            this.target.add(this.modelContainer),
            (this.mixer = new Fl(this.modelContainer))
          const { domElement: s } = this.annotationRenderer,
            { style: r } = s
          ;(r.display = 'none'),
            (r.pointerEvents = 'none'),
            (r.position = 'absolute'),
            (r.top = '0'),
            this.element.shadowRoot.querySelector('.default').appendChild(s)
        }
        createContext() {
          this.context = this.canvas.getContext('2d')
        }
        getCamera() {
          return null != this.xrCamera ? this.xrCamera : this.camera
        }
        async setObject(t) {
          this.reset(), this.modelContainer.add(t), await this.setupScene()
        }
        async setSource(t, e = () => {}) {
          if (!t || t === this.url) return void e(1)
          if ((this.reset(), (this.url = t), null != this.externalRenderer)) {
            const t = await this.externalRenderer.load(e)
            return (
              (this.idealCameraDistance = t.framedRadius / au),
              (this.fieldOfViewAspect = t.fieldOfViewAspect),
              this.frameModel(),
              void this.dispatchEvent({ type: 'model-load', url: this.url })
            )
          }
          let i
          null != this.cancelPendingSourceChange &&
            (this.cancelPendingSourceChange(), (this.cancelPendingSourceChange = null))
          try {
            i = await new Promise(async (i, n) => {
              this.cancelPendingSourceChange = () => n()
              try {
                i(await this.element[np].loader.load(t, this.element, e))
              } catch (t) {
                n(t)
              }
            })
          } catch (t) {
            if (null == t) return
            throw t
          }
          this.reset(), (this.url = t), (this._currentGLTF = i), null != i && this.modelContainer.add(i.scene)
          const { animations: n } = i,
            s = new Map(),
            r = []
          for (const a of n) s.set(a.name, a), r.push(a.name)
          ;(this.animations = n), (this.animationsByName = s), (this.animationNames = r), await this.setupScene()
        }
        async setupScene() {
          this.updateBoundingBox()
          let t = null
          !0 === this.tightBounds && (await this.element.requestUpdate('cameraTarget'), (t = this.getTarget())),
            this.updateFraming(t),
            this.frameModel(),
            this.setShadowIntensity(this.shadowIntensity),
            this.dispatchEvent({ type: 'model-load', url: this.url })
        }
        reset() {
          ;(this.url = null), (this.isDirty = !0), null != this.shadow && this.shadow.setIntensity(0)
          const t = this._currentGLTF
          if (null != t) {
            for (const t of this.modelContainer.children) this.modelContainer.remove(t)
            t.dispose(), (this._currentGLTF = null)
          }
          null != this.currentAnimationAction &&
            (this.currentAnimationAction.stop(), (this.currentAnimationAction = null)),
            this.mixer.stopAllAction(),
            this.mixer.uncacheRoot(this)
        }
        get currentGLTF() {
          return this._currentGLTF
        }
        setSize(t, e) {
          if (this.width !== t || this.height !== e) {
            if (
              ((this.width = Math.max(t, 1)),
              (this.height = Math.max(e, 1)),
              this.annotationRenderer.setSize(t, e),
              (this.aspect = this.width / this.height),
              this.frameModel(),
              null != this.externalRenderer)
            ) {
              const i = Oh()
              this.externalRenderer.resize(t * i, e * i)
            }
            this.isDirty = !0
          }
        }
        updateBoundingBox() {
          if ((this.target.remove(this.modelContainer), !0 === this.tightBounds)) {
            const t = (t, e) => t.expandByPoint(e)
            this.boundingBox = nu(this.modelContainer, t, new Bt())
          } else this.boundingBox.setFromObject(this.modelContainer)
          this.boundingBox.getSize(this.size), this.target.add(this.modelContainer)
        }
        updateFraming(t = null) {
          this.target.remove(this.modelContainer), null == t && (t = this.boundingBox.getCenter(new Et()))
          const e = Math.sqrt(nu(this.modelContainer, (e, i) => Math.max(e, t.distanceToSquared(i)), 0))
          ;(this.idealCameraDistance = e / au),
            (this.fieldOfViewAspect =
              nu(
                this.modelContainer,
                (e, i) => {
                  i.sub(t)
                  const n = Math.sqrt(i.x * i.x + i.z * i.z)
                  return Math.max(e, n / (this.idealCameraDistance - Math.abs(i.y)))
                },
                0,
              ) / ou),
            this.target.add(this.modelContainer)
        }
        frameModel() {
          const t = ou * Math.max(1, this.fieldOfViewAspect / this.aspect)
          this.framedFieldOfView = (2 * Math.atan(t) * 180) / Math.PI
        }
        getSize() {
          return { width: this.width, height: this.height }
        }
        setTarget(t, e, i) {
          this.goalTarget.set(-t, -e, -i)
        }
        setTargetDamperDecayTime(t) {
          this.targetDamperX.setDecayTime(t), this.targetDamperY.setDecayTime(t), this.targetDamperZ.setDecayTime(t)
        }
        getTarget() {
          return du.copy(this.goalTarget).multiplyScalar(-1)
        }
        jumpToGoal() {
          this.updateTarget(1e4)
        }
        updateTarget(t) {
          const e = this.goalTarget,
            i = this.target.position
          if (!e.equals(i)) {
            const n = this.idealCameraDistance
            let { x: s, y: r, z: a } = i
            ;(s = this.targetDamperX.update(s, e.x, t, n)),
              (r = this.targetDamperY.update(r, e.y, t, n)),
              (a = this.targetDamperZ.update(a, e.z, t, n)),
              this.target.position.set(s, r, a),
              this.target.updateMatrixWorld(),
              this.setShadowRotation(this.yaw),
              (this.isDirty = !0)
          }
        }
        pointTowards(t, e) {
          const { x: i, z: n } = this.position
          this.yaw = Math.atan2(t - i, e - n)
        }
        set yaw(t) {
          ;(this.rotation.y = t), this.updateMatrixWorld(!0), this.setShadowRotation(t), (this.isDirty = !0)
        }
        get yaw() {
          return this.rotation.y
        }
        set animationTime(t) {
          this.mixer.setTime(t)
        }
        get animationTime() {
          return null != this.currentAnimationAction ? this.currentAnimationAction.time : 0
        }
        get duration() {
          return null != this.currentAnimationAction && this.currentAnimationAction.getClip()
            ? this.currentAnimationAction.getClip().duration
            : 0
        }
        get hasActiveAnimation() {
          return null != this.currentAnimationAction
        }
        playAnimation(t = null, e = 0) {
          if (null == this._currentGLTF) return
          const { animations: i } = this
          if (null == i || 0 === i.length) return
          let n = null
          null != t && (n = this.animationsByName.get(t)), null == n && (n = i[0])
          try {
            const { currentAnimationAction: t } = this
            ;(this.currentAnimationAction = this.mixer.clipAction(n, this).play()),
              (this.currentAnimationAction.enabled = !0),
              null != t && this.currentAnimationAction !== t && this.currentAnimationAction.crossFadeFrom(t, e, !1)
          } catch (t) {}
        }
        stopAnimation() {
          null != this.currentAnimationAction &&
            (this.currentAnimationAction.stop(),
            this.currentAnimationAction.reset(),
            (this.currentAnimationAction = null)),
            this.mixer.stopAllAction()
        }
        updateAnimation(t) {
          this.mixer.update(t)
        }
        updateShadow() {
          const t = this.shadow
          if (null != t) {
            const e = 'wall' === this.element.arPlacement ? 'back' : 'bottom'
            t.setScene(this, this.shadowSoftness, e)
          }
        }
        setShadowIntensity(t) {
          if (((this.shadowIntensity = t), null == this._currentGLTF)) return
          let e = this.shadow
          const i = 'wall' === this.element.arPlacement ? 'back' : 'bottom'
          null != e
            ? (e.setIntensity(t), e.setScene(this, this.shadowSoftness, i))
            : t > 0 && ((e = new su(this, this.shadowSoftness, i)), e.setIntensity(t), (this.shadow = e))
        }
        setShadowSoftness(t) {
          this.shadowSoftness = t
          const e = this.shadow
          null != e && e.setSoftness(t)
        }
        setShadowRotation(t) {
          const e = this.shadow
          null != e && e.setRotation(t)
        }
        isShadowDirty() {
          const t = this.shadow
          if (null == t) return !1
          {
            const { needsUpdate: e } = t
            return (t.needsUpdate = !1), e
          }
        }
        setShadowScaleAndOffset(t, e) {
          const i = this.shadow
          null != i && i.setScaleAndOffset(t, e)
        }
        positionAndNormalFromPoint(t, e = this) {
          uu.setFromCamera(t, this.getCamera())
          const i = uu.intersectObject(e, !0)
          if (0 === i.length) return null
          const n = i[0]
          return null == n.face
            ? null
            : (n.face.normal.applyNormalMatrix(new mt().getNormalMatrix(n.object.matrixWorld)),
              { position: n.point, normal: n.face.normal })
        }
        addHotspot(t) {
          this.target.add(t), this.annotationRenderer.domElement.appendChild(t.element)
        }
        removeHotspot(t) {
          this.target.remove(t)
        }
        forHotspots(t) {
          const { children: e } = this.target
          for (let i = 0, n = e.length; i < n; i++) {
            const n = e[i]
            n instanceof iu && t(n)
          }
        }
        updateHotspots(t) {
          this.forHotspots((e) => {
            lu.copy(t),
              cu.setFromMatrixPosition(e.matrixWorld),
              lu.sub(cu),
              hu.copy(e.normal).transformDirection(this.target.matrixWorld),
              lu.dot(hu) < 0 ? e.hide() : e.show()
          })
        }
        orientHotspots(t) {
          this.forHotspots((e) => {
            e.orient(t)
          })
        }
        setHotspotsVisibility(t) {
          this.forHotspots((e) => {
            e.visible = t
          })
        }
      }
      const Au = (function () {
          const t = new on({
            uniforms: { roughnessMap: { value: null }, normalMap: { value: null }, texelSize: { value: new gt(1, 1) } },
            vertexShader:
              '\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tattribute vec3 position;\n\t\t\tattribute vec2 uv;\n\n\t\t\tvarying vec2 vUv;\n\n\t\t\tvoid main() {\n\n\t\t\t\tvUv = uv;\n\n\t\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t\t}\n\t\t',
            fragmentShader:
              '\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec2 vUv;\n\n\t\t\tuniform sampler2D roughnessMap;\n\t\t\tuniform sampler2D normalMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\n\t\t\tvec4 envMapTexelToLinear( vec4 a ) { return a; }\n\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tfloat roughnessToVariance( float roughness ) {\n\n\t\t\t\tfloat variance = 0.0;\n\n\t\t\t\tif ( roughness >= r1 ) {\n\n\t\t\t\t\tvariance = ( r0 - roughness ) * ( v1 - v0 ) / ( r0 - r1 ) + v0;\n\n\t\t\t\t} else if ( roughness >= r4 ) {\n\n\t\t\t\t\tvariance = ( r1 - roughness ) * ( v4 - v1 ) / ( r1 - r4 ) + v1;\n\n\t\t\t\t} else if ( roughness >= r5 ) {\n\n\t\t\t\t\tvariance = ( r4 - roughness ) * ( v5 - v4 ) / ( r4 - r5 ) + v4;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tfloat roughness2 = roughness * roughness;\n\n\t\t\t\t\tvariance = 1.79 * roughness2 * roughness2;\n\n\t\t\t\t}\n\n\t\t\t\treturn variance;\n\n\t\t\t}\n\n\t\t\tfloat varianceToRoughness( float variance ) {\n\n\t\t\t\tfloat roughness = 0.0;\n\n\t\t\t\tif ( variance >= v1 ) {\n\n\t\t\t\t\troughness = ( v0 - variance ) * ( r1 - r0 ) / ( v0 - v1 ) + r0;\n\n\t\t\t\t} else if ( variance >= v4 ) {\n\n\t\t\t\t\troughness = ( v1 - variance ) * ( r4 - r1 ) / ( v1 - v4 ) + r1;\n\n\t\t\t\t} else if ( variance >= v5 ) {\n\n\t\t\t\t\troughness = ( v4 - variance ) * ( r5 - r4 ) / ( v4 - v5 ) + r4;\n\n\t\t\t\t} else {\n\n\t\t\t\t\troughness = pow( 0.559 * variance, 0.25 ); // 0.559 = 1.0 / 1.79\n\n\t\t\t\t}\n\n\t\t\t\treturn roughness;\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = texture2D( roughnessMap, vUv, - 1.0 );\n\n\t\t\t\tif ( texelSize.x == 0.0 ) return;\n\n\t\t\t\tfloat roughness = gl_FragColor.g;\n\n\t\t\t\tfloat variance = roughnessToVariance( roughness );\n\n\t\t\t\tvec3 avgNormal;\n\n\t\t\t\tfor ( float x = - 1.0; x < 2.0; x += 2.0 ) {\n\n\t\t\t\t\tfor ( float y = - 1.0; y < 2.0; y += 2.0 ) {\n\n\t\t\t\t\t\tvec2 uv = vUv + vec2( x, y ) * 0.25 * texelSize;\n\n\t\t\t\t\t\tavgNormal += normalize( texture2D( normalMap, uv, - 1.0 ).xyz - 0.5 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvariance += 1.0 - 0.25 * length( avgNormal );\n\n\t\t\t\tgl_FragColor.g = varianceToRoughness( variance );\n\n\t\t\t}\n\t\t',
            blending: 0,
            depthTest: !1,
            depthWrite: !1,
          })
          return (t.type = 'RoughnessMipmapper'), t
        })(),
        /* @license
         * Copyright 2019 Google LLC. All Rights Reserved.
         * Licensed under the Apache License, Version 2.0 (the 'License');
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *     http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an 'AS IS' BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        gu = new Si(new Ji(2, 2), Au),
        mu = new an(0, 1, 0, 1, 0, 1)
      let fu = null,
        vu = null
      class yu {
        constructor(t) {
          ;(vu = t), vu.compile(gu, mu)
        }
        generateMipmaps(t) {
          if ('roughnessMap' in t == 0) return
          const { roughnessMap: e, normalMap: i } = t
          if (null === e || null === i || !e.generateMipmaps || t.userData.roughnessUpdated) return
          t.userData.roughnessUpdated = !0
          let n = Math.max(e.image.width, i.image.width),
            s = Math.max(e.image.height, i.image.height)
          if (!At.isPowerOfTwo(n) || !At.isPowerOfTwo(s)) return
          const r = vu.getRenderTarget(),
            a = vu.autoClear
          if (
            ((vu.autoClear = !1),
            (null !== fu && fu.width === n && fu.height === s) ||
              (null !== fu && fu.dispose(), (fu = new It(n, s, { depthBuffer: !1 })), (fu.scissorTest = !0)),
            n !== e.image.width || s !== e.image.height)
          ) {
            const i = {
                wrapS: e.wrapS,
                wrapT: e.wrapT,
                magFilter: e.magFilter,
                minFilter: e.minFilter,
                depthBuffer: !1,
              },
              r = new It(n, s, i)
            ;(r.texture.generateMipmaps = !0),
              vu.setRenderTarget(r),
              (t.roughnessMap = r.texture),
              t.metalnessMap == e && (t.metalnessMap = t.roughnessMap),
              t.aoMap == e && (t.aoMap = t.roughnessMap),
              t.roughnessMap.offset.copy(e.offset),
              t.roughnessMap.repeat.copy(e.repeat),
              t.roughnessMap.center.copy(e.center),
              (t.roughnessMap.rotation = e.rotation),
              (t.roughnessMap.matrixAutoUpdate = e.matrixAutoUpdate),
              t.roughnessMap.matrix.copy(e.matrix)
          }
          ;(Au.uniforms.roughnessMap.value = e), (Au.uniforms.normalMap.value = i)
          const o = new gt(0, 0),
            l = Au.uniforms.texelSize.value
          for (let c = 0; n >= 1 && s >= 1; ++c, n /= 2, s /= 2)
            l.set(1 / n, 1 / s),
              0 == c && l.set(0, 0),
              fu.viewport.set(o.x, o.y, n, s),
              fu.scissor.set(o.x, o.y, n, s),
              vu.setRenderTarget(fu),
              vu.render(gu, mu),
              vu.copyFramebufferToTexture(o, t.roughnessMap, c),
              (Au.uniforms.roughnessMap.value = t.roughnessMap)
          e !== t.roughnessMap && e.dispose(), vu.setRenderTarget(r), (vu.autoClear = a)
        }
        dispose() {
          Au.dispose(), gu.geometry.dispose(), null != fu && fu.dispose()
        }
      }
      var xu = function (t, e, i, n) {
        for (
          var s,
            r = arguments.length,
            a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n,
            o = t.length - 1;
          o >= 0;
          o--
        )
          (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a)
        return r > 3 && a && Object.defineProperty(e, i, a), a
      }
      const wu = Symbol('currentEnvironmentMap'),
        _u = Symbol('applyEnvironmentMap'),
        Iu = Symbol('updateEnvironment'),
        Cu = Symbol('cancelEnvironmentUpdate'),
        Mu = Symbol('onPreload')
      class Eu {
        constructor(t, e, i, n, s) {
          ;(this.xrLight = t),
            (this.renderer = e),
            (this.lightProbe = i),
            (this.xrWebGLBinding = null),
            (this.estimationStartCallback = s),
            (this.frameCallback = this.onXRFrame.bind(this))
          const r = e.xr.getSession()
          if (n && 'XRWebGLBinding' in window) {
            const i = new ki(16)
            t.environment = i.texture
            const n = e.getContext()
            switch (r.preferredReflectionFormat) {
              case 'srgba8':
                n.getExtension('EXT_sRGB')
                break
              case 'rgba16f':
                n.getExtension('OES_texture_half_float')
            }
            ;(this.xrWebGLBinding = new XRWebGLBinding(r, n)),
              this.lightProbe.addEventListener('reflectionchange', () => {
                this.updateReflection()
              })
          }
          r.requestAnimationFrame(this.frameCallback)
        }
        updateReflection() {
          const t = this.renderer.properties.get(this.xrLight.environment)
          if (t) {
            const e = this.xrWebGLBinding.getReflectionCubeMap(this.lightProbe)
            e && (t.__webglTexture = e)
          }
        }
        onXRFrame(t, e) {
          if (!this.xrLight) return
          e.session.requestAnimationFrame(this.frameCallback)
          const i = e.getLightEstimate(this.lightProbe)
          if (i) {
            this.xrLight.lightProbe.sh.fromArray(i.sphericalHarmonicsCoefficients),
              (this.xrLight.lightProbe.intensity = 1)
            const t = Math.max(
              1,
              Math.max(i.primaryLightIntensity.x, Math.max(i.primaryLightIntensity.y, i.primaryLightIntensity.z)),
            )
            this.xrLight.directionalLight.color.setRGB(
              i.primaryLightIntensity.x / t,
              i.primaryLightIntensity.y / t,
              i.primaryLightIntensity.z / t,
            ),
              (this.xrLight.directionalLight.intensity = t),
              this.xrLight.directionalLight.position.copy(i.primaryLightDirection),
              this.estimationStartCallback && (this.estimationStartCallback(), (this.estimationStartCallback = null))
          }
        }
        dispose() {
          ;(this.xrLight = null), (this.renderer = null), (this.lightProbe = null), (this.xrWebGLBinding = null)
        }
      }
      class bu extends Sr {
        constructor(t, e = !0) {
          super(),
            (this.lightProbe = new wl()),
            (this.lightProbe.intensity = 0),
            this.add(this.lightProbe),
            (this.directionalLight = new yl()),
            (this.directionalLight.intensity = 0),
            this.add(this.directionalLight),
            (this.environment = null)
          let i = null,
            n = !1
          t.xr.addEventListener('sessionstart', () => {
            const s = t.xr.getSession()
            'requestLightProbe' in s &&
              s.requestLightProbe({ reflectionFormat: s.preferredReflectionFormat }).then((s) => {
                i = new Eu(this, t, s, e, () => {
                  ;(n = !0), this.dispatchEvent({ type: 'estimationstart' })
                })
              })
          }),
            t.xr.addEventListener('sessionend', () => {
              i && (i.dispose(), (i = null)), n && this.dispatchEvent({ type: 'estimationend' })
            }),
            (this.dispose = () => {
              i && (i.dispose(), (i = null)),
                this.remove(this.lightProbe),
                (this.lightProbe = null),
                this.remove(this.directionalLight),
                (this.directionalLight = null),
                (this.environment = null)
            })
        }
      }
      /* @license
       * Copyright 2020 Google LLC. All Rights Reserved.
       * Licensed under the Apache License, Version 2.0 (the 'License');
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *     http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an 'AS IS' BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ const Su = Math.PI / 24,
        Bu = new gt(),
        Tu = (t, e, i) => {
          let n = e > 0 ? (i > 0 ? 0 : -Math.PI / 2) : i > 0 ? Math.PI / 2 : Math.PI
          for (let s = 0; s <= 12; ++s)
            t.push(e + 0.17 * Math.cos(n), i + 0.17 * Math.sin(n), 0, e + 0.2 * Math.cos(n), i + 0.2 * Math.sin(n), 0),
              (n += Su)
        }
      class Lu extends Si {
        constructor(t, e) {
          const i = new hi(),
            n = [],
            s = [],
            { size: r, boundingBox: a } = t,
            o = r.x / 2,
            l = ('back' === e ? r.y : r.z) / 2
          Tu(s, o, l), Tu(s, -o, l), Tu(s, -o, -l), Tu(s, o, -l)
          const c = s.length / 3
          for (let d = 0; d < c - 2; d += 2) n.push(d, d + 1, d + 3, d, d + 3, d + 2)
          const h = c - 2
          n.push(h, h + 1, 1, h, 1, 0),
            i.setAttribute('position', new ei(s, 3)),
            i.setIndex(n),
            super(i),
            (this.side = e)
          const u = this.material
          switch (
            ((u.side = 2),
            (u.transparent = !0),
            (u.opacity = 0),
            (this.goalOpacity = 0),
            (this.opacityDamper = new zh()),
            (this.hitPlane = new Si(new Ji(2 * (o + 0.2), 2 * (l + 0.2)))),
            (this.hitPlane.visible = !1),
            this.add(this.hitPlane),
            a.getCenter(this.position),
            e)
          ) {
            case 'bottom':
              this.rotateX(-Math.PI / 2), (this.shadowHeight = a.min.y), (this.position.y = this.shadowHeight)
              break
            case 'back':
              ;(this.shadowHeight = a.min.z), (this.position.z = this.shadowHeight)
          }
          t.target.add(this)
        }
        getHit(t, e, i) {
          Bu.set(e, -i), (this.hitPlane.visible = !0)
          const n = t.positionAndNormalFromPoint(Bu, this.hitPlane)
          return (this.hitPlane.visible = !1), null == n ? null : n.position
        }
        getExpandedHit(t, e, i) {
          this.hitPlane.scale.set(1e3, 1e3, 1e3)
          const n = this.getHit(t, e, i)
          return this.hitPlane.scale.set(1, 1, 1), n
        }
        set offsetHeight(t) {
          'back' === this.side ? (this.position.z = this.shadowHeight + t) : (this.position.y = this.shadowHeight + t)
        }
        get offsetHeight() {
          return 'back' === this.side ? this.position.z - this.shadowHeight : this.position.y - this.shadowHeight
        }
        set show(t) {
          this.goalOpacity = t ? 0.75 : 0
        }
        updateOpacity(t) {
          const e = this.material
          ;(e.opacity = this.opacityDamper.update(e.opacity, this.goalOpacity, t, 1)), (this.visible = e.opacity > 0)
        }
        dispose() {
          var t
          const { geometry: e, material: i } = this.hitPlane
          e.dispose(),
            i.dispose(),
            this.geometry.dispose(),
            this.material.dispose(),
            null === (t = this.parent) || void 0 === t || t.remove(this)
        }
      }
      /* @license
       * Copyright 2019 Google LLC. All Rights Reserved.
       * Licensed under the Apache License, Version 2.0 (the 'License');
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *     http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an 'AS IS' BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ const Du = 'not-presenting',
        Qu = 'session-started',
        Ru = 'tracking',
        Pu = new Et(),
        Nu = new ne(),
        Fu = new Et(),
        Uu = new Ni(45, 1, 0.1, 100)
      class ku extends it {
        constructor(t) {
          super(),
            (this.renderer = t),
            (this.currentSession = null),
            (this.placeOnWall = !1),
            (this.placementBox = null),
            (this.lastTick = null),
            (this.turntableRotation = null),
            (this.oldShadowIntensity = null),
            (this.oldBackground = null),
            (this.oldEnvironment = null),
            (this.frame = null),
            (this.initialHitSource = null),
            (this.transientHitTestSource = null),
            (this.inputSource = null),
            (this._presentedScene = null),
            (this.resolveCleanup = null),
            (this.exitWebXRButtonContainer = null),
            (this.overlay = null),
            (this.xrLight = null),
            (this.environmentEstimation = !1),
            (this.tracking = !0),
            (this.frames = 0),
            (this.initialized = !1),
            (this.oldTarget = new Et()),
            (this.oldFramedFieldOfView = 45),
            (this.placementComplete = !1),
            (this.isTranslating = !1),
            (this.isRotating = !1),
            (this.isTwoFingering = !1),
            (this.lastDragPosition = new Et()),
            (this.firstRatio = 0),
            (this.lastAngle = 0),
            (this.goalPosition = new Et()),
            (this.goalYaw = 0),
            (this.goalScale = 1),
            (this.xDamper = new zh()),
            (this.yDamper = new zh()),
            (this.zDamper = new zh()),
            (this.yawDamper = new zh()),
            (this.scaleDamper = new zh()),
            (this.onExitWebXRButtonContainerClick = () => this.stopPresenting()),
            (this.onUpdateScene = () => {
              null != this.placementBox &&
                this.isPresenting &&
                (this.placementBox.dispose(),
                (this.placementBox = new Lu(this.presentedScene, this.placeOnWall ? 'back' : 'bottom')))
            }),
            (this.onSelectStart = (t) => {
              const e = this.transientHitTestSource
              if (null == e) return
              const i = this.frame.getHitTestResultsForTransientInput(e),
                n = this.presentedScene,
                s = this.placementBox
              if (1 === i.length) {
                this.inputSource = t.inputSource
                const { axes: e } = this.inputSource.gamepad,
                  i = s.getHit(this.presentedScene, e[0], e[1])
                ;(s.show = !0),
                  null != i
                    ? ((this.isTranslating = !0), this.lastDragPosition.copy(i))
                    : !1 === this.placeOnWall && ((this.isRotating = !0), (this.lastAngle = 1.5 * e[0]))
              } else if (2 === i.length) {
                ;(s.show = !0), (this.isTwoFingering = !0)
                const { separation: t } = this.fingerPolar(i)
                this.firstRatio = t / n.scale.x
              }
            }),
            (this.onSelectEnd = () => {
              ;(this.isTranslating = !1),
                (this.isRotating = !1),
                (this.isTwoFingering = !1),
                (this.inputSource = null),
                (this.goalPosition.y += this.placementBox.offsetHeight * this.presentedScene.scale.x),
                (this.placementBox.show = !1)
            }),
            (this.threeRenderer = t.threeRenderer),
            (this.threeRenderer.xr.enabled = !0),
            (this.xrLight = new bu(this.threeRenderer)),
            this.xrLight.addEventListener('estimationstart', () => {
              if (!this.isPresenting || null == this.xrLight) return
              const t = this.presentedScene
              t.add(this.xrLight),
                this.environmentEstimation &&
                  this.xrLight.environment &&
                  ((this.oldEnvironment = t.environment), (t.environment = this.xrLight.environment))
            })
        }
        async resolveARSession() {
          Nh()
          const t = await navigator.xr.requestSession('immersive-ar', {
            requiredFeatures: ['hit-test'],
            optionalFeatures: ['dom-overlay', 'light-estimation'],
            domOverlay: { root: this.overlay },
          })
          return (
            this.threeRenderer.xr.setReferenceSpaceType('local'),
            await this.threeRenderer.xr.setSession(t),
            (this.threeRenderer.xr.cameraAutoUpdate = !1),
            t
          )
        }
        get presentedScene() {
          return this._presentedScene
        }
        async supportsPresentation() {
          try {
            return Nh(), await navigator.xr.isSessionSupported('immersive-ar')
          } catch (n) {
            return !1
          }
        }
        async present(t, e = !1) {
          this.isPresenting
          let i = new Promise((t, e) => {
            requestAnimationFrame(() => t())
          })
          t.setHotspotsVisibility(!1),
            (t.isDirty = !0),
            await i,
            (this._presentedScene = t),
            (this.overlay = t.element.shadowRoot.querySelector('div.default')),
            (this.environmentEstimation = e)
          const n = await this.resolveARSession()
          n.addEventListener(
            'end',
            () => {
              this.postSessionCleanup()
            },
            { once: !0 },
          )
          const s = t.element.shadowRoot.querySelector('.slot.exit-webxr-ar-button')
          s.classList.add('enabled'),
            s.addEventListener('click', this.onExitWebXRButtonContainerClick),
            (this.exitWebXRButtonContainer = s)
          const r = await n.requestReferenceSpace('viewer')
          ;(this.tracking = !0),
            (this.frames = 0),
            (this.initialized = !1),
            (this.turntableRotation = t.yaw),
            (this.goalYaw = t.yaw),
            (this.goalScale = 1),
            (this.oldBackground = t.background),
            (t.background = null),
            (this.oldShadowIntensity = t.shadowIntensity),
            t.setShadowIntensity(0),
            this.oldTarget.copy(t.getTarget()),
            (this.oldFramedFieldOfView = t.framedFieldOfView),
            t.addEventListener('model-load', this.onUpdateScene)
          const a = (20 * Math.PI) / 180,
            o =
              !0 === this.placeOnWall
                ? void 0
                : new XRRay(new DOMPoint(0, 0, 0), { x: 0, y: -Math.sin(a), z: -Math.cos(a) })
          n.requestHitTestSource({ space: r, offsetRay: o }).then((t) => {
            this.initialHitSource = t
          }),
            (this.currentSession = n),
            (this.placementBox = new Lu(t, this.placeOnWall ? 'back' : 'bottom')),
            (this.placementComplete = !1),
            (this.lastTick = performance.now()),
            this.dispatchEvent({ type: 'status', status: Qu })
        }
        async stopPresenting() {
          if (!this.isPresenting) return
          const t = new Promise((t) => {
            this.resolveCleanup = t
          })
          try {
            await this.currentSession.end(), await t
          } catch (t) {
            this.postSessionCleanup()
          }
        }
        get isPresenting() {
          return null != this.presentedScene
        }
        get target() {
          return this.oldTarget
        }
        updateTarget() {
          const t = this.presentedScene
          if (null != t) {
            const e = t.getTarget()
            this.oldTarget.copy(e),
              this.placeOnWall ? (e.z = t.boundingBox.min.z) : (e.y = t.boundingBox.min.y),
              t.setTarget(e.x, e.y, e.z)
          }
        }
        postSessionCleanup() {
          const t = this.currentSession
          null != t &&
            (t.removeEventListener('selectstart', this.onSelectStart),
            t.removeEventListener('selectend', this.onSelectEnd),
            (this.currentSession = null))
          const e = this.presentedScene
          if (null != e) {
            const { element: t } = e
            null != this.xrLight &&
              null != this.xrLight.parent &&
              (e.remove(this.xrLight),
              null != this.oldEnvironment && ((e.environment = this.oldEnvironment), (this.oldEnvironment = null))),
              e.position.set(0, 0, 0),
              e.scale.set(1, 1, 1),
              e.setShadowScaleAndOffset(1, 0)
            const i = this.turntableRotation
            null != i && (e.yaw = i)
            const n = this.oldShadowIntensity
            null != n && e.setShadowIntensity(n)
            const s = this.oldBackground
            null != s && (e.background = s)
            const r = this.oldTarget
            e.setTarget(r.x, r.y, r.z),
              (e.framedFieldOfView = this.oldFramedFieldOfView),
              (e.xrCamera = null),
              e.removeEventListener('model-load', this.onUpdateScene),
              e.orientHotspots(0),
              t.requestUpdate('cameraTarget'),
              t.requestUpdate('maxCameraOrbit'),
              t[ip](t.getBoundingClientRect())
          }
          this.renderer.height = 0
          const i = this.exitWebXRButtonContainer
          null != i &&
            (i.classList.remove('enabled'),
            i.removeEventListener('click', this.onExitWebXRButtonContainerClick),
            (this.exitWebXRButtonContainer = null))
          const n = this.transientHitTestSource
          null != n && (n.cancel(), (this.transientHitTestSource = null))
          const s = this.initialHitSource
          null != s && (s.cancel(), (this.initialHitSource = null)),
            null != this.placementBox && (this.placementBox.dispose(), (this.placementBox = null)),
            (this.lastTick = null),
            (this.turntableRotation = null),
            (this.oldShadowIntensity = null),
            (this.oldBackground = null),
            (this._presentedScene = null),
            (this.frame = null),
            (this.inputSource = null),
            (this.overlay = null),
            null != this.resolveCleanup && this.resolveCleanup(),
            this.dispatchEvent({ type: 'status', status: Du })
        }
        updateView(t) {
          const e = this.presentedScene,
            i = this.threeRenderer.xr
          i.updateCamera(Uu), (e.xrCamera = i.getCamera())
          const { elements: n } = e.getCamera().matrixWorld
          if (
            (e.orientHotspots(Math.atan2(n[1], n[5])),
            this.initialized || (this.placeInitially(), (this.initialized = !0)),
            t.requestViewportScale && t.recommendedViewportScale)
          ) {
            const e = t.recommendedViewportScale
            t.requestViewportScale(Math.max(e, 0.25))
          }
          const s = this.currentSession.renderState.baseLayer.getViewport(t)
          this.threeRenderer.setViewport(s.x, s.y, s.width, s.height)
        }
        placeInitially() {
          const t = this.presentedScene,
            { position: e, element: i } = t,
            n = t.getCamera(),
            { width: s, height: r } = this.overlay.getBoundingClientRect()
          t.setSize(s, r), n.projectionMatrixInverse.copy(n.projectionMatrix).invert()
          const { theta: a, radius: o } = i.getCameraOrbit(),
            l = n.getWorldDirection(Pu)
          ;(t.yaw = Math.atan2(-l.x, -l.z) - a),
            (this.goalYaw = t.yaw),
            e.copy(n.position).add(l.multiplyScalar(o)),
            this.updateTarget()
          const c = t.getTarget()
          e.add(c).sub(this.oldTarget), this.goalPosition.copy(e), t.setHotspotsVisibility(!0)
          const { session: h } = this.frame
          h.addEventListener('selectstart', this.onSelectStart),
            h.addEventListener('selectend', this.onSelectEnd),
            h.requestHitTestSourceForTransientInput({ profile: 'generic-touchscreen' }).then((t) => {
              this.transientHitTestSource = t
            })
        }
        getTouchLocation() {
          const { axes: t } = this.inputSource.gamepad
          let e = this.placementBox.getExpandedHit(this.presentedScene, t[0], t[1])
          return null != e && (Pu.copy(e).sub(this.presentedScene.getCamera().position), Pu.length() > 10) ? null : e
        }
        getHitPoint(t) {
          const e = this.threeRenderer.xr.getReferenceSpace(),
            i = t.getPose(e)
          if (null == i) return null
          const n = Nu.fromArray(i.transform.matrix)
          return (
            !0 === this.placeOnWall && (this.goalYaw = Math.atan2(n.elements[4], n.elements[6])),
            n.elements[5] > 0.75 !== this.placeOnWall ? Fu.setFromMatrixPosition(n) : null
          )
        }
        moveToFloor(t) {
          const e = this.initialHitSource
          if (null == e) return
          const i = t.getHitTestResults(e)
          if (0 == i.length) return
          const n = i[0],
            s = this.getHitPoint(n)
          null != s &&
            ((this.placementBox.show = !0),
            this.isTranslating || (this.placeOnWall ? this.goalPosition.copy(s) : (this.goalPosition.y = s.y)),
            e.cancel(),
            (this.initialHitSource = null),
            this.dispatchEvent({ type: 'status', status: 'object-placed' }))
        }
        fingerPolar(t) {
          const e = t[0].inputSource.gamepad.axes,
            i = t[1].inputSource.gamepad.axes,
            n = i[0] - e[0],
            s = i[1] - e[1],
            r = Math.atan2(s, n)
          let a = this.lastAngle - r
          return (
            a > Math.PI ? (a -= 2 * Math.PI) : a < -Math.PI && (a += 2 * Math.PI),
            (this.lastAngle = r),
            { separation: Math.sqrt(n * n + s * s), deltaYaw: a }
          )
        }
        processInput(t) {
          const e = this.transientHitTestSource
          if (null == e) return
          if (!this.isTranslating && !this.isTwoFingering && !this.isRotating) return
          const i = t.getHitTestResultsForTransientInput(e),
            n = this.presentedScene,
            s = n.scale.x
          if (this.isTwoFingering)
            if (i.length < 2) this.isTwoFingering = !1
            else {
              const { separation: t, deltaYaw: e } = this.fingerPolar(i)
              if ((!1 === this.placeOnWall && (this.goalYaw += e), n.canScale)) {
                const e = t / this.firstRatio
                this.goalScale = e < 1.3 && e > 0.7692307692307692 ? 1 : e
              }
            }
          else if (2 !== i.length)
            if (this.isRotating) {
              const t = 1.5 * this.inputSource.gamepad.axes[0]
              ;(this.goalYaw += t - this.lastAngle), (this.lastAngle = t)
            } else
              this.isTranslating &&
                i.forEach((t) => {
                  if (t.inputSource !== this.inputSource) return
                  let e = null
                  if (
                    (t.results.length > 0 && (e = this.getHitPoint(t.results[0])),
                    null == e && (e = this.getTouchLocation()),
                    null != e)
                  ) {
                    if ((this.goalPosition.sub(this.lastDragPosition), !1 === this.placeOnWall)) {
                      const t = e.y - this.lastDragPosition.y
                      if (t < 0) {
                        ;(this.placementBox.offsetHeight = t / s), this.presentedScene.setShadowScaleAndOffset(s, t)
                        const i = Pu.copy(n.getCamera().position),
                          r = -t / (i.y - e.y)
                        i.multiplyScalar(r), e.multiplyScalar(1 - r).add(i)
                      }
                    }
                    this.goalPosition.add(e), this.lastDragPosition.copy(e)
                  }
                })
          else {
            ;(this.isTranslating = !1), (this.isRotating = !1), (this.isTwoFingering = !0)
            const { separation: t } = this.fingerPolar(i)
            this.firstRatio = t / s
          }
        }
        moveScene(t) {
          const e = this.presentedScene,
            { position: i, yaw: n, idealCameraDistance: s } = e,
            r = this.goalPosition,
            a = e.scale.x,
            o = this.placementBox
          if (!r.equals(i) || this.goalScale !== a) {
            let { x: n, y: l, z: c } = i
            ;(n = this.xDamper.update(n, r.x, t, s)),
              (l = this.yDamper.update(l, r.y, t, s)),
              (c = this.zDamper.update(c, r.z, t, s)),
              i.set(n, l, c)
            const h = this.scaleDamper.update(a, this.goalScale, t, 1)
            if ((e.scale.set(h, h, h), !this.isTranslating)) {
              const t = r.y - l
              this.placementComplete && !1 === this.placeOnWall
                ? ((o.offsetHeight = t / h), e.setShadowScaleAndOffset(h, t))
                : 0 === t && ((this.placementComplete = !0), (o.show = !1), e.setShadowIntensity(0.3))
            }
          }
          o.updateOpacity(t), e.updateTarget(t), (e.yaw = this.yawDamper.update(n, this.goalYaw, t, Math.PI))
        }
        onWebXRFrame(t, e) {
          ;(this.frame = e), ++this.frames
          const i = this.threeRenderer.xr.getReferenceSpace(),
            n = e.getViewerPose(i)
          null == n &&
            !0 === this.tracking &&
            this.frames > 30 &&
            ((this.tracking = !1), this.dispatchEvent({ type: 'tracking', status: 'not-tracking' }))
          const s = this.presentedScene
          if (null == n || null == s || !s.element[lp]()) return void this.threeRenderer.clear()
          !1 === this.tracking && ((this.tracking = !0), this.dispatchEvent({ type: 'tracking', status: Ru }))
          let r = !0
          for (const a of n.views) {
            if ((this.updateView(a), r)) {
              this.moveToFloor(e), this.processInput(e)
              const i = t - this.lastTick
              this.moveScene(i), this.renderer.preRender(s, t, i), (this.lastTick = t)
            }
            const i = this.threeRenderer.getContext()
            i.depthMask(!1),
              i.clear(i.DEPTH_BUFFER_BIT),
              i.depthMask(!0),
              this.threeRenderer.render(s, s.getCamera()),
              (r = !1)
          }
        }
      }
      /* @license
       * Copyright 2019 Google LLC. All Rights Reserved.
       * Licensed under the Apache License, Version 2.0 (the 'License');
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *     http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an 'AS IS' BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Ou {
        constructor(t) {
          ;(t.threeRenderer.debug = { checkShaderErrors: !0 }),
            Promise.resolve().then(() => {
              self.dispatchEvent(
                new CustomEvent('model-viewer-renderer-debug', {
                  detail: {
                    renderer: t,
                    THREE: {
                      ShaderMaterial: Ri,
                      Texture: xt,
                      Mesh: Si,
                      Scene: Rr,
                      PlaneBufferGeometry: Ji,
                      OrthographicCamera: an,
                      WebGLRenderTarget: It,
                    },
                  },
                }),
              )
            })
        }
        addScene(t) {
          self.dispatchEvent(new CustomEvent('model-viewer-scene-added-debug', { detail: { scene: t } }))
        }
        removeScene(t) {
          self.dispatchEvent(new CustomEvent('model-viewer-scene-removed-debug', { detail: { scene: t } }))
        }
      }
      function Gu(t, e, i) {
        i(t, e)
        for (let n = 0; n < t.children.length; n++) Gu(t.children[n], e.children[n], i)
      }
      /* @license
       * Copyright 2020 Google LLC. All Rights Reserved.
       * Licensed under the Apache License, Version 2.0 (the 'License');
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *     http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an 'AS IS' BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ const zu = Symbol('prepared'),
        Vu = Symbol('prepare'),
        Hu = Symbol('preparedGLTF'),
        Wu = Symbol('clone')
      class qu {
        constructor(t) {
          this[Hu] = t
        }
        static prepare(t) {
          if (null == t.scene) throw new Error('Model does not have a scene')
          if (t[zu]) return t
          const e = this[Vu](t)
          return (e[zu] = !0), e
        }
        static [Vu](t) {
          const { scene: e } = t,
            i = [e]
          return Object.assign(Object.assign({}, t), { scene: e, scenes: i })
        }
        get parser() {
          return this[Hu].parser
        }
        get animations() {
          return this[Hu].animations
        }
        get scene() {
          return this[Hu].scene
        }
        get scenes() {
          return this[Hu].scenes
        }
        get cameras() {
          return this[Hu].cameras
        }
        get asset() {
          return this[Hu].asset
        }
        get userData() {
          return this[Hu].userData
        }
        clone() {
          return new (0, this.constructor)(this[Wu]())
        }
        dispose() {
          this.scenes.forEach((t) => {
            t.traverse((t) => {
              if (!t.isMesh) return
              const e = t
              ;(Array.isArray(e.material) ? e.material : [e.material]).forEach((t) => {
                for (const e in t) {
                  const i = t[e]
                  i instanceof xt && i.dispose()
                }
                t.dispose()
              }),
                e.geometry.dispose()
            })
          })
        }
        [Wu]() {
          const t = this[Hu],
            e = class {
              static retarget(t, e, i = {}) {
                const n = new Et(),
                  s = new Mt(),
                  r = new Et(),
                  a = new ne(),
                  o = new ne(),
                  l = new ne()
                ;(i.preserveMatrix = void 0 === i.preserveMatrix || i.preserveMatrix),
                  (i.preservePosition = void 0 === i.preservePosition || i.preservePosition),
                  (i.preserveHipPosition = void 0 !== i.preserveHipPosition && i.preserveHipPosition),
                  (i.useTargetMatrix = void 0 !== i.useTargetMatrix && i.useTargetMatrix),
                  (i.hip = void 0 !== i.hip ? i.hip : 'hip'),
                  (i.names = i.names || {})
                const c = e.isObject3D ? e.skeleton.bones : this.getBones(e),
                  h = t.isObject3D ? t.skeleton.bones : this.getBones(t)
                let u, d, p, A, g
                if (
                  (t.isObject3D ? t.skeleton.pose() : ((i.useTargetMatrix = !0), (i.preserveMatrix = !1)),
                  i.preservePosition)
                ) {
                  g = []
                  for (let t = 0; t < h.length; t++) g.push(h[t].position.clone())
                }
                if (i.preserveMatrix) {
                  t.updateMatrixWorld(), t.matrixWorld.identity()
                  for (let e = 0; e < t.children.length; ++e) t.children[e].updateMatrixWorld(!0)
                }
                if (i.offsets) {
                  u = []
                  for (let t = 0; t < h.length; ++t)
                    (d = h[t]),
                      (p = i.names[d.name] || d.name),
                      i.offsets &&
                        i.offsets[p] &&
                        (d.matrix.multiply(i.offsets[p]),
                        d.matrix.decompose(d.position, d.quaternion, d.scale),
                        d.updateMatrixWorld()),
                      u.push(d.matrixWorld.clone())
                }
                for (let m = 0; m < h.length; ++m) {
                  if (
                    ((d = h[m]),
                    (p = i.names[d.name] || d.name),
                    (A = this.getBoneByName(p, c)),
                    l.copy(d.matrixWorld),
                    A)
                  ) {
                    if (
                      (A.updateMatrixWorld(),
                      i.useTargetMatrix
                        ? o.copy(A.matrixWorld)
                        : (o.copy(t.matrixWorld).invert(), o.multiply(A.matrixWorld)),
                      r.setFromMatrixScale(o),
                      o.scale(r.set(1 / r.x, 1 / r.y, 1 / r.z)),
                      l.makeRotationFromQuaternion(s.setFromRotationMatrix(o)),
                      t.isObject3D)
                    ) {
                      const e = h.indexOf(d),
                        i = u ? u[e] : a.copy(t.skeleton.boneInverses[e]).invert()
                      l.multiply(i)
                    }
                    l.copyPosition(o)
                  }
                  d.parent && d.parent.isBone
                    ? (d.matrix.copy(d.parent.matrixWorld).invert(), d.matrix.multiply(l))
                    : d.matrix.copy(l),
                    i.preserveHipPosition && p === i.hip && d.matrix.setPosition(n.set(0, d.position.y, 0)),
                    d.matrix.decompose(d.position, d.quaternion, d.scale),
                    d.updateMatrixWorld()
                }
                if (i.preservePosition)
                  for (let m = 0; m < h.length; ++m)
                    (d = h[m]), (p = i.names[d.name] || d.name), p !== i.hip && d.position.copy(g[m])
                i.preserveMatrix && t.updateMatrixWorld(!0)
              }
              static retargetClip(t, e, i, n = {}) {
                ;(n.useFirstFramePosition = void 0 !== n.useFirstFramePosition && n.useFirstFramePosition),
                  (n.fps = void 0 !== n.fps ? n.fps : 30),
                  (n.names = n.names || []),
                  e.isObject3D || (e = this.getHelperFromSkeleton(e))
                const s = Math.round(i.duration * (n.fps / 1e3) * 1e3),
                  r = 1 / n.fps,
                  a = [],
                  o = new Fl(e),
                  l = this.getBones(t.skeleton),
                  c = []
                let h, u, d, p, A
                o.clipAction(i).play(), o.update(0), e.updateMatrixWorld()
                for (let g = 0; g < s; ++g) {
                  const i = g * r
                  this.retarget(t, e, n)
                  for (let t = 0; t < l.length; ++t)
                    (A = n.names[l[t].name] || l[t].name),
                      (d = this.getBoneByName(A, e.skeleton)),
                      d &&
                        ((u = l[t]),
                        (p = c[t] = c[t] || { bone: u }),
                        n.hip === A &&
                          (p.pos || (p.pos = { times: new Float32Array(s), values: new Float32Array(3 * s) }),
                          n.useFirstFramePosition && (0 === g && (h = u.position.clone()), u.position.sub(h)),
                          (p.pos.times[g] = i),
                          u.position.toArray(p.pos.values, 3 * g)),
                        p.quat || (p.quat = { times: new Float32Array(s), values: new Float32Array(4 * s) }),
                        (p.quat.times[g] = i),
                        u.quaternion.toArray(p.quat.values, 4 * g))
                  o.update(r), e.updateMatrixWorld()
                }
                for (let g = 0; g < c.length; ++g)
                  (p = c[g]),
                    p &&
                      (p.pos && a.push(new Ho('.bones[' + p.bone.name + '].position', p.pos.times, p.pos.values)),
                      a.push(new zo('.bones[' + p.bone.name + '].quaternion', p.quat.times, p.quat.values)))
                return o.uncacheAction(i), new Wo(i.name, -1, a)
              }
              static getHelperFromSkeleton(t) {
                const e = new Hl(t.bones[0])
                return (e.skeleton = t), e
              }
              static getSkeletonOffsets(t, e, i = {}) {
                const n = new Et(),
                  s = new Et(),
                  r = new Et(),
                  a = new Et(),
                  o = new gt(),
                  l = new gt()
                ;(i.hip = void 0 !== i.hip ? i.hip : 'hip'),
                  (i.names = i.names || {}),
                  e.isObject3D || (e = this.getHelperFromSkeleton(e))
                const c = Object.keys(i.names),
                  h = Object.values(i.names),
                  u = e.isObject3D ? e.skeleton.bones : this.getBones(e),
                  d = t.isObject3D ? t.skeleton.bones : this.getBones(t),
                  p = []
                let A, g, m, f
                for (t.skeleton.pose(), f = 0; f < d.length; ++f)
                  if (((A = d[f]), (m = i.names[A.name] || A.name), (g = this.getBoneByName(m, u)), g && m !== i.hip)) {
                    const t = this.getNearestBone(A.parent, c),
                      e = this.getNearestBone(g.parent, h)
                    t.updateMatrixWorld(),
                      e.updateMatrixWorld(),
                      n.setFromMatrixPosition(t.matrixWorld),
                      s.setFromMatrixPosition(A.matrixWorld),
                      r.setFromMatrixPosition(e.matrixWorld),
                      a.setFromMatrixPosition(g.matrixWorld),
                      o.subVectors(new gt(s.x, s.y), new gt(n.x, n.y)).normalize(),
                      l.subVectors(new gt(a.x, a.y), new gt(r.x, r.y)).normalize()
                    const i = o.angle() - l.angle(),
                      u = new ne().makeRotationFromEuler(new pe(0, 0, i))
                    A.matrix.multiply(u),
                      A.matrix.decompose(A.position, A.quaternion, A.scale),
                      A.updateMatrixWorld(),
                      (p[m] = u)
                  }
                return p
              }
              static renameBones(t, e) {
                const i = this.getBones(t)
                for (let n = 0; n < i.length; ++n) {
                  const t = i[n]
                  e[t.name] && (t.name = e[t.name])
                }
                return this
              }
              static getBones(t) {
                return Array.isArray(t) ? t : t.bones
              }
              static getBoneByName(t, e) {
                for (let i = 0, n = this.getBones(e); i < n.length; i++) if (t === n[i].name) return n[i]
              }
              static getNearestBone(t, e) {
                for (; t.isBone; ) {
                  if (-1 !== e.indexOf(t.name)) return t
                  t = t.parent
                }
              }
              static findBoneTrackData(t, e) {
                const i = /\[(.*)\]\.(.*)/,
                  n = { name: t }
                for (let s = 0; s < e.length; ++s) {
                  const r = i.exec(e[s].name)
                  r && t === r[1] && (n[r[2]] = s)
                }
                return n
              }
              static getEqualsBonesNames(t, e) {
                const i = this.getBones(t),
                  n = this.getBones(e),
                  s = []
                t: for (let r = 0; r < i.length; r++) {
                  const t = i[r].name
                  for (let e = 0; e < n.length; e++)
                    if (t === n[e].name) {
                      s.push(t)
                      continue t
                    }
                }
                return s
              }
              static clone(t) {
                const e = new Map(),
                  i = new Map(),
                  n = t.clone()
                return (
                  Gu(t, n, function (t, n) {
                    e.set(n, t), i.set(t, n)
                  }),
                  n.traverse(function (t) {
                    if (!t.isSkinnedMesh) return
                    const n = t,
                      s = e.get(t),
                      r = s.skeleton.bones
                    ;(n.skeleton = s.skeleton.clone()),
                      n.bindMatrix.copy(s.bindMatrix),
                      (n.skeleton.bones = r.map(function (t) {
                        return i.get(t)
                      })),
                      n.bind(n.skeleton, n.bindMatrix)
                  }),
                  n
                )
              }
            }.clone(this.scene)
          ju(e, this.scene)
          const i = [e],
            n = t.userData ? Object.assign({}, t.userData) : {}
          return Object.assign(Object.assign({}, t), { scene: e, scenes: i, userData: n })
        }
      }
      const ju = (t, e) => {
          Yu(t, e, (t, e) => {
            void 0 !== e.userData.variantMaterials &&
              (t.userData.variantMaterials = new Map(e.userData.variantMaterials)),
              void 0 !== e.userData.originalMaterial && (t.userData.originalMaterial = e.userData.originalMaterial)
          })
        },
        Yu = (t, e, i) => {
          i(t, e)
          for (let n = 0; n < t.children.length; n++) Yu(t.children[n], e.children[n], i)
        },
        Ju =
          '\n#ifdef ALPHATEST\n\n    if ( diffuseColor.a < ALPHATEST ) discard;\n    diffuseColor.a = 1.0;\n\n#endif\n',
        Xu = Symbol('threeGLTF'),
        Ku = Symbol('gltf'),
        Zu = Symbol('gltfElementMap'),
        $u = Symbol('threeObjectMap'),
        td = Symbol('parallelTraverseThreeScene'),
        ed = Symbol('correlateOriginalThreeGLTF'),
        id = Symbol('correlateCloneThreeGLTF')
      class nd {
        constructor(t, e, i, n) {
          ;(this[Xu] = t), (this[Ku] = e), (this[Zu] = n), (this[$u] = i)
        }
        static from(t, e) {
          return null != e ? this[id](t, e) : this[ed](t)
        }
        static [ed](t) {
          const e = t.parser.json,
            { associations: i } = t.parser,
            n = new Map(),
            s = { name: 'Default' },
            r = { type: 'materials', index: -1 }
          return (
            i.forEach((t, i) => {
              null == t &&
                (r.index < 0 &&
                  (null == e.materials && (e.materials = []), (r.index = e.materials.length), e.materials.push(s)),
                (t = r))
              const { type: a, index: o } = t,
                l = (e[a] || [])[o]
              if (null == l) return
              let c = n.get(l)
              null == c && ((c = new Set()), n.set(l, c)), c.add(i)
            }),
            new nd(t, e, i, n)
          )
        }
        static [id](t, e) {
          const i = e.threeGLTF,
            n = e.gltf,
            s = JSON.parse(JSON.stringify(n)),
            r = new Map(),
            a = new Map(),
            o = { name: 'Default' },
            l = { type: 'materials', index: -1 }
          for (let c = 0; c < i.scenes.length; c++)
            this[td](i.scenes[c], t.scenes[c], (t, i) => {
              let n = e.threeObjectMap.get(t)
              if (
                ((t.isMesh || t.isMaterial) &&
                  null == n &&
                  (s.materials &&
                    s.materials.length &&
                    'Default' === s.materials[s.materials.length - 1].name &&
                    (l.index = s.materials.length - 1),
                  l.index < 0 &&
                    (null == s.materials && (s.materials = []), (l.index = s.materials.length), s.materials.push(o)),
                  (n = l)),
                null == n)
              )
                return
              const { type: c, index: h } = n,
                u = s[c][h]
              r.set(i, { type: c, index: h })
              const d = a.get(u) || new Set()
              d.add(i), a.set(u, d)
            })
          return new nd(t, s, r, a)
        }
        static [td](t, e, i) {
          const n = (t, e) => {
            if ((i(t, e), t.isObject3D)) {
              if (t.isMesh)
                if (Array.isArray(t.material))
                  for (let i = 0; i < t.material.length; ++i) n(t.material[i], e.material[i])
                else n(t.material, e.material)
              for (let i = 0; i < t.children.length; ++i) n(t.children[i], e.children[i])
            }
          }
          n(t, e)
        }
        get threeGLTF() {
          return this[Xu]
        }
        get gltf() {
          return this[Ku]
        }
        get gltfElementMap() {
          return this[Zu]
        }
        get threeObjectMap() {
          return this[$u]
        }
        async loadVariant(t) {
          const e = new Set()
          return 'variants' in this.threeGLTF.userData &&
            'functions' in this.threeGLTF.userData &&
            'selectVariant' in this.threeGLTF.userData.functions
            ? (await this.threeGLTF.userData.functions.selectVariant(this.threeGLTF.scene, t, !0, (t, i, n) => {
                e.add(n)
                const s = this.gltf.materials[n]
                let r = this.gltfElementMap.get(s)
                null == r && ((r = new Set()), this.gltfElementMap.set(s, r)), r.add(t.material)
              }),
              e)
            : e
        }
      }
      /* @license
       * Copyright 2020 Google LLC. All Rights Reserved.
       * Licensed under the Apache License, Version 2.0 (the 'License');
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *     http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an 'AS IS' BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ const sd = Symbol('cloneAndPatchMaterial'),
        rd = Symbol('correlatedSceneGraph')
      class ad extends qu {
        static [Vu](t) {
          const e = super[Vu](t)
          null == e[rd] && (e[rd] = nd.from(e))
          const { scene: i } = e
          return (
            i.traverse((t) => {
              ;(t.renderOrder = 1e3),
                (t.frustumCulled = !1),
                t.name || (t.name = t.uuid),
                t.isMesh && (t.castShadow = !0)
            }),
            e
          )
        }
        get correlatedSceneGraph() {
          return this[Hu][rd]
        }
        [Wu]() {
          const t = super[Wu](),
            e = new Map()
          return (
            t.scene.traverse((t) => {
              if (t.isMesh) {
                const i = t
                Array.isArray(i.material)
                  ? (i.material = i.material.map((t) => this[sd](t, e)))
                  : null != i.material && (i.material = this[sd](i.material, e))
              }
            }),
            (t[rd] = nd.from(t, this.correlatedSceneGraph)),
            t
          )
        }
        [sd](t, e) {
          if (e.has(t.uuid)) return e.get(t.uuid)
          const i = t.clone()
          null != t.map && ((i.map = t.map.clone()), (i.map.needsUpdate = !0)),
            null != t.normalMap && ((i.normalMap = t.normalMap.clone()), (i.normalMap.needsUpdate = !0)),
            null != t.emissiveMap && ((i.emissiveMap = t.emissiveMap.clone()), (i.emissiveMap.needsUpdate = !0))
          let n = null
          if ((null != t.roughnessMap && (n = t.roughnessMap.clone()), null != n)) {
            ;(n.needsUpdate = !0), (i.roughnessMap = n)
            const { threeRenderer: t, roughnessMipmapper: e } = gd.singleton,
              { enabled: s } = t.xr
            ;(t.xr.enabled = !1), e.generateMipmaps(i), (t.xr.enabled = s)
          }
          t.roughnessMap === t.metalnessMap
            ? (i.metalnessMap = n)
            : null != t.metalnessMap && ((i.metalnessMap = t.metalnessMap.clone()), (i.metalnessMap.needsUpdate = !0)),
            t.roughnessMap === t.aoMap
              ? (i.aoMap = n)
              : null != t.aoMap && ((i.aoMap = t.aoMap.clone()), (i.aoMap.needsUpdate = !0))
          const s = t.onBeforeCompile
          return (
            (i.onBeforeCompile = t.isGLTFSpecularGlossinessMaterial
              ? (t) => {
                  s(t, void 0), (t.fragmentShader = t.fragmentShader.replace('#include <alphatest_fragment>', Ju))
                }
              : (t) => {
                  ;(t.fragmentShader = t.fragmentShader.replace('#include <alphatest_fragment>', Ju)), s(t, void 0)
                }),
            (i.shadowSide = 0),
            i.transparent && (i.depthWrite = !1),
            i.alphaTest || i.transparent || (i.alphaTest = -0.5),
            e.set(t.uuid, i),
            i
          )
          /* @license
           * Copyright 2021 Google LLC. All Rights Reserved.
           * Licensed under the Apache License, Version 2.0 (the 'License');
           * you may not use this file except in compliance with the License.
           * You may obtain a copy of the License at
           *
           *     http://www.apache.org/licenses/LICENSE-2.0
           *
           * Unless required by applicable law or agreed to in writing, software
           * distributed under the License is distributed on an 'AS IS' BASIS,
           * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
           * See the License for the specific language governing permissions and
           * limitations under the License.
           */
        }
      }
      class od extends Rr {
        constructor() {
          super(), (this.position.y = -3.5)
          const t = new Ti()
          t.deleteAttribute('uv')
          const e = new To({ metalness: 0, side: 1 }),
            i = new To({ metalness: 0 }),
            n = new fl(16777215, 500, 28, 2)
          n.position.set(0.418, 16.199, 0.3), this.add(n)
          const s = new Si(t, e)
          s.position.set(-0.757, 13.219, 0.717), s.scale.set(31.713, 28.305, 28.591), this.add(s)
          const r = new Si(t, i)
          r.position.set(-10.906, 2.009, 1.846),
            r.rotation.set(0, -0.195, 0),
            r.scale.set(2.328, 7.905, 4.651),
            this.add(r)
          const a = new Si(t, i)
          a.position.set(-5.607, -0.754, -0.758),
            a.rotation.set(0, 0.994, 0),
            a.scale.set(1.97, 1.534, 3.955),
            this.add(a)
          const o = new Si(t, i)
          o.position.set(6.167, 0.857, 7.803),
            o.rotation.set(0, 0.561, 0),
            o.scale.set(3.927, 6.285, 3.687),
            this.add(o)
          const l = new Si(t, i)
          l.position.set(-2.017, 0.018, 6.124),
            l.rotation.set(0, 0.333, 0),
            l.scale.set(2.002, 4.566, 2.064),
            this.add(l)
          const c = new Si(t, i)
          c.position.set(2.291, -0.756, -2.621),
            c.rotation.set(0, -0.286, 0),
            c.scale.set(1.546, 1.552, 1.496),
            this.add(c)
          const h = new Si(t, i)
          h.position.set(-2.193, -0.369, -5.547),
            h.rotation.set(0, 0.516, 0),
            h.scale.set(3.875, 3.487, 2.986),
            this.add(h)
          const u = new Si(t, this.createAreaLightMaterial(50))
          u.position.set(-16.116, 14.37, 8.208), u.scale.set(0.1, 2.428, 2.739), this.add(u)
          const d = new Si(t, this.createAreaLightMaterial(50))
          d.position.set(-16.109, 18.021, -8.207), d.scale.set(0.1, 2.425, 2.751), this.add(d)
          const p = new Si(t, this.createAreaLightMaterial(17))
          p.position.set(14.904, 12.198, -1.832), p.scale.set(0.15, 4.265, 6.331), this.add(p)
          const A = new Si(t, this.createAreaLightMaterial(43))
          A.position.set(-0.462, 8.89, 14.52), A.scale.set(4.38, 5.441, 0.088), this.add(A)
          const g = new Si(t, this.createAreaLightMaterial(20))
          g.position.set(3.235, 11.486, -12.541), g.scale.set(2.5, 2, 0.1), this.add(g)
          const m = new Si(t, this.createAreaLightMaterial(100))
          m.position.set(0, 20, 0), m.scale.set(1, 0.1, 1), this.add(m)
        }
        createAreaLightMaterial(t) {
          const e = new Je()
          return e.color.setScalar(t), e
          /* @license
           * Copyright 2021 Google LLC. All Rights Reserved.
           * Licensed under the Apache License, Version 2.0 (the 'License');
           * you may not use this file except in compliance with the License.
           * You may obtain a copy of the License at
           *
           *     http://www.apache.org/licenses/LICENSE-2.0
           *
           * Unless required by applicable law or agreed to in writing, software
           * distributed under the License is distributed on an 'AS IS' BASIS,
           * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
           * See the License for the specific language governing permissions and
           * limitations under the License.
           */
        }
      }
      class ld extends Rr {
        constructor() {
          super(), (this.position.y = -3.5)
          const t = new Ti()
          t.deleteAttribute('uv')
          const e = new To({ metalness: 0, side: 1 }),
            i = new To({ metalness: 0 }),
            n = new fl(16777215, 400, 28, 2)
          n.position.set(0.5, 14, 0.5), this.add(n)
          const s = new Si(t, e)
          s.position.set(0, 13.2, 0), s.scale.set(31.5, 28.5, 31.5), this.add(s)
          const r = new Si(t, i)
          r.position.set(-10.906, -1, 1.846),
            r.rotation.set(0, -0.195, 0),
            r.scale.set(2.328, 7.905, 4.651),
            this.add(r)
          const a = new Si(t, i)
          a.position.set(-5.607, -0.754, -0.758),
            a.rotation.set(0, 0.994, 0),
            a.scale.set(1.97, 1.534, 3.955),
            this.add(a)
          const o = new Si(t, i)
          o.position.set(6.167, -0.16, 7.803),
            o.rotation.set(0, 0.561, 0),
            o.scale.set(3.927, 6.285, 3.687),
            this.add(o)
          const l = new Si(t, i)
          l.position.set(-2.017, 0.018, 6.124),
            l.rotation.set(0, 0.333, 0),
            l.scale.set(2.002, 4.566, 2.064),
            this.add(l)
          const c = new Si(t, i)
          c.position.set(2.291, -0.756, -2.621),
            c.rotation.set(0, -0.286, 0),
            c.scale.set(1.546, 1.552, 1.496),
            this.add(c)
          const h = new Si(t, i)
          h.position.set(-2.193, -0.369, -5.547),
            h.rotation.set(0, 0.516, 0),
            h.scale.set(3.875, 3.487, 2.986),
            this.add(h)
          const u = new Si(t, this.createAreaLightMaterial(80))
          u.position.set(-14, 10, 8), u.scale.set(0.1, 2.5, 2.5), this.add(u)
          const d = new Si(t, this.createAreaLightMaterial(80))
          d.position.set(-14, 14, -4), d.scale.set(0.1, 2.5, 2.5), this.add(d)
          const p = new Si(t, this.createAreaLightMaterial(23))
          p.position.set(14, 12, 0), p.scale.set(0.1, 5, 5), this.add(p)
          const A = new Si(t, this.createAreaLightMaterial(16))
          A.position.set(0, 9, 14), A.scale.set(5, 5, 0.1), this.add(A)
          const g = new Si(t, this.createAreaLightMaterial(80))
          g.position.set(7, 8, -14), g.scale.set(2.5, 2.5, 0.1), this.add(g)
          const m = new Si(t, this.createAreaLightMaterial(80))
          m.position.set(-7, 16, -14), m.scale.set(2.5, 2.5, 0.1), this.add(m)
          const f = new Si(t, this.createAreaLightMaterial(1))
          f.position.set(0, 20, 0), f.scale.set(0.1, 0.1, 0.1), this.add(f)
        }
        createAreaLightMaterial(t) {
          const e = new Je()
          return e.color.setScalar(t), e
          /* @license
           * Copyright 2019 Google LLC. All Rights Reserved.
           * Licensed under the Apache License, Version 2.0 (the 'License');
           * you may not use this file except in compliance with the License.
           * You may obtain a copy of the License at
           *
           *     http://www.apache.org/licenses/LICENSE-2.0
           *
           * Unless required by applicable law or agreed to in writing, software
           * distributed under the License is distributed on an 'AS IS' BASIS,
           * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
           * See the License for the specific language governing permissions and
           * limitations under the License.
           */
        }
      }
      const cd = /\.hdr(\.js)?$/,
        hd = new il(),
        ud = new (class extends el {
          constructor(t) {
            super(t), (this.type = 1015)
          }
          parse(t) {
            const e = function (t, e) {
                switch (t) {
                  case 1:
                  case 2:
                  case 3:
                    break
                  default:
                  case 4:
                }
                return -1
              },
              i = function (t, e, i) {
                e = e || 1024
                let n = t.pos,
                  s = -1,
                  r = 0,
                  a = '',
                  o = String.fromCharCode.apply(null, new Uint16Array(t.subarray(n, n + 128)))
                for (; 0 > (s = o.indexOf('\n')) && r < e && n < t.byteLength; )
                  (a += o),
                    (r += o.length),
                    (n += 128),
                    (o += String.fromCharCode.apply(null, new Uint16Array(t.subarray(n, n + 128))))
                return -1 < s && (!1 !== i && (t.pos += r + s + 1), a + o.slice(0, s))
              },
              n = function (t, e, i, n) {
                const s = t[e + 3],
                  r = Math.pow(2, s - 128) / 255
                ;(i[n + 0] = t[e + 0] * r), (i[n + 1] = t[e + 1] * r), (i[n + 2] = t[e + 2] * r)
              },
              s = function (t, e, i, n) {
                const s = t[e + 3],
                  r = Math.pow(2, s - 128) / 255
                ;(i[n + 0] = Yl.toHalfFloat(t[e + 0] * r)),
                  (i[n + 1] = Yl.toHalfFloat(t[e + 1] * r)),
                  (i[n + 2] = Yl.toHalfFloat(t[e + 2] * r))
              },
              r = new Uint8Array(t)
            r.pos = 0
            const a = (function (t) {
              const n = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,
                s = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,
                r = /^\s*FORMAT=(\S+)\s*$/,
                a = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,
                o = {
                  valid: 0,
                  string: '',
                  comments: '',
                  programtype: 'RGBE',
                  format: '',
                  gamma: 1,
                  exposure: 1,
                  width: 0,
                  height: 0,
                }
              let l, c
              if (t.pos >= t.byteLength || !(l = i(t))) return e(1)
              if (!(c = l.match(/^#\?(\S+)/))) return e(3)
              for (o.valid |= 1, o.programtype = c[1], o.string += l + '\n'; (l = i(t)), !1 !== l; )
                if (((o.string += l + '\n'), '#' !== l.charAt(0))) {
                  if (
                    ((c = l.match(n)) && (o.gamma = parseFloat(c[1], 10)),
                    (c = l.match(s)) && (o.exposure = parseFloat(c[1], 10)),
                    (c = l.match(r)) && ((o.valid |= 2), (o.format = c[1])),
                    (c = l.match(a)) &&
                      ((o.valid |= 4), (o.height = parseInt(c[1], 10)), (o.width = parseInt(c[2], 10))),
                    2 & o.valid && 4 & o.valid)
                  )
                    break
                } else o.comments += l + '\n'
              return 2 & o.valid && 4 & o.valid ? o : e(3)
            })(r)
            if (-1 !== a) {
              const t = a.width,
                i = a.height,
                o = (function (t, i, n) {
                  const s = i
                  if (s < 8 || s > 32767 || 2 !== t[0] || 2 !== t[1] || 128 & t[2]) return new Uint8Array(t)
                  if (s !== ((t[2] << 8) | t[3])) return e(3)
                  const r = new Uint8Array(4 * i * n)
                  if (!r.length) return e(4)
                  let a = 0,
                    o = 0
                  const l = 4 * s,
                    c = new Uint8Array(4),
                    h = new Uint8Array(l)
                  let u = n
                  for (; u > 0 && o < t.byteLength; ) {
                    if (o + 4 > t.byteLength) return e(1)
                    if (
                      ((c[0] = t[o++]),
                      (c[1] = t[o++]),
                      (c[2] = t[o++]),
                      (c[3] = t[o++]),
                      2 != c[0] || 2 != c[1] || ((c[2] << 8) | c[3]) != s)
                    )
                      return e(3)
                    let i,
                      n = 0
                    for (; n < l && o < t.byteLength; ) {
                      i = t[o++]
                      const s = i > 128
                      if ((s && (i -= 128), 0 === i || n + i > l)) return e(3)
                      if (s) {
                        const e = t[o++]
                        for (let t = 0; t < i; t++) h[n++] = e
                      } else h.set(t.subarray(o, o + i), n), (n += i), (o += i)
                    }
                    const d = s
                    for (let t = 0; t < d; t++) {
                      let e = 0
                      ;(r[a] = h[t + e]),
                        (e += s),
                        (r[a + 1] = h[t + e]),
                        (e += s),
                        (r[a + 2] = h[t + e]),
                        (e += s),
                        (r[a + 3] = h[t + e]),
                        (a += 4)
                    }
                    u--
                  }
                  return r
                })(r.subarray(r.pos), t, i)
              if (-1 !== o) {
                let e, r, l, c
                switch (this.type) {
                  case 1009:
                    ;(e = o), (r = 1023), (l = 1009)
                    break
                  case 1015:
                    c = (o.length / 4) * 3
                    const t = new Float32Array(c)
                    for (let e = 0; e < c; e++) n(o, 4 * e, t, 3 * e)
                    ;(e = t), (r = 1022), (l = 1015)
                    break
                  case 1016:
                    c = (o.length / 4) * 3
                    const i = new Uint16Array(c)
                    for (let e = 0; e < c; e++) s(o, 4 * e, i, 3 * e)
                    ;(e = i), (r = 1022), (l = 1016)
                }
                return {
                  width: t,
                  height: i,
                  data: e,
                  header: a.string,
                  gamma: a.gamma,
                  exposure: a.exposure,
                  format: r,
                  type: l,
                }
              }
            }
            return null
          }
          setDataType(t) {
            return (this.type = t), this
          }
          load(t, e, i, n) {
            return super.load(
              t,
              function (t, i) {
                switch (t.type) {
                  case 1009:
                    ;(t.encoding = 3002),
                      (t.minFilter = 1003),
                      (t.magFilter = 1003),
                      (t.generateMipmaps = !1),
                      (t.flipY = !0)
                    break
                  case 1015:
                  case 1016:
                    ;(t.encoding = 3e3),
                      (t.minFilter = 1006),
                      (t.magFilter = 1006),
                      (t.generateMipmaps = !1),
                      (t.flipY = !0)
                }
                e && e(t, i)
              },
              i,
              n,
            )
          }
        })()
      ud.setDataType(1009)
      const dd = { url: null }
      class pd extends it {
        constructor(t) {
          super(),
            (this.generatedEnvironmentMap = null),
            (this.generatedEnvironmentMapAlt = null),
            (this.skyboxCache = new Map()),
            (this.environmentMapCache = new Map()),
            (this.PMREMGenerator = new Cn(t))
        }
        async load(t, e = () => {}) {
          try {
            const i = cd.test(t),
              n = i ? ud : hd,
              s = await new Promise((i, s) =>
                n.load(
                  t,
                  i,
                  (t) => {
                    e((t.loaded / t.total) * 0.9)
                  },
                  s,
                ),
              )
            return e(1), this.addMetadata(s, t), (s.mapping = 303), i || (s.encoding = 3007), s
          } finally {
            e && e(1)
          }
        }
        async generateEnvironmentMapAndSkybox(t = null, e = null, i = {}) {
          const { progressTracker: n } = i,
            s = null != n ? n.beginActivity() : () => {},
            r = 'neutral' === e
          !0 === r && (e = null)
          const a = Ph(e)
          try {
            let e,
              i = Promise.resolve(null)
            t && (i = this.loadSkyboxFromUrl(t, n)),
              (e = a
                ? this.loadEnvironmentMapFromUrl(a, n)
                : t
                ? this.loadEnvironmentMapFromUrl(t, n)
                : !0 === r
                ? this.loadGeneratedEnvironmentMapAlt()
                : this.loadGeneratedEnvironmentMap())
            let [o, l] = await Promise.all([e, i])
            if (null == o) throw new Error('Failed to load environment map.')
            return { environmentMap: o, skybox: l }
          } finally {
            s(1)
          }
        }
        addMetadata(t, e) {
          null != t && (t.userData = Object.assign(Object.assign({}, dd), { url: e }))
        }
        loadSkyboxFromUrl(t, e) {
          if (!this.skyboxCache.has(t)) {
            const i = e ? e.beginActivity() : () => {},
              n = this.load(t, i)
            this.skyboxCache.set(t, n)
          }
          return this.skyboxCache.get(t)
        }
        loadEnvironmentMapFromUrl(t, e) {
          if (!this.environmentMapCache.has(t)) {
            const i = this.loadSkyboxFromUrl(t, e).then((e) => {
              const i = this.PMREMGenerator.fromEquirectangular(e)
              return this.addMetadata(i.texture, t), i
            })
            this.PMREMGenerator.compileEquirectangularShader(), this.environmentMapCache.set(t, i)
          }
          return this.environmentMapCache.get(t)
        }
        loadGeneratedEnvironmentMap() {
          if (null == this.generatedEnvironmentMap) {
            const t = new od()
            ;(this.generatedEnvironmentMap = this.PMREMGenerator.fromScene(t, 0.04)),
              this.addMetadata(this.generatedEnvironmentMap.texture, null)
          }
          return Promise.resolve(this.generatedEnvironmentMap)
        }
        loadGeneratedEnvironmentMapAlt() {
          if (null == this.generatedEnvironmentMapAlt) {
            const t = new ld()
            ;(this.generatedEnvironmentMapAlt = this.PMREMGenerator.fromScene(t, 0.04)),
              this.addMetadata(this.generatedEnvironmentMapAlt.texture, null)
          }
          return Promise.resolve(this.generatedEnvironmentMapAlt)
        }
        async dispose() {
          const t = []
          this.environmentMapCache.forEach((e) => {
            t.push(e)
          }),
            this.environmentMapCache.clear()
          for (const e of t)
            try {
              ;(await e).dispose()
            } catch (t) {}
          null != this.generatedEnvironmentMap &&
            (this.generatedEnvironmentMap.dispose(), (this.generatedEnvironmentMap = null)),
            null != this.generatedEnvironmentMapAlt &&
              (this.generatedEnvironmentMapAlt.dispose(), (this.generatedEnvironmentMapAlt = null))
        }
      }
      /* @license
       * Copyright 2019 Google LLC. All Rights Reserved.
       * Licensed under the Apache License, Version 2.0 (the 'License');
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *     http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an 'AS IS' BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ const Ad = [1, 0.79, 0.62, 0.5, 0.4, 0.31, 0.25]
      class gd extends it {
        constructor(t) {
          super(),
            (this.loader = new bh(ad)),
            (this.width = 0),
            (this.height = 0),
            (this.dpr = 1),
            (this.debugger = null),
            (this.scenes = new Set()),
            (this.multipleScenesVisible = !1),
            (this.scaleStep = 0),
            (this.lastStep = 3),
            (this.avgFrameDuration = 22),
            (this.onWebGLContextLost = (t) => {
              this.dispatchEvent({ type: 'contextlost', sourceEvent: t })
            }),
            (this.onWebGLContextRestored = () => {
              var t
              null === (t = this.textureUtils) || void 0 === t || t.dispose(),
                (this.textureUtils = new pd(this.threeRenderer)),
                (this.roughnessMipmapper = new yu(this.threeRenderer))
              for (const e of this.scenes) e.element[Iu]()
              this.threeRenderer.shadowMap.needsUpdate = !0
            }),
            (this.dpr = Oh()),
            (this.canvas3D = document.createElement('canvas')),
            (this.canvas3D.id = 'webgl-canvas')
          try {
            ;(this.threeRenderer = new Qr({
              canvas: this.canvas3D,
              alpha: !0,
              antialias: !0,
              powerPreference: t.powerPreference,
              preserveDrawingBuffer: !0,
            })),
              (this.threeRenderer.autoClear = !0),
              (this.threeRenderer.outputEncoding = 3007),
              (this.threeRenderer.physicallyCorrectLights = !0),
              this.threeRenderer.setPixelRatio(1),
              (this.threeRenderer.shadowMap.enabled = !0),
              (this.threeRenderer.shadowMap.type = 2),
              (this.threeRenderer.shadowMap.autoUpdate = !1),
              (this.debugger = t.debug ? new Ou(this) : null),
              (this.threeRenderer.debug = { checkShaderErrors: !!this.debugger }),
              (this.threeRenderer.toneMapping = 4)
          } catch (t) {}
          ;(this.arRenderer = new ku(this)),
            (this.textureUtils = this.canRender ? new pd(this.threeRenderer) : null),
            (this.roughnessMipmapper = new yu(this.threeRenderer)),
            bh.initializeKTX2Loader(this.threeRenderer),
            this.canvas3D.addEventListener('webglcontextlost', this.onWebGLContextLost),
            this.canvas3D.addEventListener('webglcontextrestored', this.onWebGLContextRestored),
            this.updateRendererSize(),
            (this.lastTick = performance.now()),
            (this.avgFrameDuration = 0)
        }
        static get singleton() {
          return this._singleton
        }
        static resetSingleton() {
          const t = this._singleton.dispose()
          for (const e of t) e.disconnectedCallback()
          this._singleton = new gd({
            powerPreference: (self.ModelViewerElement || {}).powerPreference || 'high-performance',
            debug: Gh(),
          })
          for (const e of t) e.connectedCallback()
        }
        get canRender() {
          return null != this.threeRenderer
        }
        get scaleFactor() {
          return Ad[this.scaleStep]
        }
        set minScale(t) {
          let e = 1
          for (; e < Ad.length && !(Ad[e] < t); ) ++e
          this.lastStep = e - 1
        }
        updateRendererSize() {
          const t = Oh()
          if (t !== this.dpr)
            for (const a of this.scenes) {
              const { element: t } = a
              t[Gd](t.getBoundingClientRect())
            }
          let e = 0,
            i = 0
          for (const a of this.scenes) (e = Math.max(e, a.width)), (i = Math.max(i, a.height))
          if (e === this.width && i === this.height && t === this.dpr) return
          ;(this.width = e),
            (this.height = i),
            (this.dpr = t),
            this.canRender && this.threeRenderer.setSize(e * t, i * t, !1)
          const n = this.scaleFactor,
            s = e / n,
            r = i / n
          ;(this.canvas3D.style.width = `${s}px`), (this.canvas3D.style.height = `${r}px`)
          for (const a of this.scenes) {
            const { canvas: n } = a
            ;(n.width = Math.round(e * t)),
              (n.height = Math.round(i * t)),
              (n.style.width = `${s}px`),
              (n.style.height = `${r}px`),
              (a.isDirty = !0)
          }
        }
        updateRendererScale() {
          const t = this.scaleStep
          if (
            (this.avgFrameDuration > 26 && this.scaleStep < this.lastStep
              ? ++this.scaleStep
              : this.avgFrameDuration < 18 && this.scaleStep > 0 && --this.scaleStep,
            t == this.scaleStep)
          )
            return
          const e = this.scaleFactor
          this.avgFrameDuration = 22
          const i = this.width / e,
            n = this.height / e
          ;(this.canvas3D.style.width = `${i}px`), (this.canvas3D.style.height = `${n}px`)
          for (const s of this.scenes) {
            const { style: t } = s.canvas
            ;(t.width = `${i}px`), (t.height = `${n}px`), (s.isDirty = !0)
          }
        }
        registerScene(t) {
          this.scenes.add(t)
          const { canvas: e } = t,
            i = this.scaleFactor
          ;(e.width = Math.round(this.width * this.dpr)),
            (e.height = Math.round(this.height * this.dpr)),
            (e.style.width = this.width / i + 'px'),
            (e.style.height = this.height / i + 'px'),
            this.multipleScenesVisible && e.classList.add('show'),
            (t.isDirty = !0),
            this.canRender && this.scenes.size > 0 && this.threeRenderer.setAnimationLoop((t, e) => this.render(t, e)),
            null != this.debugger && this.debugger.addScene(t)
        }
        unregisterScene(t) {
          this.scenes.delete(t),
            this.canRender && 0 === this.scenes.size && this.threeRenderer.setAnimationLoop(null),
            null != this.debugger && this.debugger.removeScene(t)
        }
        displayCanvas(t) {
          return this.multipleScenesVisible ? t.element[Kd] : this.canvas3D
        }
        selectCanvas() {
          let t = 0,
            e = null
          for (const s of this.scenes) {
            const { element: i } = s
            i.modelIsVisible && null == s.externalRenderer && (++t, (e = s.canvas))
          }
          if (null == e) return
          const i = t > 1,
            { canvas3D: n } = this
          if (i !== this.multipleScenesVisible || (!i && n.parentElement !== e.parentElement)) {
            ;(this.multipleScenesVisible = i), i && n.classList.remove('show')
            for (const t of this.scenes) {
              if (null != t.externalRenderer) continue
              const s = t.element[Kd]
              i
                ? (s.classList.add('show'), (t.isDirty = !0))
                : t.canvas === e &&
                  (t.canvas.parentElement.appendChild(n),
                  n.classList.add('show'),
                  s.classList.remove('show'),
                  (t.isDirty = !0))
            }
          }
        }
        orderedScenes() {
          const t = []
          for (const e of [!1, !0]) for (const i of this.scenes) i.element.modelIsVisible === e && t.push(i)
          return t
        }
        get isPresenting() {
          return this.arRenderer.isPresenting
        }
        preRender(t, e, i) {
          const { element: n, exposure: s } = t
          n[tp](e, i)
          const r = 'number' == typeof s && !self.isNaN(s)
          ;(this.threeRenderer.toneMappingExposure = r ? s : 1),
            t.isShadowDirty() && (this.threeRenderer.shadowMap.needsUpdate = !0)
        }
        render(t, e) {
          if (null != e) return void this.arRenderer.onWebXRFrame(t, e)
          const i = t - this.lastTick
          if (((this.lastTick = t), !this.canRender || this.isPresenting)) return
          ;(this.avgFrameDuration += kh(0.2 * (i - this.avgFrameDuration), -2, 2)),
            this.selectCanvas(),
            this.updateRendererSize(),
            this.updateRendererScale()
          const { dpr: n, scaleFactor: s } = this
          for (const r of this.orderedScenes()) {
            const { element: e } = r
            if (!e.modelIsVisible && r.renderCount > 0) continue
            if ((this.preRender(r, t, i), !r.isDirty)) continue
            if (null != r.externalRenderer) {
              const t = r.getCamera()
              t.updateMatrix()
              const { matrix: e, projectionMatrix: i } = t,
                n = e.elements.slice(),
                s = r.getTarget()
              ;(n[12] += s.x),
                (n[13] += s.y),
                (n[14] += s.z),
                r.externalRenderer.render({ viewMatrix: n, projectionMatrix: i.elements })
              continue
            }
            if (!e.modelIsVisible && !this.multipleScenesVisible)
              for (const t of this.scenes) t.element.modelIsVisible && (t.isDirty = !0)
            const a = Math.min(Math.ceil(r.width * s * n), this.canvas3D.width),
              o = Math.min(Math.ceil(r.height * s * n), this.canvas3D.height)
            if (
              (this.threeRenderer.setRenderTarget(null),
              this.threeRenderer.setViewport(0, Math.floor(this.height * n) - o, a, o),
              this.threeRenderer.render(r, r.camera),
              this.multipleScenesVisible)
            ) {
              null == r.context && r.createContext()
              const t = r.context
              t.clearRect(0, 0, a, o), t.drawImage(this.canvas3D, 0, 0, a, o, 0, 0, a, o)
            }
            ;(r.isDirty = !1), e.loaded && ++r.renderCount
          }
        }
        dispose() {
          null != this.textureUtils && this.textureUtils.dispose(),
            null != this.roughnessMipmapper && this.roughnessMipmapper.dispose(),
            null != this.threeRenderer && this.threeRenderer.dispose(),
            (this.textureUtils = null),
            (this.threeRenderer = null)
          const t = []
          for (const e of this.scenes) t.push(e.element)
          return (
            this.canvas3D.removeEventListener('webglcontextlost', this.onWebGLContextLost),
            this.canvas3D.removeEventListener('webglcontextrestored', this.onWebGLContextRestored),
            t
          )
        }
      }
      /* @license
       * Copyright 2019 Google LLC. All Rights Reserved.
       * Licensed under the Apache License, Version 2.0 (the 'License');
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *     http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an 'AS IS' BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */
      var md, fd
      gd._singleton = new gd({
        powerPreference: (self.ModelViewerElement || {}).powerPreference || 'high-performance',
        debug: Gh(),
      })
      const vd = Symbol('ongoingActivities'),
        yd = Symbol('announceTotalProgress'),
        xd = Symbol('eventDelegate')
      class wd {
        constructor() {
          ;(this[md] = document.createDocumentFragment()),
            (this.addEventListener = (...t) => this[xd].addEventListener(...t)),
            (this.removeEventListener = (...t) => this[xd].removeEventListener(...t)),
            (this.dispatchEvent = (...t) => this[xd].dispatchEvent(...t)),
            (this[fd] = new Set())
        }
        get ongoingActivityCount() {
          return this[vd].size
        }
        beginActivity() {
          const t = { progress: 0 }
          return (
            this[vd].add(t),
            1 === this.ongoingActivityCount && this[yd](),
            (e) => {
              let i
              return (
                (i = Math.max(kh(e, 0, 1), t.progress)), i !== t.progress && ((t.progress = i), this[yd]()), t.progress
              )
            }
          )
        }
        [((md = xd), (fd = vd), yd)]() {
          let t = 0,
            e = 0,
            i = 0
          for (const n of this[vd]) {
            const { progress: s } = n
            ;(t += s * (0.5 / Math.pow(2, e++))), 1 === s && i++
          }
          i === this.ongoingActivityCount && ((t = 1), this[vd].clear()),
            this.dispatchEvent(new CustomEvent('progress', { detail: { totalProgress: t } }))
        }
      }
      /* @license
       * Copyright 2019 Google LLC. All Rights Reserved.
       * Licensed under the Apache License, Version 2.0 (the 'License');
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *     http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an 'AS IS' BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ var _d,
        Id,
        Cd,
        Md,
        Ed,
        bd,
        Sd,
        Bd,
        Td,
        Ld,
        Dd = function (t, e, i, n) {
          for (
            var s,
              r = arguments.length,
              a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n,
              o = t.length - 1;
            o >= 0;
            o--
          )
            (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a)
          return r > 3 && a && Object.defineProperty(e, i, a), a
        }
      const Qd = document.createElement('canvas'),
        Rd = Symbol('template'),
        Pd = Symbol('fallbackResizeHandler'),
        Nd = Symbol('defaultAriaLabel'),
        Fd = Symbol('resizeObserver'),
        Ud = Symbol('clearModelTimeout'),
        kd = Symbol('onContextLost'),
        Od = Symbol('loaded'),
        Gd = Symbol('updateSize'),
        zd = Symbol('intersectionObserver'),
        Vd = Symbol('isElementInViewport'),
        Hd = Symbol('announceModelVisibility'),
        Wd = Symbol('ariaLabel'),
        qd = Symbol('loadedTime'),
        jd = Symbol('updateSource'),
        Yd = Symbol('markLoaded'),
        Jd = Symbol('container'),
        Xd = Symbol('input'),
        Kd = Symbol('canvas'),
        Zd = Symbol('scene'),
        $d = Symbol('needsRender'),
        tp = Symbol('tick'),
        ep = Symbol('onModelLoad'),
        ip = Symbol('onResize'),
        np = Symbol('renderer'),
        sp = Symbol('progressTracker'),
        rp = Symbol('getLoaded'),
        ap = Symbol('getModelIsVisible'),
        op = Symbol('shouldAttemptPreload'),
        lp = Symbol('sceneIsReady'),
        cp = Symbol('hasTransitioned'),
        hp = (t) => ({
          x: t.x,
          y: t.y,
          z: t.z,
          toString() {
            return `${this.x}m ${this.y}m ${this.z}m`
          },
        })
      class up extends N {
        constructor() {
          super(),
            (this.alt = null),
            (this.src = null),
            (this[_d] = !1),
            (this[Id] = !1),
            (this[Cd] = 0),
            (this[Md] = null),
            (this[Ed] = Uh(() => {
              const t = this.getBoundingClientRect()
              this[Gd](t)
            }, 50)),
            (this[bd] = Uh((t) => {
              const e = this.modelIsVisible
              e !== t && this.dispatchEvent(new CustomEvent('model-visibility', { detail: { visible: e } }))
            }, 0)),
            (this[Sd] = null),
            (this[Bd] = null),
            (this[Td] = new wd()),
            (this[Ld] = (t) => {
              this.dispatchEvent(
                new CustomEvent('error', { detail: { type: 'webglcontextlost', sourceError: t.sourceEvent } }),
              )
            })
          const t = this.constructor.template
          window.ShadyCSS && window.ShadyCSS.styleElement(this, {}), this.attachShadow({ mode: 'open' })
          const e = this.shadowRoot
          let i, n
          if (
            (e.appendChild(t.content.cloneNode(!0)),
            (this[Jd] = e.querySelector('.container')),
            (this[Xd] = e.querySelector('.userInput')),
            (this[Kd] = e.querySelector('canvas')),
            (this[Nd] = this[Xd].getAttribute('aria-label')),
            this.isConnected)
          ) {
            const t = this.getBoundingClientRect()
            ;(i = t.width), (n = t.height)
          } else (i = 300), (n = 150)
          ;(this[Zd] = new pu({ canvas: this[Kd], element: this, width: i, height: n })),
            this[Zd].addEventListener('model-load', async (t) => {
              this[Yd](),
                this[ep](),
                await ((t = 0) => new Promise((e) => setTimeout(e, t)))(),
                this.dispatchEvent(new CustomEvent('load', { detail: { url: t.url } }))
            }),
            Promise.resolve().then(() => {
              this[Gd](this.getBoundingClientRect())
            }),
            q &&
              (this[Fd] = new ResizeObserver((t) => {
                if (!this[np].isPresenting) for (let e of t) e.target === this && this[Gd](e.contentRect)
              })),
            j
              ? (this[zd] = new IntersectionObserver(
                  (t) => {
                    for (let e of t)
                      if (e.target === this) {
                        const t = this.modelIsVisible
                        ;(this[Vd] = e.isIntersecting), this[Hd](t), this[Vd] && !this[lp]() && this[jd]()
                      }
                  },
                  { root: null, rootMargin: '0px', threshold: 0 },
                ))
              : (this[Vd] = !0)
        }
        static get is() {
          return 'model-viewer'
        }
        static get template() {
          return (
            this.hasOwnProperty(Rd) ||
              (this[Rd] = ((t) => {
                const e = document.createElement('template')
                return (e.innerHTML = et.innerHTML), window.ShadyCSS && window.ShadyCSS.prepareTemplate(e, t), e
              })(this.is)),
            this[Rd]
          )
        }
        static set modelCacheSize(t) {
          bh[Mh].evictionThreshold = t
        }
        static get modelCacheSize() {
          return bh[Mh].evictionThreshold
        }
        static set minimumRenderScale(t) {
          gd.singleton.minScale = t
        }
        static get minimumRenderScale() {
          return gd.singleton.minScale
        }
        get loaded() {
          return this[rp]()
        }
        get [((_d = Vd),
        (Id = Od),
        (Cd = qd),
        (Md = Ud),
        (Ed = Pd),
        (bd = Hd),
        (Sd = Fd),
        (Bd = zd),
        (Td = sp),
        np)]() {
          return gd.singleton
        }
        get modelIsVisible() {
          return this[ap]()
        }
        connectedCallback() {
          super.connectedCallback && super.connectedCallback(),
            q ? this[Fd].observe(this) : self.addEventListener('resize', this[Pd]),
            j && this[zd].observe(this)
          const t = this[np]
          t.addEventListener('contextlost', this[kd]),
            t.registerScene(this[Zd]),
            null != this[Ud] && (self.clearTimeout(this[Ud]), (this[Ud] = null), this.requestUpdate('src', null))
        }
        disconnectedCallback() {
          super.disconnectedCallback && super.disconnectedCallback(),
            q ? this[Fd].unobserve(this) : self.removeEventListener('resize', this[Pd]),
            j && this[zd].unobserve(this)
          const t = this[np]
          t.removeEventListener('contextlost', this[kd]),
            t.unregisterScene(this[Zd]),
            (this[Ud] = self.setTimeout(() => {
              this[Zd].reset()
            }, 1e3))
        }
        updated(t) {
          if (
            (super.updated(t),
            t.has('src') &&
              (null == this.src
                ? ((this[Od] = !1), (this[qd] = 0), this[Zd].reset())
                : this.src !== this[Zd].url && ((this[Od] = !1), (this[qd] = 0), this[jd]())),
            t.has('alt'))
          ) {
            const t = null == this.alt ? this[Nd] : this.alt
            this[Xd].setAttribute('aria-label', t)
          }
        }
        toDataURL(t, e) {
          return this[np].displayCanvas(this[Zd]).toDataURL(t, e)
        }
        async toBlob(t) {
          const e = t ? t.mimeType : void 0,
            i = t ? t.qualityArgument : void 0,
            n = t ? t.idealAspect : void 0,
            { width: s, height: r, fieldOfViewAspect: a, aspect: o } = this[Zd],
            { dpr: l, scaleFactor: c } = this[np]
          let h = s * c * l,
            u = r * c * l,
            d = 0,
            p = 0
          if (!0 === n)
            if (a > o) {
              const t = u
              ;(u = Math.round(h / a)), (p = (t - u) / 2)
            } else {
              const t = h
              ;(h = Math.round(u * a)), (d = (t - h) / 2)
            }
          ;(Qd.width = h), (Qd.height = u)
          try {
            return new Promise(
              async (t, n) => (
                Qd.getContext('2d').drawImage(this[np].displayCanvas(this[Zd]), d, p, h, u, 0, 0, h, u),
                !Qd.msToBlob || (e && 'image/png' !== e)
                  ? Qd.toBlob
                    ? void Qd.toBlob(
                        (e) => {
                          if (!e) return n(new Error('Unable to retrieve canvas blob'))
                          t(e)
                        },
                        e,
                        i,
                      )
                    : t(
                        await (async (t) =>
                          new Promise((e, i) => {
                            const n = t.match(/data:(.*);/)
                            if (!n) return i(new Error(`${t} is not a valid data Url`))
                            const s = n[1],
                              r = t.replace(/data:image\/\w+;base64,/, ''),
                              a = atob(r),
                              o = []
                            for (let t = 0; t < a.length; t += 512) {
                              const e = a.slice(t, t + 512),
                                i = new Array(e.length)
                              for (let t = 0; t < e.length; t++) i[t] = e.charCodeAt(t)
                              const n = new Uint8Array(i)
                              o.push(n)
                            }
                            e(new Blob(o, { type: s }))
                          }))(Qd.toDataURL(e, i)),
                      )
                  : t(Qd.msToBlob())
              ),
            )
          } finally {
            this[Gd]({ width: s, height: r })
          }
        }
        registerRenderer(t) {
          this[Zd].externalRenderer = t
        }
        unregisterRenderer() {
          this[Zd].externalRenderer = null
        }
        get [Wd]() {
          return null == this.alt || 'null' === this.alt ? this[Nd] : this.alt
        }
        [rp]() {
          return this[Od]
        }
        [ap]() {
          return this.loaded && this[Vd]
        }
        [cp]() {
          return this.modelIsVisible
        }
        [op]() {
          return !!this.src && this[Vd]
        }
        [lp]() {
          return this[Od]
        }
        [Gd]({ width: t, height: e }) {
          ;(this[Jd].style.width = `${t}px`),
            (this[Jd].style.height = `${e}px`),
            this[ip]({ width: parseFloat(t), height: parseFloat(e) })
        }
        [tp](t, e) {}
        [Yd]() {
          this[Od] || ((this[Od] = !0), (this[qd] = performance.now()))
        }
        [$d]() {
          this[Zd].isDirty = !0
        }
        [ep]() {}
        [ip](t) {
          this[Zd].setSize(t.width, t.height)
        }
        async [((Ld = kd), jd)]() {
          if (this.loaded || !this[op]()) return
          const t = this[sp].beginActivity(),
            e = this.src
          try {
            await this[Zd].setSource(e, (e) => t(0.8 * e))
            const i = { url: e }
            this.dispatchEvent(new CustomEvent('preload', { detail: i }))
          } catch (t) {
            this.dispatchEvent(new CustomEvent('error', { detail: t }))
          } finally {
            t(0.9),
              requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                  t(1)
                })
              })
          }
        }
      }
      Dd([U({ type: String })], up.prototype, 'alt', void 0), Dd([U({ type: String })], up.prototype, 'src', void 0)
      /* @license
       * Copyright 2019 Google LLC. All Rights Reserved.
       * Licensed under the Apache License, Version 2.0 (the 'License');
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *     http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an 'AS IS' BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */
      var dp = function (t, e, i, n) {
        for (
          var s,
            r = arguments.length,
            a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n,
            o = t.length - 1;
          o >= 0;
          o--
        )
          (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a)
        return r > 3 && a && Object.defineProperty(e, i, a), a
      }
      const pp = Symbol('changeAnimation'),
        Ap = Symbol('paused'),
        gp = Symbol('hotspotMap'),
        mp = Symbol('mutationCallback'),
        fp = Symbol('observer'),
        vp = Symbol('addHotspot'),
        yp = Symbol('removeHotspot'),
        xp = new gt(),
        wp = new ne(),
        _p = new mt()
      /*!
fflate - fast JavaScript compression/decompression
<https://101arrowz.github.io/fflate>
Licensed under MIT. https://github.com/101arrowz/fflate/blob/master/LICENSE
version 0.6.9
*/ var Ip = function (t) {
        return URL.createObjectURL(new Blob([t], { type: 'text/javascript' }))
      }
      try {
        URL.revokeObjectURL(Ip(''))
      } catch (Fc) {
        Ip = function (t) {
          return 'data:application/javascript;charset=UTF-8,' + encodeURI(t)
        }
      }
      var Cp = Uint8Array,
        Mp = Uint16Array,
        Ep = Uint32Array,
        bp = new Cp([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]),
        Sp = new Cp([
          0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0,
        ]),
        Bp = new Cp([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]),
        Tp = function (t, e) {
          for (var i = new Mp(31), n = 0; n < 31; ++n) i[n] = e += 1 << t[n - 1]
          var s = new Ep(i[30])
          for (n = 1; n < 30; ++n) for (var r = i[n]; r < i[n + 1]; ++r) s[r] = ((r - i[n]) << 5) | n
          return [i, s]
        },
        Lp = Tp(bp, 2),
        Dp = Lp[0],
        Qp = Lp[1]
      ;(Dp[28] = 258), (Qp[258] = 28)
      for (var Rp = Tp(Sp, 0)[1], Pp = new Mp(32768), Np = 0; Np < 32768; ++Np) {
        var Fp = ((43690 & Np) >>> 1) | ((21845 & Np) << 1)
        ;(Fp = ((61680 & (Fp = ((52428 & Fp) >>> 2) | ((13107 & Fp) << 2))) >>> 4) | ((3855 & Fp) << 4)),
          (Pp[Np] = (((65280 & Fp) >>> 8) | ((255 & Fp) << 8)) >>> 1)
      }
      var Up = function (t, e, i) {
          for (var n = t.length, s = 0, r = new Mp(e); s < n; ++s) ++r[t[s] - 1]
          var a,
            o = new Mp(e)
          for (s = 0; s < e; ++s) o[s] = (o[s - 1] + r[s - 1]) << 1
          if (i) {
            a = new Mp(1 << e)
            var l = 15 - e
            for (s = 0; s < n; ++s)
              if (t[s])
                for (var c = (s << 4) | t[s], h = e - t[s], u = o[t[s] - 1]++ << h, d = u | ((1 << h) - 1); u <= d; ++u)
                  a[Pp[u] >>> l] = c
          } else for (a = new Mp(n), s = 0; s < n; ++s) t[s] && (a[s] = Pp[o[t[s] - 1]++] >>> (15 - t[s]))
          return a
        },
        kp = new Cp(288)
      for (Np = 0; Np < 144; ++Np) kp[Np] = 8
      for (Np = 144; Np < 256; ++Np) kp[Np] = 9
      for (Np = 256; Np < 280; ++Np) kp[Np] = 7
      for (Np = 280; Np < 288; ++Np) kp[Np] = 8
      var Op = new Cp(32)
      for (Np = 0; Np < 32; ++Np) Op[Np] = 5
      var Gp = Up(kp, 9, 0),
        zp = Up(Op, 5, 0),
        Vp = function (t) {
          return ((t / 8) | 0) + (7 & t && 1)
        },
        Hp = function (t, e, i) {
          ;(null == e || e < 0) && (e = 0), (null == i || i > t.length) && (i = t.length)
          var n = new (t instanceof Mp ? Mp : t instanceof Ep ? Ep : Cp)(i - e)
          return n.set(t.subarray(e, i)), n
        },
        Wp = function (t, e, i) {
          i <<= 7 & e
          var n = (e / 8) | 0
          ;(t[n] |= i), (t[n + 1] |= i >>> 8)
        },
        qp = function (t, e, i) {
          i <<= 7 & e
          var n = (e / 8) | 0
          ;(t[n] |= i), (t[n + 1] |= i >>> 8), (t[n + 2] |= i >>> 16)
        },
        jp = function (t, e) {
          for (var i = [], n = 0; n < t.length; ++n) t[n] && i.push({ s: n, f: t[n] })
          var s = i.length,
            r = i.slice()
          if (!s) return [tA, 0]
          if (1 == s) {
            var a = new Cp(i[0].s + 1)
            return (a[i[0].s] = 1), [a, 1]
          }
          i.sort(function (t, e) {
            return t.f - e.f
          }),
            i.push({ s: -1, f: 25001 })
          var o = i[0],
            l = i[1],
            c = 0,
            h = 1,
            u = 2
          for (i[0] = { s: -1, f: o.f + l.f, l: o, r: l }; h != s - 1; )
            (o = i[i[c].f < i[u].f ? c++ : u++]),
              (l = i[c != h && i[c].f < i[u].f ? c++ : u++]),
              (i[h++] = { s: -1, f: o.f + l.f, l: o, r: l })
          var d = r[0].s
          for (n = 1; n < s; ++n) r[n].s > d && (d = r[n].s)
          var p = new Mp(d + 1),
            A = Yp(i[h - 1], p, 0)
          if (A > e) {
            n = 0
            var g = 0,
              m = A - e,
              f = 1 << m
            for (
              r.sort(function (t, e) {
                return p[e.s] - p[t.s] || t.f - e.f
              });
              n < s;
              ++n
            ) {
              var v = r[n].s
              if (!(p[v] > e)) break
              ;(g += f - (1 << (A - p[v]))), (p[v] = e)
            }
            for (g >>>= m; g > 0; ) {
              var y = r[n].s
              p[y] < e ? (g -= 1 << (e - p[y]++ - 1)) : ++n
            }
            for (; n >= 0 && g; --n) {
              var x = r[n].s
              p[x] == e && (--p[x], ++g)
            }
            A = e
          }
          return [new Cp(p), A]
        },
        Yp = function (t, e, i) {
          return -1 == t.s ? Math.max(Yp(t.l, e, i + 1), Yp(t.r, e, i + 1)) : (e[t.s] = i)
        },
        Jp = function (t) {
          for (var e = t.length; e && !t[--e]; );
          for (
            var i = new Mp(++e),
              n = 0,
              s = t[0],
              r = 1,
              a = function (t) {
                i[n++] = t
              },
              o = 1;
            o <= e;
            ++o
          )
            if (t[o] == s && o != e) ++r
            else {
              if (!s && r > 2) {
                for (; r > 138; r -= 138) a(32754)
                r > 2 && (a(r > 10 ? ((r - 11) << 5) | 28690 : ((r - 3) << 5) | 12305), (r = 0))
              } else if (r > 3) {
                for (a(s), --r; r > 6; r -= 6) a(8304)
                r > 2 && (a(((r - 3) << 5) | 8208), (r = 0))
              }
              for (; r--; ) a(s)
              ;(r = 1), (s = t[o])
            }
          return [i.subarray(0, n), e]
        },
        Xp = function (t, e) {
          for (var i = 0, n = 0; n < e.length; ++n) i += t[n] * e[n]
          return i
        },
        Kp = function (t, e, i) {
          var n = i.length,
            s = Vp(e + 2)
          ;(t[s] = 255 & n), (t[s + 1] = n >>> 8), (t[s + 2] = 255 ^ t[s]), (t[s + 3] = 255 ^ t[s + 1])
          for (var r = 0; r < n; ++r) t[s + r + 4] = i[r]
          return 8 * (s + 4 + n)
        },
        Zp = function (t, e, i, n, s, r, a, o, l, c, h) {
          Wp(e, h++, i), ++s[256]
          for (
            var u = jp(s, 15),
              d = u[0],
              p = u[1],
              A = jp(r, 15),
              g = A[0],
              m = A[1],
              f = Jp(d),
              v = f[0],
              y = f[1],
              x = Jp(g),
              w = x[0],
              _ = x[1],
              I = new Mp(19),
              C = 0;
            C < v.length;
            ++C
          )
            I[31 & v[C]]++
          for (C = 0; C < w.length; ++C) I[31 & w[C]]++
          for (var M = jp(I, 7), E = M[0], b = M[1], S = 19; S > 4 && !E[Bp[S - 1]]; --S);
          var B,
            T,
            L,
            D,
            Q = (c + 5) << 3,
            R = Xp(s, kp) + Xp(r, Op) + a,
            P = Xp(s, d) + Xp(r, g) + a + 14 + 3 * S + Xp(I, E) + (2 * I[16] + 3 * I[17] + 7 * I[18])
          if (Q <= R && Q <= P) return Kp(e, h, t.subarray(l, l + c))
          if ((Wp(e, h, 1 + (P < R)), (h += 2), P < R)) {
            ;(B = Up(d, p, 0)), (T = d), (L = Up(g, m, 0)), (D = g)
            var N = Up(E, b, 0)
            for (Wp(e, h, y - 257), Wp(e, h + 5, _ - 1), Wp(e, h + 10, S - 4), h += 14, C = 0; C < S; ++C)
              Wp(e, h + 3 * C, E[Bp[C]])
            h += 3 * S
            for (var F = [v, w], U = 0; U < 2; ++U) {
              var k = F[U]
              for (C = 0; C < k.length; ++C) {
                var O = 31 & k[C]
                Wp(e, h, N[O]), (h += E[O]), O > 15 && (Wp(e, h, (k[C] >>> 5) & 127), (h += k[C] >>> 12))
              }
            }
          } else (B = Gp), (T = kp), (L = zp), (D = Op)
          for (C = 0; C < o; ++C)
            if (n[C] > 255) {
              ;(O = (n[C] >>> 18) & 31),
                qp(e, h, B[O + 257]),
                (h += T[O + 257]),
                O > 7 && (Wp(e, h, (n[C] >>> 23) & 31), (h += bp[O]))
              var G = 31 & n[C]
              qp(e, h, L[G]), (h += D[G]), G > 3 && (qp(e, h, (n[C] >>> 5) & 8191), (h += Sp[G]))
            } else qp(e, h, B[n[C]]), (h += T[n[C]])
          return qp(e, h, B[256]), h + T[256]
        },
        $p = new Ep([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]),
        tA = new Cp(0),
        eA = (function () {
          for (var t = new Ep(256), e = 0; e < 256; ++e) {
            for (var i = e, n = 9; --n; ) i = (1 & i && 3988292384) ^ (i >>> 1)
            t[e] = i
          }
          return t
        })(),
        iA = function () {
          var t = -1
          return {
            p: function (e) {
              for (var i = t, n = 0; n < e.length; ++n) i = eA[(255 & i) ^ e[n]] ^ (i >>> 8)
              t = i
            },
            d: function () {
              return ~t
            },
          }
        },
        nA = function (t, e) {
          var i = {}
          for (var n in t) i[n] = t[n]
          for (var n in e) i[n] = e[n]
          return i
        },
        sA = function (t, e, i) {
          for (; i; ++e) (t[e] = i), (i >>>= 8)
        }
      function rA(t, e) {
        return (function (t, e, i, n, s) {
          return (function (t, e, i, n, s, r) {
            var a = t.length,
              o = new Cp(n + a + 5 * (1 + Math.ceil(a / 7e3)) + s),
              l = o.subarray(n, o.length - s),
              c = 0
            if (!e || a < 8)
              for (var h = 0; h <= a; h += 65535) {
                var u = h + 65535
                u < a ? (c = Kp(l, c, t.subarray(h, u))) : ((l[h] = r), (c = Kp(l, c, t.subarray(h, a))))
              }
            else {
              for (
                var d = $p[e - 1],
                  p = d >>> 13,
                  A = 8191 & d,
                  g = (1 << i) - 1,
                  m = new Mp(32768),
                  f = new Mp(g + 1),
                  v = Math.ceil(i / 3),
                  y = 2 * v,
                  x = function (e) {
                    return (t[e] ^ (t[e + 1] << v) ^ (t[e + 2] << y)) & g
                  },
                  w = new Ep(25e3),
                  _ = new Mp(288),
                  I = new Mp(32),
                  C = 0,
                  M = 0,
                  E = ((h = 0), 0),
                  b = 0,
                  S = 0;
                h < a;
                ++h
              ) {
                var B = x(h),
                  T = 32767 & h,
                  L = f[B]
                if (((m[T] = L), (f[B] = T), b <= h)) {
                  var D = a - h
                  if ((C > 7e3 || E > 24576) && D > 423) {
                    ;(c = Zp(t, l, 0, w, _, I, M, E, S, h - S, c)), (E = C = M = 0), (S = h)
                    for (var Q = 0; Q < 286; ++Q) _[Q] = 0
                    for (Q = 0; Q < 30; ++Q) I[Q] = 0
                  }
                  var R = 2,
                    P = 0,
                    N = A,
                    F = (T - L) & 32767
                  if (D > 2 && B == x(h - F))
                    for (
                      var U = Math.min(p, D) - 1, k = Math.min(32767, h), O = Math.min(258, D);
                      F <= k && --N && T != L;

                    ) {
                      if (t[h + R] == t[h + R - F]) {
                        for (var G = 0; G < O && t[h + G] == t[h + G - F]; ++G);
                        if (G > R) {
                          if (((R = G), (P = F), G > U)) break
                          var z = Math.min(F, G - 2),
                            V = 0
                          for (Q = 0; Q < z; ++Q) {
                            var H = (h - F + Q + 32768) & 32767,
                              W = (H - m[H] + 32768) & 32767
                            W > V && ((V = W), (L = H))
                          }
                        }
                      }
                      F += ((T = L) - (L = m[T]) + 32768) & 32767
                    }
                  if (P) {
                    w[E++] = 268435456 | (Qp[R] << 18) | Rp[P]
                    var q = 31 & Qp[R],
                      j = 31 & Rp[P]
                    ;(M += bp[q] + Sp[j]), ++_[257 + q], ++I[j], (b = h + R), ++C
                  } else (w[E++] = t[h]), ++_[t[h]]
                }
              }
              ;(c = Zp(t, l, r, w, _, I, M, E, S, h - S, c)), !r && 7 & c && (c = Kp(l, c + 1, tA))
            }
            return Hp(o, 0, n + Vp(c) + s)
          })(
            t,
            null == e.level ? 6 : e.level,
            null == e.mem ? Math.ceil(1.5 * Math.max(8, Math.min(13, Math.log(t.length)))) : 12 + e.mem,
            i,
            n,
            !s,
          )
        })(t, e || {}, 0, 0)
      }
      var aA = function (t, e, i, n) {
          for (var s in t) {
            var r = t[s],
              a = e + s
            r instanceof Cp ? (i[a] = [r, n]) : Array.isArray(r) ? (i[a] = [r[0], nA(n, r[1])]) : aA(r, a + '/', i, n)
          }
        },
        oA = 'undefined' != typeof TextEncoder && new TextEncoder(),
        lA = 'undefined' != typeof TextDecoder && new TextDecoder()
      try {
        lA.decode(tA, { stream: !0 })
      } catch (Fc) {}
      function cA(t, e) {
        if (e) {
          for (var i = new Cp(t.length), n = 0; n < t.length; ++n) i[n] = t.charCodeAt(n)
          return i
        }
        if (oA) return oA.encode(t)
        var s = t.length,
          r = new Cp(t.length + (t.length >> 1)),
          a = 0,
          o = function (t) {
            r[a++] = t
          }
        for (n = 0; n < s; ++n) {
          if (a + 5 > r.length) {
            var l = new Cp(a + 8 + ((s - n) << 1))
            l.set(r), (r = l)
          }
          var c = t.charCodeAt(n)
          c < 128 || e
            ? o(c)
            : c < 2048
            ? (o(192 | (c >> 6)), o(128 | (63 & c)))
            : c > 55295 && c < 57344
            ? (o(240 | ((c = (65536 + (1047552 & c)) | (1023 & t.charCodeAt(++n))) >> 18)),
              o(128 | ((c >> 12) & 63)),
              o(128 | ((c >> 6) & 63)),
              o(128 | (63 & c)))
            : (o(224 | (c >> 12)), o(128 | ((c >> 6) & 63)), o(128 | (63 & c)))
        }
        return Hp(r, 0, a)
      }
      var hA = function (t) {
          var e = 0
          if (t)
            for (var i in t) {
              var n = t[i].length
              if (n > 65535) throw 'extra field too long'
              e += n + 4
            }
          return e
        },
        uA = function (t, e, i, n, s, r, a, o) {
          var l = n.length,
            c = i.extra,
            h = o && o.length,
            u = hA(c)
          sA(t, e, null != a ? 33639248 : 67324752),
            (e += 4),
            null != a && ((t[e++] = 20), (t[e++] = i.os)),
            (t[e] = 20),
            (e += 2),
            (t[e++] = (i.flag << 1) | (null == r && 8)),
            (t[e++] = s && 8),
            (t[e++] = 255 & i.compression),
            (t[e++] = i.compression >> 8)
          var d = new Date(null == i.mtime ? Date.now() : i.mtime),
            p = d.getFullYear() - 1980
          if (p < 0 || p > 119) throw 'date not in range 1980-2099'
          if (
            (sA(
              t,
              e,
              (p << 25) |
                ((d.getMonth() + 1) << 21) |
                (d.getDate() << 16) |
                (d.getHours() << 11) |
                (d.getMinutes() << 5) |
                (d.getSeconds() >>> 1),
            ),
            (e += 4),
            null != r && (sA(t, e, i.crc), sA(t, e + 4, r), sA(t, e + 8, i.size)),
            sA(t, e + 12, l),
            sA(t, e + 14, u),
            (e += 16),
            null != a && (sA(t, e, h), sA(t, e + 6, i.attrs), sA(t, e + 10, a), (e += 14)),
            t.set(n, e),
            (e += l),
            u)
          )
            for (var A in c) {
              var g = c[A],
                m = g.length
              sA(t, e, +A), sA(t, e + 2, m), t.set(g, e + 4), (e += 4 + m)
            }
          return h && (t.set(o, e), (e += h)), e
        }
      class dA {
        async parse(t) {
          const e = { 'model.usda': null }
          let i =
            '#usda 1.0\n(\n    customLayerData = {\n        string creator = "Three.js USDZExporter"\n    }\n    metersPerUnit = 1\n    upAxis = "Y"\n)\n\n'
          const n = {},
            s = {}
          t.traverseVisible((t) => {
            if (t.isMesh && t.material.isMeshStandardMaterial) {
              const s = t.geometry,
                r = t.material,
                a = 'geometries/Geometry_' + s.id + '.usd'
              if (!(a in e)) {
                const t = (function (t) {
                  return `\ndef "Geometry"\n{\n  ${(function (t) {
                    const e = t.attributes,
                      i = e.position.count
                    return `\n    def Mesh "Geometry"\n    {\n        int[] faceVertexCounts = [${(function (t) {
                      const e = null !== t.index ? t.index.array.length : t.attributes.position.count
                      return Array(e / 3)
                        .fill(3)
                        .join(', ')
                    })(t)}]\n        int[] faceVertexIndices = [${(function (t) {
                      if (null !== t.index) return t.index.array.join(', ')
                      const e = [],
                        i = t.attributes.position.count
                      for (let n = 0; n < i; n++) e.push(n)
                      return e.join(', ')
                    })(t)}]\n        normal3f[] normals = [${gA(
                      e.normal,
                      i,
                    )}] (\n            interpolation = "vertex"\n        )\n        point3f[] points = [${gA(
                      e.position,
                      i,
                    )}]\n        float2[] primvars:st = [${(function (t, e) {
                      if (void 0 === t) return Array(e).fill('(0, 0)').join(', ')
                      const i = [],
                        n = t.array
                      for (let s = 0; s < n.length; s += 2)
                        i.push(`(${n[s + 0].toPrecision(7)}, ${1 - n[s + 1].toPrecision(7)})`)
                      return i.join(', ')
                    })(
                      e.uv,
                      i,
                    )}] (\n            interpolation = "vertex"\n        )\n        uniform token subdivisionScheme = "none"\n    }\n`
                  })(t)}\n}\n`
                })(s)
                e[a] = (function (t) {
                  let e =
                    '#usda 1.0\n(\n    customLayerData = {\n        string creator = "Three.js USDZExporter"\n    }\n    metersPerUnit = 1\n    upAxis = "Y"\n)\n\n'
                  return (e += t), cA(e)
                })(t)
              }
              r.uuid in n || (n[r.uuid] = r),
                (i += (function (t, e, i) {
                  const n = 'Object_' + t.id,
                    s = (function (t) {
                      const e = t.elements
                      return `( ${AA(e, 0)}, ${AA(e, 4)}, ${AA(e, 8)}, ${AA(e, 12)} )`
                    })(t.matrixWorld)
                  return (
                    t.matrixWorld.determinant(),
                    `def Xform "${n}" (\n    prepend references = @./geometries/Geometry_${e.id}.usd@</Geometry>\n)\n{\n    matrix4d xformOp:transform = ${s}\n    uniform token[] xformOpOrder = ["xformOp:transform"]\n\n    rel material:binding = </Materials/Material_${i.id}>\n}\n\n`
                  )
                })(t, s, r))
            }
          }),
            (i += (function (t, e) {
              const i = []
              for (const n in t) {
                const s = t[n]
                i.push(mA(s, e))
              }
              return `def "Materials"\n{\n${i.join('')}\n}\n\n`
            })(n, s)),
            (e['model.usda'] = cA(i)),
            (i = null)
          for (const a in s) {
            const t = s[a],
              i = a.split('_')[1],
              n = 1023 === t.format,
              r = pA(t.image, i),
              o = await new Promise((t) => r.toBlob(t, n ? 'image/png' : 'image/jpeg', 1))
            e[`textures/Texture_${a}.${n ? 'png' : 'jpg'}`] = new Uint8Array(await o.arrayBuffer())
          }
          let r = 0
          for (const a in e) {
            const t = e[a]
            r += 34 + a.length
            const i = 63 & r
            if (4 !== i) {
              const n = new Uint8Array(64 - i)
              e[a] = [t, { extra: { 12345: n } }]
            }
            r = t.length
          }
          return (function (t, e) {
            e || (e = {})
            var i = {},
              n = []
            aA(t, '', i, e)
            var s = 0,
              r = 0
            for (var a in i) {
              var o = i[a],
                l = o[0],
                c = o[1],
                h = 0 == c.level ? 0 : 8,
                u = (I = cA(a)).length,
                d = c.comment,
                p = d && cA(d),
                A = p && p.length,
                g = hA(c.extra)
              if (u > 65535) throw 'filename too long'
              var m = h ? rA(l, c) : l,
                f = m.length,
                v = iA()
              v.p(l),
                n.push(
                  nA(c, {
                    size: l.length,
                    crc: v.d(),
                    c: m,
                    f: I,
                    m: p,
                    u: u != a.length || (p && d.length != A),
                    o: s,
                    compression: h,
                  }),
                ),
                (s += 30 + u + g + f),
                (r += 76 + 2 * (u + g) + (A || 0) + f)
            }
            for (var y = new Cp(r + 22), x = s, w = r - s, _ = 0; _ < n.length; ++_) {
              var I = n[_]
              uA(y, I.o, I, I.f, I.u, I.c.length)
              var C = 30 + I.f.length + hA(I.extra)
              y.set(I.c, I.o + C), uA(y, s, I, I.f, I.u, I.c.length, I.o, I.m), (s += 16 + C + (I.m ? I.m.length : 0))
            }
            return (
              (function (t, e, i, n, s) {
                sA(t, e, 101010256), sA(t, e + 8, i), sA(t, e + 10, i), sA(t, e + 12, n), sA(t, e + 16, s)
              })(y, s, n.length, w, x),
              y
            )
          })(e, { level: 0 })
        }
      }
      function pA(t, e) {
        if (
          ('undefined' != typeof HTMLImageElement && t instanceof HTMLImageElement) ||
          ('undefined' != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement) ||
          ('undefined' != typeof OffscreenCanvas && t instanceof OffscreenCanvas) ||
          ('undefined' != typeof ImageBitmap && t instanceof ImageBitmap)
        ) {
          const i = 1024 / Math.max(t.width, t.height),
            n = document.createElement('canvas')
          ;(n.width = t.width * Math.min(1, i)), (n.height = t.height * Math.min(1, i))
          const s = n.getContext('2d')
          if ((s.drawImage(t, 0, 0, n.width, n.height), void 0 !== e)) {
            const t = parseInt(e, 16),
              i = ((t >> 16) & 255) / 255,
              r = ((t >> 8) & 255) / 255,
              a = (255 & t) / 255,
              o = s.getImageData(0, 0, n.width, n.height),
              l = o.data
            for (let e = 0; e < l.length; e += 4)
              (l[e + 0] = l[e + 0] * i), (l[e + 1] = l[e + 1] * r), (l[e + 2] = l[e + 2] * a)
            s.putImageData(o, 0, 0)
          }
          return n
        }
      }
      function AA(t, e) {
        return `(${t[e + 0]}, ${t[e + 1]}, ${t[e + 2]}, ${t[e + 3]})`
      }
      function gA(t, e) {
        if (void 0 === t) return Array(e).fill('(0, 0, 0)').join(', ')
        const i = [],
          n = t.array
        for (let s = 0; s < n.length; s += 3)
          i.push(`(${n[s + 0].toPrecision(7)}, ${n[s + 1].toPrecision(7)}, ${n[s + 2].toPrecision(7)})`)
        return i.join(', ')
      }
      function mA(t, e) {
        const i = '            ',
          n = [],
          s = []
        function r(i, n, s) {
          const r = i.id + (s ? '_' + s.getHexString() : ''),
            a = 1023 === i.format
          return (
            (e[r] = i),
            `\n        def Shader "Transform2d_${n}" (\n            sdrMetadata = {\n                string role = "math"\n            }\n        )\n        {\n            uniform token info:id = "UsdTransform2d"\n            float2 inputs:in.connect = </Materials/Material_${
              t.id
            }/uvReader_st.outputs:result>\n            float2 inputs:scale = ${vA(
              i.repeat,
            )}\n            float2 inputs:translation = ${vA(
              i.offset,
            )}\n            float2 outputs:result\n        }\n\n        def Shader "Texture_${
              i.id
            }_${n}"\n        {\n            uniform token info:id = "UsdUVTexture"\n            asset inputs:file = @textures/Texture_${r}.${
              a ? 'png' : 'jpg'
            }@\n            float2 inputs:st.connect = </Materials/Material_${
              t.id
            }/Transform2d_${n}.outputs:result>\n            token inputs:wrapS = "repeat"\n            token inputs:wrapT = "repeat"\n            float outputs:r\n            float outputs:g\n            float outputs:b\n            float3 outputs:rgb\n        }`
          )
        }
        return (
          null !== t.map
            ? (n.push(
                `${i}color3f inputs:diffuseColor.connect = </Materials/Material_${t.id}/Texture_${t.map.id}_diffuse.outputs:rgb>`,
              ),
              s.push(r(t.map, 'diffuse', t.color)))
            : n.push(`${i}color3f inputs:diffuseColor = ${fA(t.color)}`),
          null !== t.emissiveMap
            ? (n.push(
                `${i}color3f inputs:emissiveColor.connect = </Materials/Material_${t.id}/Texture_${t.emissiveMap.id}_emissive.outputs:rgb>`,
              ),
              s.push(r(t.emissiveMap, 'emissive')))
            : t.emissive.getHex() > 0 && n.push(`${i}color3f inputs:emissiveColor = ${fA(t.emissive)}`),
          null !== t.normalMap &&
            (n.push(
              `${i}normal3f inputs:normal.connect = </Materials/Material_${t.id}/Texture_${t.normalMap.id}_normal.outputs:rgb>`,
            ),
            s.push(r(t.normalMap, 'normal'))),
          null !== t.aoMap &&
            (n.push(
              `${i}float inputs:occlusion.connect = </Materials/Material_${t.id}/Texture_${t.aoMap.id}_occlusion.outputs:r>`,
            ),
            s.push(r(t.aoMap, 'occlusion'))),
          null !== t.roughnessMap && 1 === t.roughness
            ? (n.push(
                `${i}float inputs:roughness.connect = </Materials/Material_${t.id}/Texture_${t.roughnessMap.id}_roughness.outputs:g>`,
              ),
              s.push(r(t.roughnessMap, 'roughness')))
            : n.push(`${i}float inputs:roughness = ${t.roughness}`),
          null !== t.metalnessMap && 1 === t.metalness
            ? (n.push(
                `${i}float inputs:metallic.connect = </Materials/Material_${t.id}/Texture_${t.metalnessMap.id}_metallic.outputs:b>`,
              ),
              s.push(r(t.metalnessMap, 'metallic')))
            : n.push(`${i}float inputs:metallic = ${t.metalness}`),
          n.push(`${i}float inputs:opacity = ${t.opacity}`),
          t.isMeshPhysicalMaterial &&
            (n.push(`${i}float inputs:clearcoat = ${t.clearcoat}`),
            n.push(`${i}float inputs:clearcoatRoughness = ${t.clearcoatRoughness}`),
            n.push(`${i}float inputs:ior = ${t.ior}`)),
          `\n    def Material "Material_${
            t.id
          }"\n    {\n        def Shader "PreviewSurface"\n        {\n            uniform token info:id = "UsdPreviewSurface"\n${n.join(
            '\n',
          )}\n            int inputs:useSpecularWorkflow = 0\n            token outputs:surface\n        }\n\n        token outputs:surface.connect = </Materials/Material_${
            t.id
          }/PreviewSurface.outputs:surface>\n        token inputs:frame:stPrimvarName = "st"\n\n        def Shader "uvReader_st"\n        {\n            uniform token info:id = "UsdPrimvarReader_float2"\n            token inputs:varname.connect = </Materials/Material_${
            t.id
          }.inputs:frame:stPrimvarName>\n            float2 inputs:fallback = (0.0, 0.0)\n            float2 outputs:result\n        }\n\n${s.join(
            '\n',
          )}\n\n    }\n`
        )
      }
      function fA(t) {
        return `(${t.r}, ${t.g}, ${t.b})`
      }
      function vA(t) {
        return `(${t.x}, ${t.y})`
        /* @license
         * Copyright 2019 Google LLC. All Rights Reserved.
         * Licensed under the Apache License, Version 2.0 (the 'License');
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *     http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an 'AS IS' BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        /* @license
         * Copyright 2019 Google LLC. All Rights Reserved.
         * Licensed under the Apache License, Version 2.0 (the 'License');
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *     http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an 'AS IS' BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
      }
      var yA = function (t, e, i, n) {
        for (
          var s,
            r = arguments.length,
            a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n,
            o = t.length - 1;
          o >= 0;
          o--
        )
          (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a)
        return r > 3 && a && Object.defineProperty(e, i, a), a
      }
      let xA = !1,
        wA = !1
      const _A =
        ((IA = ['quick-look', 'scene-viewer', 'webxr', 'none']),
        (t) => {
          try {
            const e = Hh(t),
              i = (e.length ? e[0].terms : [])
                .filter((t) => t && 'ident' === t.type)
                .map((t) => t.value)
                .filter((t) => IA.indexOf(t) > -1),
              n = new Set()
            for (const t of i) n.add(t)
            return n
          } catch (t) {}
          return new Set()
        })
      var IA
      const CA = 'quick-look',
        MA = 'scene-viewer',
        EA = 'webxr',
        bA = 'none',
        SA = Symbol('arButtonContainer'),
        BA = Symbol('enterARWithWebXR'),
        TA = Symbol('openSceneViewer'),
        LA = Symbol('openIOSARQuickLook'),
        DA = Symbol('canActivateAR'),
        QA = Symbol('arMode'),
        RA = Symbol('arModes'),
        PA = Symbol('arAnchor'),
        NA = Symbol('preload'),
        FA = Symbol('onARButtonContainerClick'),
        UA = Symbol('onARStatus'),
        kA = Symbol('onARTracking'),
        OA = Symbol('onARTap'),
        GA = Symbol('selectARMode'),
        zA = Symbol('triggerLoad')
      /* @license
       * Copyright 2019 Google LLC. All Rights Reserved.
       * Licensed under the Apache License, Version 2.0 (the 'License');
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *     http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an 'AS IS' BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ var VA, HA, WA
      const qA = Symbol('evaluate'),
        jA = Symbol('lastValue')
      class YA {
        constructor() {
          this[VA] = null
        }
        static evaluatableFor(t, e = Zh) {
          if (t instanceof YA) return t
          if ('number' === t.type) return '%' === t.unit ? new KA(t, e) : t
          switch (t.name.value) {
            case 'calc':
              return new ig(t, e)
            case 'env':
              return new $A(t)
          }
          return Zh
        }
        static evaluate(t) {
          return t instanceof YA ? t.evaluate() : t
        }
        static isConstant(t) {
          return !(t instanceof YA) || t.isConstant
        }
        static applyIntrinsics(t, e) {
          const { basis: i, keywords: n } = e,
            { auto: s } = n
          return i.map((e, i) => {
            const r = null == s[i] ? e : s[i]
            let a = t[i] ? t[i] : r
            if ('ident' === a.type) {
              const t = a.value
              t in n && (a = n[t][i])
            }
            return (
              (null != a && 'ident' !== a.type) || (a = r),
              '%' === a.unit ? Vh((a.number / 100) * e.number, e.unit) : ((a = eu(a, e)), a.unit !== e.unit ? e : a)
            )
          })
        }
        get isConstant() {
          return !1
        }
        evaluate() {
          return (this.isConstant && null != this[jA]) || (this[jA] = this[qA]()), this[jA]
        }
      }
      VA = jA
      const JA = Symbol('percentage'),
        XA = Symbol('basis')
      class KA extends YA {
        constructor(t, e) {
          super(), (this[JA] = t), (this[XA] = e)
        }
        get isConstant() {
          return !0
        }
        [qA]() {
          return Vh((this[JA].number / 100) * this[XA].number, this[XA].unit)
        }
      }
      const ZA = Symbol('identNode')
      class $A extends YA {
        constructor(t) {
          super(), (this[HA] = null)
          const e = t.arguments.length ? t.arguments[0].terms[0] : null
          null != e && 'ident' === e.type && (this[ZA] = e)
        }
        get isConstant() {
          return !1
        }
        [((HA = ZA), qA)]() {
          if (null != this[ZA])
            switch (this[ZA].value) {
              case 'window-scroll-y':
                return {
                  type: 'number',
                  number:
                    window.pageYOffset /
                      (Math.max(
                        document.body.scrollHeight,
                        document.body.offsetHeight,
                        document.documentElement.clientHeight,
                        document.documentElement.scrollHeight,
                        document.documentElement.offsetHeight,
                      ) -
                        window.innerHeight) || 0,
                  unit: null,
                }
            }
          return Zh
        }
      }
      const tg = /[\*\/]/,
        eg = Symbol('evalutor')
      class ig extends YA {
        constructor(t, e = Zh) {
          if ((super(), (this[WA] = null), 1 !== t.arguments.length)) return
          const i = t.arguments[0].terms.slice(),
            n = []
          for (; i.length; ) {
            const t = i.shift()
            if (n.length > 0) {
              const i = n[n.length - 1]
              if ('operator' === i.type && tg.test(i.value)) {
                const i = n.pop(),
                  s = n.pop()
                if (null == s) return
                n.push(new ag(i, YA.evaluatableFor(s, e), YA.evaluatableFor(t, e)))
                continue
              }
            }
            n.push('operator' === t.type ? t : YA.evaluatableFor(t, e))
          }
          for (; n.length > 2; ) {
            const [t, i, s] = n.splice(0, 3)
            if ('operator' !== i.type) return
            n.unshift(new ag(i, YA.evaluatableFor(t, e), YA.evaluatableFor(s, e)))
          }
          1 === n.length && (this[eg] = n[0])
        }
        get isConstant() {
          return null == this[eg] || YA.isConstant(this[eg])
        }
        [((WA = eg), qA)]() {
          return null != this[eg] ? YA.evaluate(this[eg]) : Zh
        }
      }
      const ng = Symbol('operator'),
        sg = Symbol('left'),
        rg = Symbol('right')
      class ag extends YA {
        constructor(t, e, i) {
          super(), (this[ng] = t), (this[sg] = e), (this[rg] = i)
        }
        get isConstant() {
          return YA.isConstant(this[sg]) && YA.isConstant(this[rg])
        }
        [qA]() {
          const t = eu(YA.evaluate(this[sg])),
            e = eu(YA.evaluate(this[rg])),
            { number: i, unit: n } = t,
            { number: s, unit: r } = e
          if (null != r && null != n && r != n) return Zh
          const a = n || r
          let o
          switch (this[ng].value) {
            case '+':
              o = i + s
              break
            case '-':
              o = i - s
              break
            case '/':
              o = i / s
              break
            case '*':
              o = i * s
              break
            default:
              return Zh
          }
          return { type: 'number', number: o, unit: a }
        }
      }
      const og = Symbol('evaluatables'),
        lg = Symbol('intrinsics')
      class cg extends YA {
        constructor(t, e) {
          super(), (this[lg] = e)
          const i = t[0],
            n = null != i ? i.terms : []
          this[og] = e.basis.map((t, e) => {
            const i = n[e]
            return null == i ? { type: 'ident', value: 'auto' } : 'ident' === i.type ? i : YA.evaluatableFor(i, t)
          })
        }
        get isConstant() {
          for (const t of this[og]) if (!YA.isConstant(t)) return !1
          return !0
        }
        [qA]() {
          const t = this[og].map((t) => YA.evaluate(t))
          return YA.applyIntrinsics(t, this[lg]).map((t) => t.number)
        }
      }
      /* @license
       * Copyright 2019 Google LLC. All Rights Reserved.
       * Licensed under the Apache License, Version 2.0 (the 'License');
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *     http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an 'AS IS' BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ var hg, ug, dg, pg
      const Ag = Symbol('instances'),
        gg = Symbol('activateListener'),
        mg = Symbol('deactivateListener'),
        fg = Symbol('notifyInstances'),
        vg = Symbol('notify'),
        yg = Symbol('callback')
      class xg {
        constructor(t) {
          this[yg] = t
        }
        static [fg]() {
          for (const t of xg[Ag]) t[vg]()
        }
        static [((hg = Ag), gg)]() {
          window.addEventListener('scroll', this[fg], { passive: !0 })
        }
        static [mg]() {
          window.removeEventListener('scroll', this[fg])
        }
        observe() {
          0 === xg[Ag].size && xg[gg](), xg[Ag].add(this)
        }
        disconnect() {
          xg[Ag].delete(this), 0 === xg[Ag].size && xg[mg]()
        }
        [vg]() {
          this[yg]()
        }
      }
      xg[hg] = new Set()
      const wg = Symbol('computeStyleCallback'),
        _g = Symbol('astWalker'),
        Ig = Symbol('dependencies'),
        Cg = Symbol('onScroll')
      class Mg {
        constructor(t) {
          ;(this[ug] = {}),
            (this[dg] = new Kh(['function'])),
            (this[pg] = () => {
              this[wg]({ relatedState: 'window-scroll' })
            }),
            (this[wg] = t)
        }
        observeEffectsFor(t) {
          const e = {},
            i = this[Ig]
          this[_g].walk(t, (t) => {
            const { name: n } = t,
              s = t.arguments[0].terms[0]
            if ('env' === n.value && null != s && 'ident' === s.type)
              switch (s.value) {
                case 'window-scroll-y':
                  if (null == e['window-scroll']) {
                    const t = 'window-scroll' in i ? i['window-scroll'] : new xg(this[Cg])
                    t.observe(), delete i['window-scroll'], (e['window-scroll'] = t)
                  }
              }
          })
          for (const n in i) i[n].disconnect()
          this[Ig] = e
        }
        dispose() {
          for (const t in this[Ig]) this[Ig][t].disconnect()
        }
      }
      ;(ug = Ig), (dg = _g), (pg = Cg)
      /* @license
       * Copyright 2019 Google LLC. All Rights Reserved.
       * Licensed under the Apache License, Version 2.0 (the 'License');
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *     http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an 'AS IS' BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */
      const Eg = (t) => {
          const e = t.observeEffects || !1,
            i = t.intrinsics instanceof Function ? t.intrinsics : () => t.intrinsics
          return (n, s) => {
            const r = n.updated,
              a = n.connectedCallback,
              o = n.disconnectedCallback,
              l = Symbol(`${s}StyleEffector`),
              c = Symbol(`${s}StyleEvaluator`),
              h = Symbol(`${s}UpdateEvaluator`),
              u = Symbol(`${s}EvaluateAndSync`)
            Object.defineProperties(n, {
              [l]: { value: null, writable: !0 },
              [c]: { value: null, writable: !0 },
              [h]: {
                value: function () {
                  const t = Hh(this[s])
                  ;(this[c] = new cg(t, i(this))),
                    null == this[l] && e && (this[l] = new Mg(() => this[u]())),
                    null != this[l] && this[l].observeEffectsFor(t)
                },
              },
              [u]: {
                value: function () {
                  if (null == this[c]) return
                  const e = this[c].evaluate()
                  this[t.updateHandler](e)
                },
              },
              updated: {
                value: function (t) {
                  t.has(s) && (this[h](), this[u]()), r.call(this, t)
                },
              },
              connectedCallback: {
                value: function () {
                  a.call(this), this.requestUpdate(s, this[s])
                },
              },
              disconnectedCallback: {
                value: function () {
                  o.call(this), null != this[l] && (this[l].dispose(), (this[l] = null))
                },
              },
            })
          }
        },
        bg = Object.freeze({
          minimumRadius: 0,
          maximumRadius: 1 / 0,
          minimumPolarAngle: Math.PI / 8,
          maximumPolarAngle: Math.PI - Math.PI / 8,
          minimumAzimuthalAngle: -1 / 0,
          maximumAzimuthalAngle: 1 / 0,
          minimumFieldOfView: 10,
          maximumFieldOfView: 45,
          interactionPolicy: 'always-allow',
          touchAction: 'pan-y',
        }),
        Sg = /^touch(start|end|move)$/,
        Bg = Math.PI / 8,
        Tg = 'user-interaction'
      /* @license
       * Licensed under the Apache License, Version 2.0 (the 'License');
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *     http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an 'AS IS' BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Lg extends it {
        constructor(t, e) {
          super(),
            (this.camera = t),
            (this.element = e),
            (this.sensitivity = 1),
            (this._interactionEnabled = !1),
            (this._disableZoom = !1),
            (this.isUserChange = !1),
            (this.isUserPointing = !1),
            (this.spherical = new Ol()),
            (this.goalSpherical = new Ol()),
            (this.thetaDamper = new zh()),
            (this.phiDamper = new zh()),
            (this.radiusDamper = new zh()),
            (this.logFov = Math.log(bg.maximumFieldOfView)),
            (this.goalLogFov = this.logFov),
            (this.fovDamper = new zh()),
            (this.pointerIsDown = !1),
            (this.lastPointerPosition = { clientX: 0, clientY: 0 }),
            (this.touchMode = 'rotate'),
            (this.touchDecided = !1),
            (this.onPointerMove = (t) => {
              if (this.pointerIsDown && this.canInteract) {
                if (Sg.test(t.type)) {
                  const { touches: e } = t
                  switch (this.touchMode) {
                    case 'zoom':
                      if (this.lastTouches.length > 1 && e.length > 1) {
                        const t =
                          (0.04 *
                            (this.twoTouchDistance(this.lastTouches[0], this.lastTouches[1]) -
                              this.twoTouchDistance(e[0], e[1]))) /
                          10
                        this.userAdjustOrbit(0, 0, t)
                      }
                      break
                    case 'rotate':
                      const { touchAction: t } = this._options
                      if (!this.touchDecided && 'none' !== t) {
                        this.touchDecided = !0
                        const { clientX: i, clientY: n } = e[0],
                          s = Math.abs(i - this.lastPointerPosition.clientX),
                          r = Math.abs(n - this.lastPointerPosition.clientY)
                        if (('pan-y' === t && r > s) || ('pan-x' === t && s > r))
                          return void (this.touchMode = 'scroll')
                      }
                      this.handleSinglePointerMove(e[0])
                      break
                    case 'scroll':
                      return
                  }
                  this.lastTouches = e
                } else this.handleSinglePointerMove(t)
                t.cancelable && t.preventDefault()
              }
            }),
            (this.onPointerDown = (t) => {
              if (((this.pointerIsDown = !0), (this.isUserPointing = !1), Sg.test(t.type))) {
                const { touches: e } = t
                switch (((this.touchDecided = !1), e.length)) {
                  default:
                  case 1:
                    ;(this.touchMode = 'rotate'), this.handleSinglePointerDown(e[0])
                    break
                  case 2:
                    this.touchMode = this._disableZoom ? 'scroll' : 'zoom'
                }
                this.lastTouches = e
              } else this.handleSinglePointerDown(t)
            }),
            (this.onPointerUp = (t) => {
              ;(this.element.style.cursor = 'grab'),
                (this.pointerIsDown = !1),
                this.isUserPointing &&
                  this.dispatchEvent({
                    type: 'pointer-change-end',
                    pointer: Object.assign({}, this.lastPointerPosition),
                  })
            }),
            (this.onWheel = (t) => {
              if (!this.canInteract) return
              const e = (t.deltaY * (1 == t.deltaMode ? 18 : 1) * 0.04) / 30
              this.userAdjustOrbit(0, 0, e), t.cancelable && t.preventDefault()
            }),
            (this.onKeyDown = (t) => {
              let e = !1
              switch (t.keyCode) {
                case 33:
                  ;(e = !0), this.userAdjustOrbit(0, 0, 0.04)
                  break
                case 34:
                  ;(e = !0), this.userAdjustOrbit(0, 0, -0.04)
                  break
                case 38:
                  ;(e = !0), this.userAdjustOrbit(0, -Bg, 0)
                  break
                case 40:
                  ;(e = !0), this.userAdjustOrbit(0, Bg, 0)
                  break
                case 37:
                  ;(e = !0), this.userAdjustOrbit(-Bg, 0, 0)
                  break
                case 39:
                  ;(e = !0), this.userAdjustOrbit(Bg, 0, 0)
              }
              e && t.cancelable && t.preventDefault()
            }),
            (this._options = Object.assign({}, bg)),
            this.setOrbit(0, Math.PI / 2, 1),
            this.setFieldOfView(100),
            this.jumpToGoal()
        }
        get interactionEnabled() {
          return this._interactionEnabled
        }
        enableInteraction() {
          if (!1 === this._interactionEnabled) {
            const { element: t } = this
            t.addEventListener('mousemove', this.onPointerMove),
              t.addEventListener('mousedown', this.onPointerDown),
              this._disableZoom || t.addEventListener('wheel', this.onWheel),
              t.addEventListener('keydown', this.onKeyDown),
              t.addEventListener('touchstart', this.onPointerDown, { passive: !0 }),
              t.addEventListener('touchmove', this.onPointerMove),
              self.addEventListener('mouseup', this.onPointerUp),
              self.addEventListener('touchend', this.onPointerUp),
              (this.element.style.cursor = 'grab'),
              (this._interactionEnabled = !0)
          }
        }
        disableInteraction() {
          if (!0 === this._interactionEnabled) {
            const { element: t } = this
            t.removeEventListener('mousemove', this.onPointerMove),
              t.removeEventListener('mousedown', this.onPointerDown),
              this._disableZoom || t.removeEventListener('wheel', this.onWheel),
              t.removeEventListener('keydown', this.onKeyDown),
              t.removeEventListener('touchstart', this.onPointerDown),
              t.removeEventListener('touchmove', this.onPointerMove),
              self.removeEventListener('mouseup', this.onPointerUp),
              self.removeEventListener('touchend', this.onPointerUp),
              (t.style.cursor = ''),
              (this._interactionEnabled = !1)
          }
        }
        get options() {
          return this._options
        }
        set disableZoom(t) {
          this._disableZoom != t &&
            ((this._disableZoom = t),
            !0 === t
              ? this.element.removeEventListener('wheel', this.onWheel)
              : this.element.addEventListener('wheel', this.onWheel))
        }
        getCameraSpherical(t = new Ol()) {
          return t.copy(this.spherical)
        }
        getFieldOfView() {
          return this.camera.fov
        }
        applyOptions(t) {
          Object.assign(this._options, t), this.setOrbit(), this.setFieldOfView(Math.exp(this.goalLogFov))
        }
        updateNearFar(t, e) {
          ;(this.camera.near = Math.max(t, e / 1e3)), (this.camera.far = e), this.camera.updateProjectionMatrix()
        }
        updateAspect(t) {
          ;(this.camera.aspect = t), this.camera.updateProjectionMatrix()
        }
        setOrbit(t = this.goalSpherical.theta, e = this.goalSpherical.phi, i = this.goalSpherical.radius) {
          const {
              minimumAzimuthalAngle: n,
              maximumAzimuthalAngle: s,
              minimumPolarAngle: r,
              maximumPolarAngle: a,
              minimumRadius: o,
              maximumRadius: l,
            } = this._options,
            { theta: c, phi: h, radius: u } = this.goalSpherical,
            d = kh(t, n, s)
          isFinite(n) || isFinite(s) || (this.spherical.theta = this.wrapAngle(this.spherical.theta - d) + d)
          const p = kh(e, r, a),
            A = kh(i, o, l)
          return (
            (d !== c || p !== h || A !== u) &&
            ((this.goalSpherical.theta = d),
            (this.goalSpherical.phi = p),
            (this.goalSpherical.radius = A),
            this.goalSpherical.makeSafe(),
            (this.isUserChange = !1),
            !0)
          )
        }
        setRadius(t) {
          ;(this.goalSpherical.radius = t), this.setOrbit()
        }
        setFieldOfView(t) {
          const { minimumFieldOfView: e, maximumFieldOfView: i } = this._options
          ;(t = kh(t, e, i)), (this.goalLogFov = Math.log(t))
        }
        setDamperDecayTime(t) {
          this.thetaDamper.setDecayTime(t),
            this.phiDamper.setDecayTime(t),
            this.radiusDamper.setDecayTime(t),
            this.fovDamper.setDecayTime(t)
        }
        adjustOrbit(t, e, i) {
          const { theta: n, phi: s, radius: r } = this.goalSpherical,
            { minimumRadius: a, maximumRadius: o, minimumFieldOfView: l, maximumFieldOfView: c } = this._options,
            h = this.spherical.theta - n,
            u = Math.PI - 0.001,
            d = n - kh(t, -u - h, u - h),
            p = s - e,
            A = 0 === i ? 0 : ((i > 0 ? o : a) - r) / (Math.log(i > 0 ? c : l) - this.goalLogFov),
            g = r + i * Math.min(isFinite(A) ? A : 1 / 0, o - a)
          if ((this.setOrbit(d, p, g), 0 !== i)) {
            const t = this.goalLogFov + i
            this.setFieldOfView(Math.exp(t))
          }
        }
        jumpToGoal() {
          this.update(0, 1e4)
        }
        update(t, e) {
          if (this.isStationary()) return
          const { maximumPolarAngle: i, maximumRadius: n } = this._options,
            s = this.spherical.theta - this.goalSpherical.theta
          Math.abs(s) > Math.PI &&
            !isFinite(this._options.minimumAzimuthalAngle) &&
            !isFinite(this._options.maximumAzimuthalAngle) &&
            (this.spherical.theta -= 2 * Math.sign(s) * Math.PI),
            (this.spherical.theta = this.thetaDamper.update(
              this.spherical.theta,
              this.goalSpherical.theta,
              e,
              Math.PI,
            )),
            (this.spherical.phi = this.phiDamper.update(this.spherical.phi, this.goalSpherical.phi, e, i)),
            (this.spherical.radius = this.radiusDamper.update(this.spherical.radius, this.goalSpherical.radius, e, n)),
            (this.logFov = this.fovDamper.update(this.logFov, this.goalLogFov, e, 1)),
            this.moveCamera()
        }
        isStationary() {
          return (
            this.goalSpherical.theta === this.spherical.theta &&
            this.goalSpherical.phi === this.spherical.phi &&
            this.goalSpherical.radius === this.spherical.radius &&
            this.goalLogFov === this.logFov
          )
        }
        moveCamera() {
          this.spherical.makeSafe(),
            this.camera.position.setFromSpherical(this.spherical),
            this.camera.setRotationFromEuler(new pe(this.spherical.phi - Math.PI / 2, this.spherical.theta, 0, 'YXZ')),
            this.camera.fov !== Math.exp(this.logFov) &&
              ((this.camera.fov = Math.exp(this.logFov)), this.camera.updateProjectionMatrix())
          const t = this.isUserChange ? Tg : 'none'
          this.dispatchEvent({ type: 'change', source: t })
        }
        get canInteract() {
          return 'allow-when-focused' == this._options.interactionPolicy
            ? this.element.getRootNode().activeElement === this.element
            : 'always-allow' === this._options.interactionPolicy
        }
        userAdjustOrbit(t, e, i) {
          this.adjustOrbit(t * this.sensitivity, e * this.sensitivity, i),
            (this.isUserChange = !0),
            this.dispatchEvent({ type: 'change', source: Tg })
        }
        wrapAngle(t) {
          const e = (t + Math.PI) / (2 * Math.PI)
          return 2 * (e - Math.floor(e)) * Math.PI - Math.PI
        }
        pixelLengthToSphericalAngle(t) {
          return (2 * Math.PI * t) / this.element.clientHeight
        }
        twoTouchDistance(t, e) {
          const { clientX: i, clientY: n } = t,
            { clientX: s, clientY: r } = e,
            a = s - i,
            o = r - n
          return Math.sqrt(a * a + o * o)
        }
        handleSinglePointerMove(t) {
          const { clientX: e, clientY: i } = t,
            n = this.pixelLengthToSphericalAngle(e - this.lastPointerPosition.clientX),
            s = this.pixelLengthToSphericalAngle(i - this.lastPointerPosition.clientY)
          ;(this.lastPointerPosition.clientX = e),
            (this.lastPointerPosition.clientY = i),
            !1 === this.isUserPointing &&
              ((this.isUserPointing = !0),
              this.dispatchEvent({ type: 'pointer-change-start', pointer: Object.assign({}, t) })),
            this.userAdjustOrbit(n, s, 0)
        }
        handleSinglePointerDown(t) {
          ;(this.lastPointerPosition.clientX = t.clientX),
            (this.lastPointerPosition.clientY = t.clientY),
            (this.element.style.cursor = 'grabbing')
          /* @license
           * Copyright 2019 Google LLC. All Rights Reserved.
           * Licensed under the Apache License, Version 2.0 (the 'License');
           * you may not use this file except in compliance with the License.
           * You may obtain a copy of the License at
           *
           *     http://www.apache.org/licenses/LICENSE-2.0
           *
           * Unless required by applicable law or agreed to in writing, software
           * distributed under the License is distributed on an 'AS IS' BASIS,
           * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
           * See the License for the specific language governing permissions and
           * limitations under the License.
           */
        }
      }
      const Dg = (t) => (t < 0.5 ? 2 * t * t : (4 - 2 * t) * t - 1),
        Qg =
          (t, e, i = Dg) =>
          (n) =>
            t + (e - t) * i(n),
        Rg = (t, e) => {
          const i = [],
            n = []
          let s = t
          for (let r = 0; r < e.length; ++r) {
            const t = e[r],
              { value: a, frames: o } = t,
              l = t.ease || Dg,
              c = Qg(s, a, l)
            i.push(c), n.push(o), (s = a)
          }
          return ((t, e) => {
            const i = e.reduce((t, e) => t + e, 0),
              n = e.map((t) => t / i)
            return (e) => {
              let i = 0,
                s = 1 / 0,
                r = () => 0
              for (let a = 0; a < n.length && ((s = n[a]), (r = t[a]), !(e <= i + s)); ++a) i += s
              return r((e - i) / s)
            }
          })(i, n)
        }
      /* @license
       * Copyright 2019 Google LLC. All Rights Reserved.
       * Licensed under the Apache License, Version 2.0 (the 'License');
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *     http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an 'AS IS' BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ var Pg = function (t, e, i, n) {
        for (
          var s,
            r = arguments.length,
            a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n,
            o = t.length - 1;
          o >= 0;
          o--
        )
          (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a)
        return r > 3 && a && Object.defineProperty(e, i, a), a
      }
      const Ng = Rg(0, [
          { frames: 5, value: -1 },
          { frames: 1, value: -1 },
          { frames: 8, value: 1 },
          { frames: 1, value: 1 },
          { frames: 5, value: 0 },
          { frames: 18, value: 0 },
        ]),
        Fg = Rg(0, [
          { frames: 1, value: 1 },
          { frames: 5, value: 1 },
          { frames: 1, value: 0 },
          { frames: 6, value: 0 },
        ]),
        Ug = 1.1 * au,
        kg = ['front', 'right', 'back', 'left'],
        Og = ['upper-', '', 'lower-'],
        Gg = 'auto',
        zg = 'when-focused',
        Vg = 'wiggle',
        Hg = (t) => ({ basis: [Vh((t[mm] * Math.PI) / 180, 'rad')], keywords: { auto: [null] } }),
        Wg = { basis: [$h(Vh(25, 'deg'))], keywords: { auto: [null] } },
        qg = (t) => {
          const e = t[Zd]
          return { basis: [$h(Vh(45, 'deg'))], keywords: { auto: [Vh(e.framedFieldOfView, 'deg')] } }
        },
        jg = (() => {
          const t = Hh('0deg 75deg 105%')[0].terms,
            e = eu(t[0]),
            i = eu(t[1])
          return (t) => {
            const n = t[Zd].idealCameraDistance
            return { basis: [e, i, Vh(n, 'm')], keywords: { auto: [null, null, Vh(105, '%')] } }
          }
        })(),
        Yg = (t) => {
          const e = Ug * t[Zd].idealCameraDistance
          return {
            basis: [Vh(-1 / 0, 'rad'), Vh(Math.PI / 8, 'rad'), Vh(e, 'm')],
            keywords: { auto: [null, null, null] },
          }
        },
        Jg = (t) => {
          const e = jg(t),
            i = new cg([], e).evaluate()[2]
          return {
            basis: [Vh(1 / 0, 'rad'), Vh(Math.PI - Math.PI / 8, 'rad'), Vh(i, 'm')],
            keywords: { auto: [null, null, null] },
          }
        },
        Xg = (t) => {
          const e = t[Zd].boundingBox.getCenter(new Et())
          return { basis: [Vh(e.x, 'm'), Vh(e.y, 'm'), Vh(e.z, 'm')], keywords: { auto: [null, null, null] } }
        },
        Kg = Math.PI / 2,
        Zg = Math.PI / 3,
        $g = Kg / 2,
        tm = 2 * Math.PI,
        em = Symbol('controls'),
        im = Symbol('promptElement'),
        nm = Symbol('promptAnimatedContainer'),
        sm = Symbol('deferInteractionPrompt'),
        rm = Symbol('updateAria'),
        am = Symbol('updateCameraForRadius'),
        om = Symbol('onBlur'),
        lm = Symbol('onFocus'),
        cm = Symbol('onChange'),
        hm = Symbol('onPointerChange'),
        um = Symbol('waitingToPromptUser'),
        dm = Symbol('userHasInteracted'),
        pm = Symbol('promptElementVisibleTime'),
        Am = Symbol('lastPromptOffset'),
        gm = Symbol('focusedTime'),
        mm = Symbol('zoomAdjustedFieldOfView'),
        fm = Symbol('lastSpherical'),
        vm = Symbol('jumpCamera'),
        ym = Symbol('initialized'),
        xm = Symbol('maintainThetaPhi'),
        wm = Symbol('syncCameraOrbit'),
        _m = Symbol('syncFieldOfView'),
        Im = Symbol('syncCameraTarget'),
        Cm = Symbol('syncMinCameraOrbit'),
        Mm = Symbol('syncMaxCameraOrbit'),
        Em = Symbol('syncMinFieldOfView'),
        bm = Symbol('syncMaxFieldOfView')
      /* @license
       * Copyright 2019 Google LLC. All Rights Reserved.
       * Licensed under the Apache License, Version 2.0 (the 'License');
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *     http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an 'AS IS' BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ var Sm, Bm
      const Tm = Symbol('modelViewerStatusInstance'),
        Lm = Symbol('updateStatus')
      ;(Sm = Tm), (Bm = Lm)
      /* @license
       * Copyright 2019 Google LLC. All Rights Reserved.
       * Licensed under the Apache License, Version 2.0 (the 'License');
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *     http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an 'AS IS' BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */
      var Dm = function (t, e, i, n) {
        for (
          var s,
            r = arguments.length,
            a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n,
            o = t.length - 1;
          o >= 0;
          o--
        )
          (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a)
        return r > 3 && a && Object.defineProperty(e, i, a), a
      }
      const Qm = 'auto',
        Rm = 'manual',
        Pm = new (class extends it {
          constructor() {
            super(),
              (this[Sm] = null),
              (this.registeredInstanceStatuses = new Map()),
              (this.loadingPromises = []),
              (this.statusElement = document.createElement('p')),
              (this.statusUpdateInProgress = !1),
              (this[Bm] = Uh(() => this.updateStatus(), 100))
            const { statusElement: t } = this,
              { style: e } = t
            t.setAttribute('role', 'status'),
              t.classList.add('screen-reader-only'),
              (e.top = e.left = '0'),
              (e.pointerEvents = 'none')
          }
          registerInstance(t) {
            if (this.registeredInstanceStatuses.has(t)) return
            let e = () => {}
            const i = !1 === t.loaded && !!t.src,
              n = new Promise((n) => {
                if (!i) return void n()
                const s = () => {
                  n(), t.removeEventListener('load', s), t.removeEventListener('error', s)
                }
                t.addEventListener('load', s), t.addEventListener('error', s), (e = s)
              })
            this.registeredInstanceStatuses.set(t, { onUnregistered: e }),
              this.loadingPromises.push(n),
              null == this.modelViewerStatusInstance && (this.modelViewerStatusInstance = t)
          }
          unregisterInstance(t) {
            if (!this.registeredInstanceStatuses.has(t)) return
            const e = this.registeredInstanceStatuses,
              i = e.get(t)
            e.delete(t),
              i.onUnregistered(),
              this.modelViewerStatusInstance === t &&
                (this.modelViewerStatusInstance =
                  e.size > 0
                    ? ((t) => {
                        if (null != t.keys) return t.keys().next().value || null
                        let e = null
                        try {
                          t.forEach((t, i, n) => {
                            throw ((e = i), new Error())
                          })
                        } catch (t) {}
                        return e
                      })(e)
                    : null)
          }
          get modelViewerStatusInstance() {
            return this[Tm]
          }
          set modelViewerStatusInstance(t) {
            if (this[Tm] === t) return
            const { statusElement: e } = this
            null != t && null != t.shadowRoot
              ? t.shadowRoot.appendChild(e)
              : null != e.parentNode && e.parentNode.removeChild(e),
              (this[Tm] = t),
              this[Lm]()
          }
          async updateStatus() {
            if (!this.statusUpdateInProgress && 0 !== this.loadingPromises.length) {
              for (
                this.statusElement.textContent = 'This page includes one or more 3D models that are loading',
                  this.statusUpdateInProgress = !0,
                  this.dispatchEvent({ type: 'initial-status-announced' });
                this.loadingPromises.length;

              ) {
                const { loadingPromises: t } = this
                ;(this.loadingPromises = []), await Promise.all(t)
              }
              ;(this.statusElement.textContent = 'All 3D models in the page have loaded'),
                (this.statusUpdateInProgress = !1),
                this.dispatchEvent({ type: 'finished-loading-announced' })
            }
          }
        })(),
        Nm = Symbol('defaultProgressBarElement'),
        Fm = Symbol('defaultProgressMaskElement'),
        Um = Symbol('posterContainerElement'),
        km = Symbol('defaultPosterElement'),
        Om = Symbol('posterDismissalSource'),
        Gm = Symbol('hidePoster'),
        zm = Symbol('modelIsRevealed'),
        Vm = Symbol('updateProgressBar'),
        Hm = Symbol('lastReportedProgress'),
        Wm = Symbol('transitioned'),
        qm = Symbol('ariaLabelCallToAction'),
        jm = Symbol('onClick'),
        Ym = Symbol('onKeydown'),
        Jm = Symbol('onProgress')
      class Xm {
        constructor() {
          ;(this.pluginCallbacks = []),
            this.register(function (t) {
              return new of(t)
            }),
            this.register(function (t) {
              return new lf(t)
            }),
            this.register(function (t) {
              return new cf(t)
            }),
            this.register(function (t) {
              return new hf(t)
            }),
            this.register(function (t) {
              return new uf(t)
            })
        }
        register(t) {
          return -1 === this.pluginCallbacks.indexOf(t) && this.pluginCallbacks.push(t), this
        }
        unregister(t) {
          return (
            -1 !== this.pluginCallbacks.indexOf(t) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(t), 1),
            this
          )
        }
        parse(t, e, i) {
          const n = new af(),
            s = []
          for (let r = 0, a = this.pluginCallbacks.length; r < a; r++) s.push(this.pluginCallbacks[r](n))
          n.setPlugins(s), n.write(t, e, i)
        }
      }
      const Km = 5121,
        Zm = 5123,
        $m = {
          1003: 9728,
          1004: 9984,
          1005: 9986,
          1006: 9729,
          1007: 9985,
          1008: 9987,
          1001: 33071,
          1e3: 10497,
          1002: 33648,
        },
        tf = { scale: 'scale', position: 'translation', quaternion: 'rotation', morphTargetInfluences: 'weights' }
      function ef(t, e) {
        return (
          t.length === e.length &&
          t.every(function (t, i) {
            return t === e[i]
          })
        )
      }
      function nf(t) {
        return 4 * Math.ceil(t / 4)
      }
      function sf(t, e = 0) {
        const i = nf(t.byteLength)
        if (i !== t.byteLength) {
          const n = new Uint8Array(i)
          if ((n.set(new Uint8Array(t)), 0 !== e)) for (let s = t.byteLength; s < i; s++) n[s] = e
          return n.buffer
        }
        return t
      }
      let rf = null
      class af {
        constructor() {
          ;(this.plugins = []),
            (this.options = {}),
            (this.pending = []),
            (this.buffers = []),
            (this.byteOffset = 0),
            (this.buffers = []),
            (this.nodeMap = new Map()),
            (this.skins = []),
            (this.extensionsUsed = {}),
            (this.uids = new Map()),
            (this.uid = 0),
            (this.json = { asset: { version: '2.0', generator: 'THREE.GLTFExporter' } }),
            (this.cache = {
              meshes: new Map(),
              attributes: new Map(),
              attributesNormalized: new Map(),
              materials: new Map(),
              textures: new Map(),
              images: new Map(),
            })
        }
        setPlugins(t) {
          this.plugins = t
        }
        write(t, e, i) {
          ;(this.options = Object.assign(
            {},
            {
              binary: !1,
              trs: !1,
              onlyVisible: !0,
              truncateDrawRange: !0,
              embedImages: !0,
              maxTextureSize: 1 / 0,
              animations: [],
              includeCustomExtensions: !1,
            },
            i,
          )),
            this.options.animations.length > 0 && (this.options.trs = !0),
            this.processInput(t)
          const n = this
          Promise.all(this.pending).then(function () {
            const t = n.buffers,
              i = n.json,
              s = n.options,
              r = n.extensionsUsed,
              a = new Blob(t, { type: 'application/octet-stream' }),
              o = Object.keys(r)
            if (
              (o.length > 0 && (i.extensionsUsed = o),
              i.buffers && i.buffers.length > 0 && (i.buffers[0].byteLength = a.size),
              !0 === s.binary)
            ) {
              const t = new window.FileReader()
              t.readAsArrayBuffer(a),
                (t.onloadend = function () {
                  const n = sf(t.result),
                    s = new DataView(new ArrayBuffer(8))
                  s.setUint32(0, n.byteLength, !0), s.setUint32(4, 5130562, !0)
                  const r = sf(
                      (function (t) {
                        if (void 0 !== window.TextEncoder) return new TextEncoder().encode(t).buffer
                        const e = new Uint8Array(new ArrayBuffer(t.length))
                        for (let i = 0, n = t.length; i < n; i++) {
                          const n = t.charCodeAt(i)
                          e[i] = n > 255 ? 32 : n
                        }
                        return e.buffer
                      })(JSON.stringify(i)),
                      32,
                    ),
                    a = new DataView(new ArrayBuffer(8))
                  a.setUint32(0, r.byteLength, !0), a.setUint32(4, 1313821514, !0)
                  const o = new ArrayBuffer(12),
                    l = new DataView(o)
                  l.setUint32(0, 1179937895, !0), l.setUint32(4, 2, !0)
                  const c = 12 + a.byteLength + r.byteLength + s.byteLength + n.byteLength
                  l.setUint32(8, c, !0)
                  const h = new Blob([o, a, r, s, n], { type: 'application/octet-stream' }),
                    u = new window.FileReader()
                  u.readAsArrayBuffer(h),
                    (u.onloadend = function () {
                      e(u.result)
                    })
                })
            } else if (i.buffers && i.buffers.length > 0) {
              const t = new window.FileReader()
              t.readAsDataURL(a),
                (t.onloadend = function () {
                  const n = t.result
                  ;(i.buffers[0].uri = n), e(i)
                })
            } else e(i)
          })
        }
        serializeUserData(t, e) {
          if (0 === Object.keys(t.userData).length) return
          const i = this.options,
            n = this.extensionsUsed
          try {
            const s = JSON.parse(JSON.stringify(t.userData))
            if (i.includeCustomExtensions && s.gltfExtensions) {
              void 0 === e.extensions && (e.extensions = {})
              for (const t in s.gltfExtensions) (e.extensions[t] = s.gltfExtensions[t]), (n[t] = !0)
              delete s.gltfExtensions
            }
            Object.keys(s).length > 0 && (e.extras = s)
          } catch (e) {}
        }
        getUID(t) {
          return this.uids.has(t) || this.uids.set(t, this.uid++), this.uids.get(t)
        }
        isNormalizedNormalAttribute(t) {
          if (this.cache.attributesNormalized.has(t)) return !1
          const e = new Et()
          for (let i = 0, n = t.count; i < n; i++)
            if (Math.abs(e.fromBufferAttribute(t, i).length() - 1) > 5e-4) return !1
          return !0
        }
        createNormalizedNormalAttribute(t) {
          const e = this.cache
          if (e.attributesNormalized.has(t)) return e.attributesNormalized.get(t)
          const i = t.clone(),
            n = new Et()
          for (let s = 0, r = i.count; s < r; s++)
            n.fromBufferAttribute(i, s),
              0 === n.x && 0 === n.y && 0 === n.z ? n.setX(1) : n.normalize(),
              i.setXYZ(s, n.x, n.y, n.z)
          return e.attributesNormalized.set(t, i), i
        }
        applyTextureTransform(t, e) {
          let i = !1
          const n = {}
          ;(0 === e.offset.x && 0 === e.offset.y) || ((n.offset = e.offset.toArray()), (i = !0)),
            0 !== e.rotation && ((n.rotation = e.rotation), (i = !0)),
            (1 === e.repeat.x && 1 === e.repeat.y) || ((n.scale = e.repeat.toArray()), (i = !0)),
            i &&
              ((t.extensions = t.extensions || {}),
              (t.extensions.KHR_texture_transform = n),
              (this.extensionsUsed.KHR_texture_transform = !0))
        }
        processBuffer(t) {
          const e = this.json,
            i = this.buffers
          return e.buffers || (e.buffers = [{ byteLength: 0 }]), i.push(t), 0
        }
        processBufferView(t, e, i, n, s) {
          const r = this.json
          let a
          r.bufferViews || (r.bufferViews = []), (a = e === Km ? 1 : e === Zm ? 2 : 4)
          const o = nf(n * t.itemSize * a),
            l = new DataView(new ArrayBuffer(o))
          let c = 0
          for (let u = i; u < i + n; u++)
            for (let i = 0; i < t.itemSize; i++) {
              let n
              t.itemSize > 4
                ? (n = t.array[u * t.itemSize + i])
                : 0 === i
                ? (n = t.getX(u))
                : 1 === i
                ? (n = t.getY(u))
                : 2 === i
                ? (n = t.getZ(u))
                : 3 === i && (n = t.getW(u)),
                5126 === e
                  ? l.setFloat32(c, n, !0)
                  : 5125 === e
                  ? l.setUint32(c, n, !0)
                  : e === Zm
                  ? l.setUint16(c, n, !0)
                  : e === Km && l.setUint8(c, n),
                (c += a)
            }
          const h = { buffer: this.processBuffer(l.buffer), byteOffset: this.byteOffset, byteLength: o }
          return (
            void 0 !== s && (h.target = s),
            34962 === s && (h.byteStride = t.itemSize * a),
            (this.byteOffset += o),
            r.bufferViews.push(h),
            { id: r.bufferViews.length - 1, byteLength: 0 }
          )
        }
        processBufferViewImage(t) {
          const e = this,
            i = e.json
          return (
            i.bufferViews || (i.bufferViews = []),
            new Promise(function (n) {
              const s = new window.FileReader()
              s.readAsArrayBuffer(t),
                (s.onloadend = function () {
                  const t = sf(s.result),
                    r = { buffer: e.processBuffer(t), byteOffset: e.byteOffset, byteLength: t.byteLength }
                  ;(e.byteOffset += t.byteLength), n(i.bufferViews.push(r) - 1)
                })
            })
          )
        }
        processAccessor(t, e, i, n) {
          const s = this.options,
            r = this.json
          let a
          if (t.array.constructor === Float32Array) a = 5126
          else if (t.array.constructor === Uint32Array) a = 5125
          else if (t.array.constructor === Uint16Array) a = Zm
          else {
            if (t.array.constructor !== Uint8Array)
              throw new Error('THREE.GLTFExporter: Unsupported bufferAttribute component type.')
            a = Km
          }
          if (
            (void 0 === i && (i = 0),
            void 0 === n && (n = t.count),
            s.truncateDrawRange && void 0 !== e && null === e.index)
          ) {
            const s = i + n,
              r = e.drawRange.count === 1 / 0 ? t.count : e.drawRange.start + e.drawRange.count
            ;(i = Math.max(i, e.drawRange.start)), (n = Math.min(s, r) - i) < 0 && (n = 0)
          }
          if (0 === n) return null
          const o = (function (t, e, i) {
            const n = {
              min: new Array(t.itemSize).fill(Number.POSITIVE_INFINITY),
              max: new Array(t.itemSize).fill(Number.NEGATIVE_INFINITY),
            }
            for (let s = e; s < e + i; s++)
              for (let e = 0; e < t.itemSize; e++) {
                let i
                t.itemSize > 4
                  ? (i = t.array[s * t.itemSize + e])
                  : 0 === e
                  ? (i = t.getX(s))
                  : 1 === e
                  ? (i = t.getY(s))
                  : 2 === e
                  ? (i = t.getZ(s))
                  : 3 === e && (i = t.getW(s)),
                  (n.min[e] = Math.min(n.min[e], i)),
                  (n.max[e] = Math.max(n.max[e], i))
              }
            return n
          })(t, i, n)
          let l
          void 0 !== e && (l = t === e.index ? 34963 : 34962)
          const c = this.processBufferView(t, a, i, n, l),
            h = {
              bufferView: c.id,
              byteOffset: c.byteOffset,
              componentType: a,
              count: n,
              max: o.max,
              min: o.min,
              type: { 1: 'SCALAR', 2: 'VEC2', 3: 'VEC3', 4: 'VEC4', 16: 'MAT4' }[t.itemSize],
            }
          return !0 === t.normalized && (h.normalized = !0), r.accessors || (r.accessors = []), r.accessors.push(h) - 1
        }
        processImage(t, e, i) {
          const n = this,
            s = n.cache,
            r = n.json,
            a = n.options,
            o = n.pending
          s.images.has(t) || s.images.set(t, {})
          const l = s.images.get(t),
            c = 1023 === e ? 'image/png' : 'image/jpeg',
            h = c + ':flipY/' + i.toString()
          if (void 0 !== l[h]) return l[h]
          r.images || (r.images = [])
          const u = { mimeType: c }
          if (a.embedImages) {
            const s = (rf = rf || document.createElement('canvas'))
            ;(s.width = Math.min(t.width, a.maxTextureSize)), (s.height = Math.min(t.height, a.maxTextureSize))
            const r = s.getContext('2d')
            if (
              (!0 === i && (r.translate(0, s.height), r.scale(1, -1)),
              ('undefined' != typeof HTMLImageElement && t instanceof HTMLImageElement) ||
                ('undefined' != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement) ||
                ('undefined' != typeof OffscreenCanvas && t instanceof OffscreenCanvas) ||
                ('undefined' != typeof ImageBitmap && t instanceof ImageBitmap))
            )
              r.drawImage(t, 0, 0, s.width, s.height)
            else {
              t.width > a.maxTextureSize || (t.height, a.maxTextureSize)
              const i = new Uint8ClampedArray(t.height * t.width * 4)
              if (1023 === e)
                for (let e = 0; e < i.length; e += 4)
                  (i[e + 0] = t.data[e + 0]),
                    (i[e + 1] = t.data[e + 1]),
                    (i[e + 2] = t.data[e + 2]),
                    (i[e + 3] = t.data[e + 3])
              else
                for (let e = 0, n = 0; e < i.length; e += 4, n += 3)
                  (i[e + 0] = t.data[n + 0]), (i[e + 1] = t.data[n + 1]), (i[e + 2] = t.data[n + 2]), (i[e + 3] = 255)
              r.putImageData(new ImageData(i, t.width, t.height), 0, 0)
            }
            !0 === a.binary
              ? o.push(
                  new Promise(function (t) {
                    s.toBlob(function (e) {
                      n.processBufferViewImage(e).then(function (e) {
                        ;(u.bufferView = e), t()
                      })
                    }, c)
                  }),
                )
              : (u.uri = s.toDataURL(c))
          } else u.uri = t.src
          const d = r.images.push(u) - 1
          return (l[h] = d), d
        }
        processSampler(t) {
          const e = this.json
          e.samplers || (e.samplers = [])
          const i = { magFilter: $m[t.magFilter], minFilter: $m[t.minFilter], wrapS: $m[t.wrapS], wrapT: $m[t.wrapT] }
          return e.samplers.push(i) - 1
        }
        processTexture(t) {
          const e = this.cache,
            i = this.json
          if (e.textures.has(t)) return e.textures.get(t)
          i.textures || (i.textures = [])
          const n = { sampler: this.processSampler(t), source: this.processImage(t.image, t.format, t.flipY) }
          t.name && (n.name = t.name),
            this._invokeAll(function (e) {
              e.writeTexture && e.writeTexture(t, n)
            })
          const s = i.textures.push(n) - 1
          return e.textures.set(t, s), s
        }
        processMaterial(t) {
          const e = this.cache,
            i = this.json
          if (e.materials.has(t)) return e.materials.get(t)
          if (t.isShaderMaterial) return null
          i.materials || (i.materials = [])
          const n = { pbrMetallicRoughness: {} }
          !0 !== t.isMeshStandardMaterial && t.isMeshBasicMaterial
          const s = t.color.toArray().concat([t.opacity])
          if (
            (ef(s, [1, 1, 1, 1]) || (n.pbrMetallicRoughness.baseColorFactor = s),
            t.isMeshStandardMaterial
              ? ((n.pbrMetallicRoughness.metallicFactor = t.metalness),
                (n.pbrMetallicRoughness.roughnessFactor = t.roughness))
              : ((n.pbrMetallicRoughness.metallicFactor = 0.5), (n.pbrMetallicRoughness.roughnessFactor = 0.5)),
            (t.metalnessMap || t.roughnessMap) && t.metalnessMap === t.roughnessMap)
          ) {
            const e = { index: this.processTexture(t.metalnessMap) }
            this.applyTextureTransform(e, t.metalnessMap), (n.pbrMetallicRoughness.metallicRoughnessTexture = e)
          }
          if (t.map) {
            const e = { index: this.processTexture(t.map) }
            this.applyTextureTransform(e, t.map), (n.pbrMetallicRoughness.baseColorTexture = e)
          }
          if (t.emissive) {
            const e = t.emissive.clone().multiplyScalar(t.emissiveIntensity),
              i = Math.max(e.r, e.g, e.b)
            if ((i > 1 && e.multiplyScalar(1 / i), i > 0 && (n.emissiveFactor = e.toArray()), t.emissiveMap)) {
              const e = { index: this.processTexture(t.emissiveMap) }
              this.applyTextureTransform(e, t.emissiveMap), (n.emissiveTexture = e)
            }
          }
          if (t.normalMap) {
            const e = { index: this.processTexture(t.normalMap) }
            t.normalScale && 1 !== t.normalScale.x && (e.scale = t.normalScale.x),
              this.applyTextureTransform(e, t.normalMap),
              (n.normalTexture = e)
          }
          if (t.aoMap) {
            const e = { index: this.processTexture(t.aoMap), texCoord: 1 }
            1 !== t.aoMapIntensity && (e.strength = t.aoMapIntensity),
              this.applyTextureTransform(e, t.aoMap),
              (n.occlusionTexture = e)
          }
          t.transparent
            ? (n.alphaMode = 'BLEND')
            : t.alphaTest > 0 && ((n.alphaMode = 'MASK'), (n.alphaCutoff = t.alphaTest)),
            2 === t.side && (n.doubleSided = !0),
            '' !== t.name && (n.name = t.name),
            this.serializeUserData(t, n),
            this._invokeAll(function (e) {
              e.writeMaterial && e.writeMaterial(t, n)
            })
          const r = i.materials.push(n) - 1
          return e.materials.set(t, r), r
        }
        processMesh(t) {
          const e = this.cache,
            i = this.json,
            n = [t.geometry.uuid]
          if (Array.isArray(t.material)) for (let v = 0, y = t.material.length; v < y; v++) n.push(t.material[v].uuid)
          else n.push(t.material.uuid)
          const s = n.join(':')
          if (e.meshes.has(s)) return e.meshes.get(s)
          const r = t.geometry
          let a
          if (
            ((a = t.isLineSegments
              ? 1
              : t.isLineLoop
              ? 2
              : t.isLine
              ? 3
              : t.isPoints
              ? 0
              : t.material.wireframe
              ? 1
              : 4),
            !0 !== r.isBufferGeometry)
          )
            throw new Error('THREE.GLTFExporter: Geometry is not of type THREE.BufferGeometry.')
          const o = {},
            l = {},
            c = [],
            h = [],
            u = {
              uv: 'TEXCOORD_0',
              uv2: 'TEXCOORD_1',
              color: 'COLOR_0',
              skinWeight: 'WEIGHTS_0',
              skinIndex: 'JOINTS_0',
            },
            d = r.getAttribute('normal')
          void 0 === d ||
            this.isNormalizedNormalAttribute(d) ||
            r.setAttribute('normal', this.createNormalizedNormalAttribute(d))
          let p = null
          for (let v in r.attributes) {
            if ('morph' === v.substr(0, 5)) continue
            const t = r.attributes[v]
            if (
              ((v = u[v] || v.toUpperCase()),
              /^(POSITION|NORMAL|TANGENT|TEXCOORD_\d+|COLOR_\d+|JOINTS_\d+|WEIGHTS_\d+)$/.test(v) || (v = '_' + v),
              e.attributes.has(this.getUID(t)))
            ) {
              l[v] = e.attributes.get(this.getUID(t))
              continue
            }
            p = null
            const i = t.array
            'JOINTS_0' !== v ||
              i instanceof Uint16Array ||
              i instanceof Uint8Array ||
              (p = new Ze(new Uint16Array(i), t.itemSize, t.normalized))
            const n = this.processAccessor(p || t, r)
            null !== n && ((l[v] = n), e.attributes.set(this.getUID(t), n))
          }
          if ((void 0 !== d && r.setAttribute('normal', d), 0 === Object.keys(l).length)) return null
          if (void 0 !== t.morphTargetInfluences && t.morphTargetInfluences.length > 0) {
            const i = [],
              n = [],
              s = {}
            if (void 0 !== t.morphTargetDictionary)
              for (const e in t.morphTargetDictionary) s[t.morphTargetDictionary[e]] = e
            for (let a = 0; a < t.morphTargetInfluences.length; ++a) {
              const o = {}
              let l = !1
              for (const t in r.morphAttributes) {
                if ('position' !== t && 'normal' !== t) {
                  l || (l = !0)
                  continue
                }
                const i = r.morphAttributes[t][a],
                  n = t.toUpperCase(),
                  s = r.attributes[t]
                if (e.attributes.has(this.getUID(i))) {
                  o[n] = e.attributes.get(this.getUID(i))
                  continue
                }
                const c = i.clone()
                if (!r.morphTargetsRelative)
                  for (let t = 0, e = i.count; t < e; t++)
                    c.setXYZ(t, i.getX(t) - s.getX(t), i.getY(t) - s.getY(t), i.getZ(t) - s.getZ(t))
                ;(o[n] = this.processAccessor(c, r)), e.attributes.set(this.getUID(s), o[n])
              }
              h.push(o), i.push(t.morphTargetInfluences[a]), void 0 !== t.morphTargetDictionary && n.push(s[a])
            }
            ;(o.weights = i), n.length > 0 && ((o.extras = {}), (o.extras.targetNames = n))
          }
          const A = Array.isArray(t.material)
          if (A && 0 === r.groups.length) return null
          const g = A ? t.material : [t.material],
            m = A ? r.groups : [{ materialIndex: 0, start: void 0, count: void 0 }]
          for (let v = 0, y = m.length; v < y; v++) {
            const t = { mode: a, attributes: l }
            if ((this.serializeUserData(r, t), h.length > 0 && (t.targets = h), null !== r.index)) {
              let i = this.getUID(r.index)
              ;(void 0 === m[v].start && void 0 === m[v].count) || (i += ':' + m[v].start + ':' + m[v].count),
                e.attributes.has(i)
                  ? (t.indices = e.attributes.get(i))
                  : ((t.indices = this.processAccessor(r.index, r, m[v].start, m[v].count)),
                    e.attributes.set(i, t.indices)),
                null === t.indices && delete t.indices
            }
            const i = this.processMaterial(g[m[v].materialIndex])
            null !== i && (t.material = i), c.push(t)
          }
          ;(o.primitives = c),
            i.meshes || (i.meshes = []),
            this._invokeAll(function (e) {
              e.writeMesh && e.writeMesh(t, o)
            })
          const f = i.meshes.push(o) - 1
          return e.meshes.set(s, f), f
        }
        processCamera(t) {
          const e = this.json
          e.cameras || (e.cameras = [])
          const i = t.isOrthographicCamera,
            n = { type: i ? 'orthographic' : 'perspective' }
          return (
            i
              ? (n.orthographic = {
                  xmag: 2 * t.right,
                  ymag: 2 * t.top,
                  zfar: t.far <= 0 ? 0.001 : t.far,
                  znear: t.near < 0 ? 0 : t.near,
                })
              : (n.perspective = {
                  aspectRatio: t.aspect,
                  yfov: At.degToRad(t.fov),
                  zfar: t.far <= 0 ? 0.001 : t.far,
                  znear: t.near < 0 ? 0 : t.near,
                }),
            '' !== t.name && (n.name = t.type),
            e.cameras.push(n) - 1
          )
        }
        processAnimation(t, e) {
          const i = this.json,
            n = this.nodeMap
          i.animations || (i.animations = [])
          const s = (t = Xm.Utils.mergeMorphTargetTracks(t.clone(), e)).tracks,
            r = [],
            a = []
          for (let o = 0; o < s.length; ++o) {
            const t = s[o],
              i = Pl.parseTrackName(t.name)
            let l = Pl.findNode(e, i.nodeName)
            const c = tf[i.propertyName]
            if (
              ('bones' === i.objectName &&
                (l = !0 === l.isSkinnedMesh ? l.skeleton.getBoneByName(i.objectIndex) : void 0),
              !l || !c)
            )
              return null
            const h = 1
            let u,
              d = t.values.length / t.times.length
            c === tf.morphTargetInfluences && (d /= l.morphTargetInfluences.length),
              !0 === t.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline
                ? ((u = 'CUBICSPLINE'), (d /= 3))
                : (u = 2300 === t.getInterpolation() ? 'STEP' : 'LINEAR'),
              a.push({
                input: this.processAccessor(new Ze(t.times, h)),
                output: this.processAccessor(new Ze(t.values, d)),
                interpolation: u,
              }),
              r.push({ sampler: a.length - 1, target: { node: n.get(l), path: c } })
          }
          return (
            i.animations.push({ name: t.name || 'clip_' + i.animations.length, samplers: a, channels: r }),
            i.animations.length - 1
          )
        }
        processSkin(t) {
          const e = this.json,
            i = this.nodeMap,
            n = e.nodes[i.get(t)],
            s = t.skeleton
          if (void 0 === s) return null
          const r = t.skeleton.bones[0]
          if (void 0 === r) return null
          const a = [],
            o = new Float32Array(16 * s.bones.length),
            l = new ne()
          for (let c = 0; c < s.bones.length; ++c)
            a.push(i.get(s.bones[c])), l.copy(s.boneInverses[c]), l.multiply(t.bindMatrix).toArray(o, 16 * c)
          return (
            void 0 === e.skins && (e.skins = []),
            e.skins.push({ inverseBindMatrices: this.processAccessor(new Ze(o, 16)), joints: a, skeleton: i.get(r) }),
            (n.skin = e.skins.length - 1)
          )
        }
        processNode(t) {
          const e = this.json,
            i = this.options,
            n = this.nodeMap
          e.nodes || (e.nodes = [])
          const s = {}
          if (i.trs) {
            const e = t.quaternion.toArray(),
              i = t.position.toArray(),
              n = t.scale.toArray()
            ef(e, [0, 0, 0, 1]) || (s.rotation = e),
              ef(i, [0, 0, 0]) || (s.translation = i),
              ef(n, [1, 1, 1]) || (s.scale = n)
          } else
            t.matrixAutoUpdate && t.updateMatrix(),
              !1 === ef(t.matrix.elements, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]) &&
                (s.matrix = t.matrix.elements)
          if (
            ('' !== t.name && (s.name = String(t.name)),
            this.serializeUserData(t, s),
            t.isMesh || t.isLine || t.isPoints)
          ) {
            const e = this.processMesh(t)
            null !== e && (s.mesh = e)
          } else t.isCamera && (s.camera = this.processCamera(t))
          if ((t.isSkinnedMesh && this.skins.push(t), t.children.length > 0)) {
            const e = []
            for (let n = 0, s = t.children.length; n < s; n++) {
              const s = t.children[n]
              if (s.visible || !1 === i.onlyVisible) {
                const t = this.processNode(s)
                null !== t && e.push(t)
              }
            }
            e.length > 0 && (s.children = e)
          }
          this._invokeAll(function (e) {
            e.writeNode && e.writeNode(t, s)
          })
          const r = e.nodes.push(s) - 1
          return n.set(t, r), r
        }
        processScene(t) {
          const e = this.json,
            i = this.options
          e.scenes || ((e.scenes = []), (e.scene = 0))
          const n = {}
          '' !== t.name && (n.name = t.name), e.scenes.push(n)
          const s = []
          for (let r = 0, a = t.children.length; r < a; r++) {
            const e = t.children[r]
            if (e.visible || !1 === i.onlyVisible) {
              const t = this.processNode(e)
              null !== t && s.push(t)
            }
          }
          s.length > 0 && (n.nodes = s), this.serializeUserData(t, n)
        }
        processObjects(t) {
          const e = new Rr()
          e.name = 'AuxScene'
          for (let i = 0; i < t.length; i++) e.children.push(t[i])
          this.processScene(e)
        }
        processInput(t) {
          const e = this.options
          ;(t = t instanceof Array ? t : [t]),
            this._invokeAll(function (e) {
              e.beforeParse && e.beforeParse(t)
            })
          const i = []
          for (let n = 0; n < t.length; n++) t[n] instanceof Rr ? this.processScene(t[n]) : i.push(t[n])
          i.length > 0 && this.processObjects(i)
          for (let n = 0; n < this.skins.length; ++n) this.processSkin(this.skins[n])
          for (let n = 0; n < e.animations.length; ++n) this.processAnimation(e.animations[n], t[0])
          this._invokeAll(function (e) {
            e.afterParse && e.afterParse(t)
          })
        }
        _invokeAll(t) {
          for (let e = 0, i = this.plugins.length; e < i; e++) t(this.plugins[e])
        }
      }
      class of {
        constructor(t) {
          ;(this.writer = t), (this.name = 'KHR_lights_punctual')
        }
        writeNode(t, e) {
          if (!t.isLight) return
          if (!t.isDirectionalLight && !t.isPointLight && !t.isSpotLight) return
          const i = this.writer,
            n = i.json,
            s = i.extensionsUsed,
            r = {}
          t.name && (r.name = t.name),
            (r.color = t.color.toArray()),
            (r.intensity = t.intensity),
            t.isDirectionalLight
              ? (r.type = 'directional')
              : t.isPointLight
              ? ((r.type = 'point'), t.distance > 0 && (r.range = t.distance))
              : t.isSpotLight &&
                ((r.type = 'spot'),
                t.distance > 0 && (r.range = t.distance),
                (r.spot = {}),
                (r.spot.innerConeAngle = (t.penumbra - 1) * t.angle * -1),
                (r.spot.outerConeAngle = t.angle)),
            void 0 !== t.decay && t.decay,
            !t.target ||
              (t.target.parent === t && 0 === t.target.position.x && 0 === t.target.position.y && t.target.position.z),
            s[this.name] ||
              ((n.extensions = n.extensions || {}), (n.extensions[this.name] = { lights: [] }), (s[this.name] = !0))
          const a = n.extensions[this.name].lights
          a.push(r), (e.extensions = e.extensions || {}), (e.extensions[this.name] = { light: a.length - 1 })
        }
      }
      class lf {
        constructor(t) {
          ;(this.writer = t), (this.name = 'KHR_materials_unlit')
        }
        writeMaterial(t, e) {
          if (!t.isMeshBasicMaterial) return
          const i = this.writer.extensionsUsed
          ;(e.extensions = e.extensions || {}),
            (e.extensions[this.name] = {}),
            (i[this.name] = !0),
            (e.pbrMetallicRoughness.metallicFactor = 0),
            (e.pbrMetallicRoughness.roughnessFactor = 0.9)
        }
      }
      class cf {
        constructor(t) {
          ;(this.writer = t), (this.name = 'KHR_materials_pbrSpecularGlossiness')
        }
        writeMaterial(t, e) {
          if (!t.isGLTFSpecularGlossinessMaterial) return
          const i = this.writer,
            n = i.extensionsUsed,
            s = {}
          e.pbrMetallicRoughness.baseColorFactor && (s.diffuseFactor = e.pbrMetallicRoughness.baseColorFactor)
          const r = [1, 1, 1]
          if (
            (t.specular.toArray(r, 0),
            (s.specularFactor = r),
            (s.glossinessFactor = t.glossiness),
            e.pbrMetallicRoughness.baseColorTexture && (s.diffuseTexture = e.pbrMetallicRoughness.baseColorTexture),
            t.specularMap)
          ) {
            const e = { index: i.processTexture(t.specularMap) }
            i.applyTextureTransform(e, t.specularMap), (s.specularGlossinessTexture = e)
          }
          ;(e.extensions = e.extensions || {}), (e.extensions[this.name] = s), (n[this.name] = !0)
        }
      }
      class hf {
        constructor(t) {
          ;(this.writer = t), (this.name = 'KHR_materials_transmission')
        }
        writeMaterial(t, e) {
          if (!t.isMeshPhysicalMaterial || 0 === t.transmission) return
          const i = this.writer,
            n = i.extensionsUsed,
            s = {}
          if (((s.transmissionFactor = t.transmission), t.transmissionMap)) {
            const e = { index: i.processTexture(t.transmissionMap) }
            i.applyTextureTransform(e, t.transmissionMap), (s.transmissionTexture = e)
          }
          ;(e.extensions = e.extensions || {}), (e.extensions[this.name] = s), (n[this.name] = !0)
        }
      }
      class uf {
        constructor(t) {
          ;(this.writer = t), (this.name = 'KHR_materials_volume')
        }
        writeMaterial(t, e) {
          if (!t.isMeshPhysicalMaterial || 0 === t.thickness) return
          const i = this.writer,
            n = i.extensionsUsed,
            s = {}
          if (((s.thicknessFactor = t.thickness), t.thicknessMap)) {
            const e = { index: i.processTexture(t.thicknessMap) }
            i.applyTextureTransform(e, t.thicknessMap), (s.thicknessTexture = e)
          }
          ;(s.attenuationDistance = t.attenuationDistance),
            (s.attenuationColor = t.attenuationTint.toArray()),
            (e.extensions = e.extensions || {}),
            (e.extensions[this.name] = s),
            (n[this.name] = !0)
        }
      }
      Xm.Utils = {
        insertKeyframe: function (t, e) {
          const i = 0.001,
            n = t.getValueSize(),
            s = new t.TimeBufferType(t.times.length + 1),
            r = new t.ValueBufferType(t.values.length + n),
            a = t.createInterpolant(new t.ValueBufferType(n))
          let o
          if (0 === t.times.length) {
            s[0] = e
            for (let t = 0; t < n; t++) r[t] = 0
            o = 0
          } else if (e < t.times[0]) {
            if (Math.abs(t.times[0] - e) < i) return 0
            ;(s[0] = e), s.set(t.times, 1), r.set(a.evaluate(e), 0), r.set(t.values, n), (o = 0)
          } else if (e > t.times[t.times.length - 1]) {
            if (Math.abs(t.times[t.times.length - 1] - e) < i) return t.times.length - 1
            ;(s[s.length - 1] = e),
              s.set(t.times, 0),
              r.set(t.values, 0),
              r.set(a.evaluate(e), t.values.length),
              (o = s.length - 1)
          } else
            for (let l = 0; l < t.times.length; l++) {
              if (Math.abs(t.times[l] - e) < i) return l
              if (t.times[l] < e && t.times[l + 1] > e) {
                s.set(t.times.slice(0, l + 1), 0),
                  (s[l + 1] = e),
                  s.set(t.times.slice(l + 1), l + 2),
                  r.set(t.values.slice(0, (l + 1) * n), 0),
                  r.set(a.evaluate(e), (l + 1) * n),
                  r.set(t.values.slice((l + 1) * n), (l + 2) * n),
                  (o = l + 1)
                break
              }
            }
          return (t.times = s), (t.values = r), o
        },
        mergeMorphTargetTracks: function (t, e) {
          const i = [],
            n = {},
            s = t.tracks
          for (let r = 0; r < s.length; ++r) {
            let t = s[r]
            const a = Pl.parseTrackName(t.name),
              o = Pl.findNode(e, a.nodeName)
            if ('morphTargetInfluences' !== a.propertyName || void 0 === a.propertyIndex) {
              i.push(t)
              continue
            }
            if (
              t.createInterpolant !== t.InterpolantFactoryMethodDiscrete &&
              t.createInterpolant !== t.InterpolantFactoryMethodLinear
            ) {
              if (t.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline)
                throw new Error('THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.')
              ;(t = t.clone()), t.setInterpolation(2301)
            }
            const l = o.morphTargetInfluences.length,
              c = o.morphTargetDictionary[a.propertyIndex]
            if (void 0 === c) throw new Error('THREE.GLTFExporter: Morph target name not found: ' + a.propertyIndex)
            let h
            if (void 0 === n[o.uuid]) {
              h = t.clone()
              const e = new h.ValueBufferType(l * h.times.length)
              for (let t = 0; t < h.times.length; t++) e[t * l + c] = h.values[t]
              ;(h.name = (a.nodeName || '') + '.morphTargetInfluences'), (h.values = e), (n[o.uuid] = h), i.push(h)
              continue
            }
            const u = t.createInterpolant(new t.ValueBufferType(1))
            h = n[o.uuid]
            for (let e = 0; e < h.times.length; e++) h.values[e * l + c] = u.evaluate(h.times[e])
            for (let e = 0; e < t.times.length; e++) {
              const i = this.insertKeyframe(h, t.times[e])
              h.values[i * l + c] = t.values[e]
            }
          }
          return (t.tracks = i), t
        },
      }
      /* @license
       * Copyright 2021 Google LLC. All Rights Reserved.
       * Licensed under the Apache License, Version 2.0 (the 'License');
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *     http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an 'AS IS' BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */
      const df = (t) =>
          void 0 !== t.material &&
          t.userData &&
          t.userData.variantMaterials &&
          !!Array.from(t.userData.variantMaterials.values()).filter((t) => pf(t.material)),
        pf = (t) => t && t.isMaterial && !Array.isArray(t)
      class Af {
        constructor(t) {
          ;(this.writer = t), (this.name = 'KHR_materials_variants'), (this.variantNames = [])
        }
        beforeParse(t) {
          const e = new Set()
          for (const i of t)
            i.traverse((t) => {
              if (!df(t)) return
              const i = t.userData.variantMaterials
              for (const n of i.keys()) {
                const t = i.get(n)
                pf(t.material) && e.add(n)
              }
            })
          e.forEach((t) => this.variantNames.push(t))
        }
        writeMesh(t, e) {
          if (!df(t)) return
          const i = t.userData,
            n = i.variantMaterials,
            s = new Map()
          for (const o of n.keys()) {
            const t = n.get(o).material
            if (!pf(t)) continue
            const e = this.variantNames.indexOf(o),
              i = this.writer.processMaterial(t)
            s.has(i) || s.set(i, { material: i, variants: [] }), s.get(i).variants.push(e)
          }
          const r = Array.from(s.values())
            .map((t) => t.variants.sort((t, e) => t - e) && t)
            .sort((t, e) => t.material - e.material)
          if (0 === r.length) return
          const a = pf(i.originalMaterial) ? this.writer.processMaterial(i.originalMaterial) : -1
          for (const o of e.primitives)
            a >= 0 && (o.material = a), (o.extensions = o.extensions || {}), (o.extensions[this.name] = { mappings: r })
        }
        afterParse() {
          if (0 === this.variantNames.length) return
          const t = this.writer.json
          t.extensions = t.extensions || {}
          const e = this.variantNames.map((t) => ({ name: t }))
          ;(t.extensions[this.name] = { variants: e }), (this.writer.extensionsUsed[this.name] = !0)
        }
      }
      /* @license
       * Copyright 2020 Google LLC. All Rights Reserved.
       * Licensed under the Apache License, Version 2.0 (the 'License');
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *     http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an 'AS IS' BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ const gf = Symbol('correlatedObjects'),
        mf = Symbol('sourceObject'),
        ff = Symbol('onUpdate')
      class vf {
        constructor(t, e, i = null) {
          ;(this[ff] = t), (this[mf] = e), (this[gf] = i)
          /* @license
           * Copyright 2020 Google LLC. All Rights Reserved.
           * Licensed under the Apache License, Version 2.0 (the 'License');
           * you may not use this file except in compliance with the License.
           * You may obtain a copy of the License at
           *
           *     http://www.apache.org/licenses/LICENSE-2.0
           *
           * Unless required by applicable law or agreed to in writing, software
           * distributed under the License is distributed on an 'AS IS' BASIS,
           * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
           * See the License for the specific language governing permissions and
           * limitations under the License.
           */
        }
      }
      const yf = new $o(),
        xf = new Je(),
        wf = new Ji(2, 2),
        _f = Symbol('threeTexture')
      class If extends vf {
        get [_f]() {
          var t
          return null === (t = this[gf]) || void 0 === t ? void 0 : t.values().next().value
        }
        constructor(t, e, i) {
          super(
            t,
            (i = null != i ? i : { name: 'adhoc_image', uri: e && e.image ? e.image.src : 'adhoc_image' }),
            new Set(e ? [e] : []),
          )
        }
        get name() {
          return this[mf].name || ''
        }
        get uri() {
          return this[mf].uri
        }
        get bufferView() {
          return this[mf].bufferView
        }
        get type() {
          return null != this.uri ? 'external' : 'embedded'
        }
        async setURI(t) {
          this[mf].uri = t
          const e = await new Promise((e, i) => {
              yf.load(t, e, void 0, i)
            }),
            i = this[_f]
          ;(i.image = e), (i.needsUpdate = !0), this[ff]()
        }
        async createThumbnail(t, e) {
          const i = new Rr()
          xf.map = this[_f]
          const n = new Si(wf, xf)
          i.add(n)
          const s = new an(-1, 1, 1, -1, 0, 1),
            { threeRenderer: r } = gd.singleton,
            a = new It(t, e)
          r.setRenderTarget(a), r.render(i, s), r.setRenderTarget(null)
          const o = new Uint8Array(t * e * 4)
          r.readRenderTargetPixels(a, 0, 0, t, e, o), (Qd.width = t), (Qd.height = e)
          const l = Qd.getContext('2d'),
            c = l.createImageData(t, e)
          return (
            c.data.set(o),
            l.putImageData(c, 0, 0),
            new Promise(async (t, e) => {
              Qd.toBlob((i) => {
                if (!i) return e('Failed to capture thumbnail.')
                t(URL.createObjectURL(i))
              }, 'image/png')
            })
          )
        }
      }
      var Cf, Mf
      !(function (t) {
        ;(t[(t.Nearest = 9728)] = 'Nearest'),
          (t[(t.Linear = 9729)] = 'Linear'),
          (t[(t.NearestMipmapNearest = 9984)] = 'NearestMipmapNearest'),
          (t[(t.LinearMipmapNearest = 9985)] = 'LinearMipmapNearest'),
          (t[(t.NearestMipmapLinear = 9986)] = 'NearestMipmapLinear'),
          (t[(t.LinearMipmapLinear = 9987)] = 'LinearMipmapLinear')
      })(Cf || (Cf = {})),
        (function (t) {
          ;(t[(t.ClampToEdge = 33071)] = 'ClampToEdge'),
            (t[(t.MirroredRepeat = 33648)] = 'MirroredRepeat'),
            (t[(t.Repeat = 10497)] = 'Repeat')
        })(Mf || (Mf = {}))
      /* @license
       * Copyright 2020 Google LLC. All Rights Reserved.
       * Licensed under the Apache License, Version 2.0 (the 'License');
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *     http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an 'AS IS' BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */
      const Ef = (() => {
          const t = [
            Cf.Nearest,
            Cf.Linear,
            Cf.NearestMipmapNearest,
            Cf.LinearMipmapLinear,
            Cf.NearestMipmapLinear,
            Cf.LinearMipmapLinear,
          ]
          return (e) => t.indexOf(e) > -1
        })(),
        bf = (() => {
          const t = [Cf.Nearest, Cf.Linear]
          return (e) => t.indexOf(e) > -1
        })(),
        Sf = (() => {
          const t = [Mf.ClampToEdge, Mf.MirroredRepeat, Mf.Repeat]
          return (e) => t.indexOf(e) > -1
        })(),
        Bf = Symbol('threeTextures'),
        Tf = Symbol('setProperty'),
        Lf = Symbol('sourceSampler')
      class Df extends vf {
        get [Bf]() {
          return this[gf]
        }
        get [Lf]() {
          return this[mf]
        }
        constructor(t, e, i) {
          null == (i = null != i ? i : {}).minFilter && (i.minFilter = e ? e.minFilter : Cf.LinearMipmapLinear),
            null == i.magFilter && (i.magFilter = e ? e.magFilter : Cf.Linear),
            null == i.wrapS && (i.wrapS = e ? e.wrapS : Mf.Repeat),
            null == i.wrapT && (i.wrapT = e ? e.wrapT : Mf.Repeat),
            super(t, i, new Set(e ? [e] : []))
        }
        get name() {
          return this[mf].name || ''
        }
        get minFilter() {
          return this[Lf].minFilter
        }
        get magFilter() {
          return this[Lf].magFilter
        }
        get wrapS() {
          return this[Lf].wrapS
        }
        get wrapT() {
          return this[Lf].wrapT
        }
        setMinFilter(t) {
          this[Tf]('minFilter', t)
        }
        setMagFilter(t) {
          this[Tf]('magFilter', t)
        }
        setWrapS(t) {
          this[Tf]('wrapS', t)
        }
        setWrapT(t) {
          this[Tf]('wrapT', t)
        }
        [Tf](t, e) {
          const i = this[Lf]
          if (null != i) {
            if (
              ((t, e) => {
                switch (t) {
                  case 'minFilter':
                    return Ef(e)
                  case 'magFilter':
                    return bf(e)
                  case 'wrapS':
                  case 'wrapT':
                    return Sf(e)
                  default:
                    throw new Error(`Cannot configure property "${t}" on Sampler`)
                }
              })(t, e)
            ) {
              i[t] = e
              for (const i of this[Bf]) (i[t] = e), (i.needsUpdate = !0)
            }
            this[ff]()
          }
        }
      }
      /* @license
       * Copyright 2020 Google LLC. All Rights Reserved.
       * Licensed under the Apache License, Version 2.0 (the 'License');
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *     http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an 'AS IS' BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ const Qf = Symbol('image'),
        Rf = Symbol('sampler')
      class Pf extends vf {
        constructor(t, e, i = null, n = null, s = null) {
          super(t, i || {}, new Set(e ? [e] : [])), (this[Rf] = new Df(t, e, n)), (this[Qf] = new If(t, e, s))
        }
        get name() {
          return this[mf].name || ''
        }
        get sampler() {
          return this[Rf]
        }
        get source() {
          return this[Qf]
        }
      }
      /* @license
       * Copyright 2020 Google LLC. All Rights Reserved.
       * Licensed under the Apache License, Version 2.0 (the 'License');
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *     http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an 'AS IS' BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ var Nf
      const Ff = Symbol('texture'),
        Uf = Symbol('materials'),
        kf = Symbol('usage')
      var Of
      !(function (t) {
        ;(t[(t.Base = 0)] = 'Base'),
          (t[(t.MetallicRoughness = 1)] = 'MetallicRoughness'),
          (t[(t.Normal = 2)] = 'Normal'),
          (t[(t.Occlusion = 3)] = 'Occlusion'),
          (t[(t.Emissive = 4)] = 'Emissive')
      })(Of || (Of = {}))
      class Gf {
        constructor(t, e, i, n, s, r) {
          if (((this[Nf] = null), r)) {
            const e = s.textures ? s.textures[r.index] : null,
              n = e && s.samplers ? s.samplers[e.sampler] : null,
              a = e && s.images ? s.images[e.source] : null
            this[Ff] = new Pf(t, i, e, n, a)
          }
          ;(this.onUpdate = t), (this[Uf] = n), (this[kf] = e)
        }
        get texture() {
          return this[Ff]
        }
        setTexture(t) {
          const e = null != t ? t.source[_f] : null
          let i = 3001
          if (((this[Ff] = t), this[Uf]))
            for (const n of this[Uf]) {
              switch (this[kf]) {
                case Of.Base:
                  n.map = e
                  break
                case Of.MetallicRoughness:
                  ;(i = 3e3), (n.metalnessMap = e), (n.roughnessMap = e)
                  break
                case Of.Normal:
                  ;(i = 3e3), (n.normalMap = e)
                  break
                case Of.Occlusion:
                  ;(i = 3e3), (n.aoMap = e)
                  break
                case Of.Emissive:
                  n.emissiveMap = e
              }
              n.needsUpdate = !0
            }
          e && (e.encoding = i), this.onUpdate()
        }
      }
      Nf = Ff
      /* @license
       * Copyright 2020 Google LLC. All Rights Reserved.
       * Licensed under the Apache License, Version 2.0 (the 'License');
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *     http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an 'AS IS' BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */
      const zf = Symbol('threeMaterials'),
        Vf = Symbol('baseColorTexture'),
        Hf = Symbol('metallicRoughnessTexture')
      class Wf extends vf {
        constructor(t, e, i, n) {
          super(t, i, n),
            null == i.baseColorFactor && (i.baseColorFactor = [1, 1, 1, 1]),
            null == i.roughnessFactor && (i.roughnessFactor = 1),
            null == i.metallicFactor && (i.metallicFactor = 1)
          const { baseColorTexture: s, metallicRoughnessTexture: r } = i,
            { map: a, metalnessMap: o } = n.values().next().value
          ;(this[Vf] = new Gf(t, Of.Base, a, n, e, s || null)),
            (this[Hf] = new Gf(t, Of.MetallicRoughness, o, n, e, r || null))
        }
        get [zf]() {
          return this[gf]
        }
        get baseColorFactor() {
          return this[mf].baseColorFactor
        }
        get metallicFactor() {
          return this[mf].metallicFactor
        }
        get roughnessFactor() {
          return this[mf].roughnessFactor
        }
        get baseColorTexture() {
          return this[Vf]
        }
        get metallicRoughnessTexture() {
          return this[Hf]
        }
        setBaseColorFactor(t) {
          for (const e of this[zf]) e.color.fromArray(t), (e.opacity = t[3])
          ;(this[mf].baseColorFactor = t), this[ff]()
        }
        setMetallicFactor(t) {
          for (const e of this[zf]) e.metalness = t
          ;(this[mf].metallicFactor = t), this[ff]()
        }
        setRoughnessFactor(t) {
          for (const e of this[zf]) e.roughness = t
          ;(this[mf].roughnessFactor = t), this[ff]()
        }
      }
      /* @license
       * Copyright 2020 Google LLC. All Rights Reserved.
       * Licensed under the Apache License, Version 2.0 (the 'License');
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *     http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an 'AS IS' BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ const qf = Symbol('pbrMetallicRoughness'),
        jf = Symbol('normalTexture'),
        Yf = Symbol('occlusionTexture'),
        Jf = Symbol('emissiveTexture'),
        Xf = Symbol('backingThreeMaterial'),
        Kf = Symbol('applyAlphaCutoff')
      class Zf extends vf {
        constructor(t, e, i, n) {
          if ((super(t, i, n), null == n)) return
          i.extensions && i.extensions.KHR_materials_pbrSpecularGlossiness,
            null == i.pbrMetallicRoughness && (i.pbrMetallicRoughness = {}),
            (this[qf] = new Wf(t, e, i.pbrMetallicRoughness, n)),
            null == i.emissiveFactor && (i.emissiveFactor = [0, 0, 0]),
            null == i.doubleSided && (i.doubleSided = !1),
            null == i.alphaMode && (i.alphaMode = 'OPAQUE'),
            null == i.alphaCutoff && (i.alphaCutoff = 0.5)
          const { normalTexture: s, occlusionTexture: r, emissiveTexture: a } = i,
            { normalMap: o, aoMap: l, emissiveMap: c } = n.values().next().value
          ;(this[jf] = new Gf(t, Of.Normal, o, n, e, s || null)),
            (this[Yf] = new Gf(t, Of.Occlusion, l, n, e, r || null)),
            (this[Jf] = new Gf(t, Of.Emissive, c, n, e, a || null))
        }
        get [Xf]() {
          return this[gf].values().next().value
        }
        get name() {
          return this[mf].name || ''
        }
        get pbrMetallicRoughness() {
          return this[qf]
        }
        get normalTexture() {
          return this[jf]
        }
        get occlusionTexture() {
          return this[Yf]
        }
        get emissiveTexture() {
          return this[Jf]
        }
        get emissiveFactor() {
          return this[mf].emissiveFactor
        }
        setEmissiveFactor(t) {
          for (const e of this[gf]) e.emissive.fromArray(t)
          ;(this[mf].emissiveFactor = t), this[ff]()
        }
        [Kf]() {
          const t = this[mf],
            e =
              'OPAQUE' === t.alphaMode ? -0.5 : 'BLEND' === t.alphaMode ? 0 : Math.max(1e-4, Math.min(1, t.alphaCutoff))
          for (const i of this[gf]) (i.alphaTest = e), (i.needsUpdate = !0)
        }
        setAlphaCutoff(t) {
          ;(this[mf].alphaCutoff = t), this[Kf](), this[ff]()
        }
        getAlphaCutoff() {
          return this[mf].alphaCutoff
        }
        setDoubleSided(t) {
          for (const e of this[gf]) (e.side = t ? 2 : 0), (e.needsUpdate = !0)
          ;(this[mf].doubleSided = t), this[ff]()
        }
        getDoubleSided() {
          return this[mf].doubleSided
        }
        setAlphaMode(t) {
          const e = (t, e) => {
            ;(t.transparent = e), (t.depthWrite = !e)
          }
          this[mf].alphaMode = t
          for (const i of this[gf]) e(i, 'OPAQUE' !== t), this[Kf](), (i.needsUpdate = !0)
          this[ff]()
        }
        getAlphaMode() {
          return this[mf].alphaMode
        }
      }
      /* @license
       * Copyright 2020 Google LLC. All Rights Reserved.
       * Licensed under the Apache License, Version 2.0 (the 'License');
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *     http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an 'AS IS' BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ var $f
      const tv = Symbol('materials')
      class ev {
        constructor(t, e = () => {}) {
          this[$f] = []
          const { gltf: i, gltfElementMap: n } = t
          i.materials.forEach((t) => {
            this[tv].push(new Zf(e, i, t, n.get(t)))
          })
        }
        get materials() {
          return this[tv]
        }
      }
      $f = tv
      /* @license
       * Copyright 2020 Google LLC. All Rights Reserved.
       * Licensed under the Apache License, Version 2.0 (the 'License');
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *     http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an 'AS IS' BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */
      var iv = function (t, e, i, n) {
        for (
          var s,
            r = arguments.length,
            a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n,
            o = t.length - 1;
          o >= 0;
          o--
        )
          (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a)
        return r > 3 && a && Object.defineProperty(e, i, a), a
      }
      const nv = Symbol('currentGLTF'),
        sv = Symbol('model'),
        rv = Symbol('variants'),
        av = Symbol('getOnUpdateMethod'),
        ov = Symbol('textureLoader'),
        lv = Symbol('originalGltfJson')
      /* @license
       * Copyright 2019 Google LLC. All Rights Reserved.
       * Licensed under the Apache License, Version 2.0 (the 'License');
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *     http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an 'AS IS' BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ var cv = function (t, e, i, n) {
        for (
          var s,
            r = arguments.length,
            a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n,
            o = t.length - 1;
          o >= 0;
          o--
        )
          (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a)
        return r > 3 && a && Object.defineProperty(e, i, a), a
      }
      const hv = Math.PI / 32,
        uv = { basis: [$h(Vh(hv, 'rad'))], keywords: { auto: [null] } },
        dv = Symbol('autoRotateStartTime'),
        pv = Symbol('radiansPerSecond'),
        Av = Symbol('syncRotationRate'),
        gv = Symbol('onCameraChange'),
        mv = ((t) => {
          var e, i, n
          class s extends t {
            constructor() {
              super(...arguments),
                (this[e] = new Map()),
                (this[i] = (t) => {
                  t.forEach((t) => {
                    ;(t instanceof MutationRecord && 'childList' !== t.type) ||
                      (t.addedNodes.forEach((t) => {
                        this[vp](t)
                      }),
                      t.removedNodes.forEach((t) => {
                        this[yp](t)
                      }),
                      this[$d]())
                  })
                }),
                (this[n] = new MutationObserver(this[mp]))
            }
            connectedCallback() {
              super.connectedCallback()
              for (let e = 0; e < this.children.length; ++e) this[vp](this.children[e])
              const { ShadyDOM: t } = self
              null == t ? this[fp].observe(this, { childList: !0 }) : (this[fp] = t.observeChildren(this, this[mp]))
            }
            disconnectedCallback() {
              super.disconnectedCallback()
              const { ShadyDOM: t } = self
              null == t ? this[fp].disconnect() : t.unobserveChildren(this[fp])
            }
            [((e = gp), (i = mp), (n = fp), tp)](t, e) {
              super[tp](t, e)
              const i = this[Zd],
                { annotationRenderer: n } = i,
                s = i.getCamera()
              i.isDirty && (i.updateHotspots(s.position), (n.domElement.style.display = ''), n.render(i, s))
            }
            updateHotspot(t) {
              const e = this[gp].get(t.name)
              null != e && (e.updatePosition(t.position), e.updateNormal(t.normal), this[$d]())
            }
            positionAndNormalFromPoint(t, e) {
              const i = this[Zd],
                { width: n, height: s, target: r } = i
              xp
                .set(t / n, e / s)
                .multiplyScalar(2)
                .subScalar(1),
                (xp.y *= -1)
              const a = i.positionAndNormalFromPoint(xp)
              if (null == a) return null
              wp.copy(r.matrixWorld).invert()
              const o = hp(a.position.applyMatrix4(wp))
              return _p.getNormalMatrix(wp), { position: o, normal: hp(a.normal.applyNormalMatrix(_p)) }
            }
            [vp](t) {
              if (!(t instanceof HTMLElement && 0 === t.slot.indexOf('hotspot'))) return
              let e = this[gp].get(t.slot)
              null != e
                ? e.increment()
                : ((e = new iu({ name: t.slot, position: t.dataset.position, normal: t.dataset.normal })),
                  this[gp].set(t.slot, e),
                  this[Zd].addHotspot(e)),
                (this[Zd].isDirty = !0)
            }
            [yp](t) {
              if (!(t instanceof HTMLElement)) return
              const e = this[gp].get(t.slot)
              e && (e.decrement() && (this[Zd].removeHotspot(e), this[gp].delete(t.slot)), (this[Zd].isDirty = !0))
            }
          }
          return s
        })(
          ((t) => {
            var e, i, n, s, r
            class a extends t {
              constructor() {
                super(...arguments),
                  (this[e] = void 0),
                  (this[i] = null),
                  (this[n] = []),
                  (this[s] = new il()),
                  (this[r] = null),
                  (this.variantName = void 0),
                  (this.orientation = '0 0 0'),
                  (this.scale = '1 1 1')
              }
              get model() {
                return this[sv]
              }
              get availableVariants() {
                return this[rv]
              }
              get originalGltfJson() {
                return this[lv]
              }
              [((e = sv), (i = nv), (n = rv), (s = ov), (r = lv), av)]() {
                return () => {
                  this[$d]()
                }
              }
              async createTexture(t, e = 'image/png') {
                const i = this[nv],
                  n = await new Promise((e) => this[ov].load(t, e))
                return i && n
                  ? ((n.encoding = 3001),
                    (n.wrapS = 1e3),
                    (n.wrapT = 1e3),
                    (n.flipY = !1),
                    'image/jpeg' === e && (n.format = 1022),
                    new Pf(this[av](), n))
                  : null
              }
              async updated(t) {
                if ((super.updated(t), t.has('variantName'))) {
                  const t = this[nv],
                    { variantName: e } = this
                  if (null == t) return
                  const i = await t.correlatedSceneGraph.loadVariant(e),
                    { gltf: n, gltfElementMap: s } = t.correlatedSceneGraph
                  for (const r of i) {
                    const t = n.materials[r]
                    this[sv].materials[r] = new Zf(this[av](), n, t, s.get(t))
                  }
                  this[$d]()
                }
                if (t.has('orientation') || t.has('scale')) {
                  const { modelContainer: t } = this[Zd],
                    e = Hh(this.orientation)[0].terms,
                    i = eu(e[0]).number,
                    n = eu(e[1]).number,
                    s = eu(e[2]).number
                  t.quaternion.setFromEuler(new pe(n, s, i, 'YXZ'))
                  const r = Hh(this.scale)[0].terms
                  t.scale.set(r[0].number, r[1].number, r[2].number),
                    this[Zd].updateBoundingBox(),
                    this[Zd].updateShadow(),
                    this[np].arRenderer.onUpdateScene(),
                    this[$d]()
                }
              }
              [ep]() {
                super[ep](), (this[rv] = [])
                const { currentGLTF: t } = this[Zd]
                if (null != t) {
                  const { correlatedSceneGraph: e } = t
                  null != e &&
                    t !== this[nv] &&
                    ((this[sv] = new ev(e, this[av]())), (this[lv] = JSON.parse(JSON.stringify(e.gltf)))),
                    'variants' in t.userData &&
                      ((this[rv] = t.userData.variants.slice()), this.requestUpdate('variantName'))
                }
                ;(this[nv] = t), this.dispatchEvent(new CustomEvent('scene-graph-ready'))
              }
              async exportScene(t) {
                const e = this[Zd]
                return new Promise(async (i) => {
                  const n = {
                    binary: !0,
                    onlyVisible: !0,
                    maxTextureSize: 1 / 0,
                    forcePowerOfTwoTextures: !1,
                    includeCustomExtensions: !1,
                    embedImages: !0,
                  }
                  Object.assign(n, t), (n.animations = e.animations), (n.truncateDrawRange = !0)
                  const s = e.shadow
                  let r = !1
                  null != s && ((r = s.visible), (s.visible = !1))
                  const a = this[nv]
                  null != a &&
                    'functions' in a.userData &&
                    'ensureLoadVariants' in a.userData.functions &&
                    (await a.userData.functions.ensureLoadVariants(e)),
                    new Xm()
                      .register((t) => new Af(t))
                      .parse(
                        e.modelContainer.children[0],
                        (t) =>
                          i(
                            new Blob([n.binary ? t : JSON.stringify(t)], {
                              type: n.binary ? 'application/octet-stream' : 'application/json',
                            }),
                          ),
                        n,
                      ),
                    null != s && (s.visible = r)
                })
              }
            }
            return (
              iv([U({ type: String, attribute: 'variant-name' })], a.prototype, 'variantName', void 0),
              iv([U({ type: String, attribute: 'orientation' })], a.prototype, 'orientation', void 0),
              iv([U({ type: String, attribute: 'scale' })], a.prototype, 'scale', void 0),
              a
            )
          })(
            ((t) => {
              var e, i, n
              class s extends t {
                constructor() {
                  super(...arguments),
                    (this.autoRotate = !1),
                    (this.autoRotateDelay = 3e3),
                    (this.rotationPerSecond = 'auto'),
                    (this[e] = performance.now()),
                    (this[i] = 0),
                    (this[n] = (t) => {
                      this.autoRotate && 'user-interaction' === t.detail.source && (this[dv] = performance.now())
                    })
                }
                connectedCallback() {
                  super.connectedCallback(),
                    this.addEventListener('camera-change', this[gv]),
                    (this[dv] = performance.now())
                }
                disconnectedCallback() {
                  super.disconnectedCallback(),
                    this.removeEventListener('camera-change', this[gv]),
                    (this[dv] = performance.now())
                }
                updated(t) {
                  super.updated(t), t.has('autoRotate') && (this[dv] = performance.now())
                }
                [((e = dv), (i = pv), Av)](t) {
                  this[pv] = t[0]
                }
                [tp](t, e) {
                  if ((super[tp](t, e), !this.autoRotate || !this[cp]() || this[np].isPresenting)) return
                  const i = Math.min(e, t - this[dv] - this.autoRotateDelay)
                  i > 0 && (this[Zd].yaw = this.turntableRotation + this[pv] * i * 0.001)
                }
                get turntableRotation() {
                  return this[Zd].yaw
                }
                resetTurntableRotation(t = 0) {
                  this[Zd].yaw = t
                }
              }
              return (
                (n = gv),
                cv([U({ type: Boolean, attribute: 'auto-rotate' })], s.prototype, 'autoRotate', void 0),
                cv([U({ type: Number, attribute: 'auto-rotate-delay' })], s.prototype, 'autoRotateDelay', void 0),
                cv(
                  [Eg({ intrinsics: uv, updateHandler: Av }), U({ type: String, attribute: 'rotation-per-second' })],
                  s.prototype,
                  'rotationPerSecond',
                  void 0,
                ),
                s
              )
            })(
              ((t) => {
                var e, i, n
                class s extends t {
                  constructor() {
                    super(...arguments),
                      (this.environmentImage = null),
                      (this.skyboxImage = null),
                      (this.shadowIntensity = 0),
                      (this.shadowSoftness = 1),
                      (this.exposure = 1),
                      (this[e] = null),
                      (this[i] = null),
                      (this[n] = (t) => {
                        t.element === this && this[Iu]()
                      })
                  }
                  connectedCallback() {
                    super.connectedCallback(), this[np].loader.addEventListener('preload', this[Mu])
                  }
                  disconnectedCallback() {
                    super.disconnectedCallback(), this[np].loader.removeEventListener('preload', this[Mu])
                  }
                  updated(t) {
                    super.updated(t),
                      t.has('shadowIntensity') && (this[Zd].setShadowIntensity(0.1 * this.shadowIntensity), this[$d]()),
                      t.has('shadowSoftness') && (this[Zd].setShadowSoftness(this.shadowSoftness), this[$d]()),
                      t.has('exposure') && ((this[Zd].exposure = this.exposure), this[$d]()),
                      (t.has('environmentImage') || t.has('skyboxImage')) && this[op]() && this[Iu]()
                  }
                  [((e = wu), (i = Cu), (n = Mu), ep)]() {
                    super[ep](), null != this[wu] && this[_u](this[wu])
                  }
                  async [Iu]() {
                    const { skyboxImage: t, environmentImage: e } = this
                    null != this[Cu] && (this[Cu](), (this[Cu] = null))
                    const { textureUtils: i } = this[np]
                    if (null != i)
                      try {
                        const { environmentMap: n, skybox: s } = await new Promise(async (n, s) => {
                            const r = i.generateEnvironmentMapAndSkybox(Ph(t), e, { progressTracker: this[sp] })
                            ;(this[Cu] = () => s(r)), n(await r)
                          }),
                          r = n.texture
                        ;(this[Zd].background = null != s ? (s.userData.url === r.userData.url ? r : s) : null),
                          this[_u](n.texture),
                          this[Zd].dispatchEvent({ type: 'envmap-update' })
                      } catch (t) {
                        if (t instanceof Error) throw (this[_u](null), t)
                      }
                  }
                  [_u](t) {
                    ;(this[wu] = t),
                      (this[Zd].environment = this[wu]),
                      this.dispatchEvent(new CustomEvent('environment-change')),
                      this[$d]()
                  }
                }
                return (
                  xu([U({ type: String, attribute: 'environment-image' })], s.prototype, 'environmentImage', void 0),
                  xu([U({ type: String, attribute: 'skybox-image' })], s.prototype, 'skyboxImage', void 0),
                  xu([U({ type: Number, attribute: 'shadow-intensity' })], s.prototype, 'shadowIntensity', void 0),
                  xu([U({ type: Number, attribute: 'shadow-softness' })], s.prototype, 'shadowSoftness', void 0),
                  xu([U({ type: Number })], s.prototype, 'exposure', void 0),
                  s
                )
              })(
                ((t) => {
                  var e, i, n, s, r, a, o, l, c, h, u, d, p, A, g, m, f
                  class v extends t {
                    constructor() {
                      super(...arguments),
                        (this.cameraControls = !1),
                        (this.cameraOrbit = '0deg 75deg 105%'),
                        (this.cameraTarget = 'auto auto auto'),
                        (this.fieldOfView = 'auto'),
                        (this.minCameraOrbit = 'auto'),
                        (this.maxCameraOrbit = 'auto'),
                        (this.minFieldOfView = 'auto'),
                        (this.maxFieldOfView = 'auto'),
                        (this.interactionPromptThreshold = 3e3),
                        (this.interactionPromptStyle = Vg),
                        (this.interactionPrompt = Gg),
                        (this.interactionPolicy = 'always-allow'),
                        (this.orbitSensitivity = 1),
                        (this.touchAction = 'pan-y'),
                        (this.disableZoom = !1),
                        (this.interpolationDecay = 50),
                        (this.bounds = 'legacy'),
                        (this[e] = this.shadowRoot.querySelector('.interaction-prompt')),
                        (this[i] = this.shadowRoot.querySelector('.interaction-prompt > .animated-container')),
                        (this[n] = 1 / 0),
                        (this[s] = 0),
                        (this[r] = 1 / 0),
                        (this[a] = !1),
                        (this[o] = !1),
                        (this[l] = new Lg(this[Zd].camera, this[Xd])),
                        (this[c] = 0),
                        (this[h] = new Ol()),
                        (this[u] = !1),
                        (this[d] = !1),
                        (this[p] = !1),
                        (this[A] = () => {
                          const t = this[Xd]
                          isFinite(this[gm]) || (this[gm] = performance.now())
                          const e = this[Wd]
                          t.getAttribute('aria-label') !== e && t.setAttribute('aria-label', e),
                            this.interactionPrompt !== zg || this[dm] || (this[um] = !0)
                        }),
                        (this[g] = () => {
                          this.interactionPrompt === zg &&
                            ((this[um] = !1),
                            this[im].classList.remove('visible'),
                            (this[pm] = 1 / 0),
                            (this[gm] = 1 / 0))
                        }),
                        (this[m] = ({ source: t }) => {
                          this[rm](),
                            this[$d](),
                            t === Tg && ((this[dm] = !0), this[sm]()),
                            this.dispatchEvent(new CustomEvent('camera-change', { detail: { source: t } }))
                        }),
                        (this[f] = (t) => {
                          'pointer-change-start' === t.type
                            ? this[Jd].classList.add('pointer-tumbling')
                            : this[Jd].classList.remove('pointer-tumbling')
                        })
                    }
                    getCameraOrbit() {
                      const { theta: t, phi: e, radius: i } = this[fm]
                      return {
                        theta: t,
                        phi: e,
                        radius: i,
                        toString() {
                          return `${this.theta}rad ${this.phi}rad ${this.radius}m`
                        },
                      }
                    }
                    getCameraTarget() {
                      return hp(this[np].isPresenting ? this[np].arRenderer.target : this[Zd].getTarget())
                    }
                    getFieldOfView() {
                      return this[em].getFieldOfView()
                    }
                    getMinimumFieldOfView() {
                      return this[em].options.minimumFieldOfView
                    }
                    getMaximumFieldOfView() {
                      return this[em].options.maximumFieldOfView
                    }
                    jumpCameraToGoal() {
                      ;(this[vm] = !0), this.requestUpdate(vm, !1)
                    }
                    resetInteractionPrompt() {
                      ;(this[Am] = 0),
                        (this[pm] = 1 / 0),
                        (this[dm] = !1),
                        (this[um] = this.interactionPrompt === Gg && this.cameraControls)
                    }
                    connectedCallback() {
                      super.connectedCallback(),
                        this[em].addEventListener('change', this[cm]),
                        this[em].addEventListener('pointer-change-start', this[hm]),
                        this[em].addEventListener('pointer-change-end', this[hm])
                    }
                    disconnectedCallback() {
                      super.disconnectedCallback(),
                        this[em].removeEventListener('change', this[cm]),
                        this[em].removeEventListener('pointer-change-start', this[hm]),
                        this[em].removeEventListener('pointer-change-end', this[hm])
                    }
                    updated(t) {
                      super.updated(t)
                      const e = this[em],
                        i = this[Xd]
                      if (
                        (t.has('cameraControls') &&
                          (this.cameraControls
                            ? (e.enableInteraction(),
                              this.interactionPrompt === Gg && (this[um] = !0),
                              i.addEventListener('focus', this[lm]),
                              i.addEventListener('blur', this[om]))
                            : (i.removeEventListener('focus', this[lm]),
                              i.removeEventListener('blur', this[om]),
                              e.disableInteraction(),
                              this[sm]())),
                        t.has('disableZoom') && (e.disableZoom = this.disableZoom),
                        t.has('bounds') && (this[Zd].tightBounds = 'tight' === this.bounds),
                        (t.has('interactionPrompt') || t.has('cameraControls') || t.has('src')) &&
                          (this.interactionPrompt === Gg && this.cameraControls && !this[dm]
                            ? (this[um] = !0)
                            : this[sm]()),
                        t.has('interactionPromptStyle') &&
                          this[im].classList.toggle('wiggle', this.interactionPromptStyle === Vg),
                        t.has('interactionPolicy'))
                      ) {
                        const t = this.interactionPolicy
                        e.applyOptions({ interactionPolicy: t })
                      }
                      if (t.has('touchAction')) {
                        const t = this.touchAction
                        e.applyOptions({ touchAction: t })
                      }
                      t.has('orbitSensitivity') && (e.sensitivity = this.orbitSensitivity),
                        t.has('interpolationDecay') &&
                          (e.setDamperDecayTime(this.interpolationDecay),
                          this[Zd].setTargetDamperDecayTime(this.interpolationDecay)),
                        !0 === this[vm] &&
                          Promise.resolve().then(() => {
                            e.jumpToGoal(), this[Zd].jumpToGoal(), (this[vm] = !1)
                          })
                    }
                    async updateFraming() {
                      const t = this[Zd],
                        e = t.framedFieldOfView
                      await this.requestUpdate('cameraTarget'),
                        t.updateFraming('tight' === this.bounds ? t.getTarget() : void 0),
                        t.frameModel()
                      const i = t.framedFieldOfView,
                        n = this[em].getFieldOfView() / e
                      ;(this[mm] = i * n),
                        (this[xm] = !0),
                        this.requestUpdate('maxFieldOfView'),
                        this.requestUpdate('fieldOfView'),
                        this.requestUpdate('minCameraOrbit'),
                        this.requestUpdate('maxCameraOrbit'),
                        await this.requestUpdate('cameraOrbit')
                    }
                    [((e = im),
                    (i = nm),
                    (n = gm),
                    (s = Am),
                    (r = pm),
                    (a = dm),
                    (o = um),
                    (l = em),
                    (c = mm),
                    (h = fm),
                    (u = vm),
                    (d = ym),
                    (p = xm),
                    _m)](t) {
                      this[em].setFieldOfView((180 * t[0]) / Math.PI)
                    }
                    [wm](t) {
                      if (this[xm]) {
                        const { theta: e, phi: i } = this.getCameraOrbit()
                        ;(t[0] = e), (t[1] = i), (this[xm] = !1)
                      }
                      this[em].setOrbit(t[0], t[1], t[2])
                    }
                    [Cm](t) {
                      this[em].applyOptions({
                        minimumAzimuthalAngle: t[0],
                        minimumPolarAngle: t[1],
                        minimumRadius: t[2],
                      }),
                        this.jumpCameraToGoal()
                    }
                    [Mm](t) {
                      this[em].applyOptions({
                        maximumAzimuthalAngle: t[0],
                        maximumPolarAngle: t[1],
                        maximumRadius: t[2],
                      }),
                        this[am](t[2]),
                        this.jumpCameraToGoal()
                    }
                    [Em](t) {
                      this[em].applyOptions({ minimumFieldOfView: (180 * t[0]) / Math.PI }), this.jumpCameraToGoal()
                    }
                    [bm](t) {
                      this[em].applyOptions({ maximumFieldOfView: (180 * t[0]) / Math.PI }), this.jumpCameraToGoal()
                    }
                    [Im](t) {
                      const [e, i, n] = t
                      this[Zd].setTarget(e, i, n), this[np].arRenderer.updateTarget()
                    }
                    [tp](t, e) {
                      if ((super[tp](t, e), this[np].isPresenting || !this[cp]())) return
                      const i = performance.now()
                      if (this[um]) {
                        const t = this.interactionPrompt === Gg ? this[qd] : this[gm]
                        this.loaded &&
                          i > t + this.interactionPromptThreshold &&
                          (this[Xd].setAttribute('aria-label', 'Use mouse, touch or arrow keys to control the camera!'),
                          (this[um] = !1),
                          (this[pm] = i),
                          this[im].classList.add('visible'))
                      }
                      if (isFinite(this[pm]) && this.interactionPromptStyle === Vg) {
                        const t = this[Zd],
                          e = ((i - this[pm]) / 5e3) % 1,
                          n = Ng(e),
                          s = Fg(e)
                        if (((this[nm].style.opacity = `${s}`), n !== this[Am])) {
                          const e = n * t.width * 0.05,
                            i = ((n - this[Am]) * Math.PI) / 16
                          ;(this[nm].style.transform = `translateX(${e}px)`),
                            this[em].adjustOrbit(i, 0, 0),
                            (this[Am] = n)
                        }
                      }
                      this[em].update(t, e), this[Zd].updateTarget(e)
                    }
                    [sm]() {
                      ;(this[um] = !1), this[im].classList.remove('visible'), (this[pm] = 1 / 0)
                    }
                    [am](t) {
                      const { idealCameraDistance: e } = this[Zd],
                        i = 2 * Math.max(e, t)
                      this[em].updateNearFar(0, i)
                    }
                    [rm]() {
                      const { theta: t, phi: e } = this[fm],
                        { theta: i, phi: n } = this[em].getCameraSpherical(this[fm]),
                        s = this.getRootNode()
                      if (null != s && s.activeElement === this) {
                        const s = (4 + Math.floor(((t % tm) + $g) / Kg)) % 4,
                          r = (4 + Math.floor(((i % tm) + $g) / Kg)) % 4,
                          a = Math.floor(e / Zg),
                          o = Math.floor(n / Zg)
                        if (r !== s || o !== a) {
                          const t = `View from stage ${Og[o]}${kg[r]}`
                          this[Xd].setAttribute('aria-label', t)
                        }
                      }
                    }
                    [ip](t) {
                      const e = this[em],
                        i = this[Zd].framedFieldOfView
                      super[ip](t)
                      const n = this[Zd].framedFieldOfView,
                        s = e.getFieldOfView() / i
                      ;(this[mm] = n * s),
                        e.updateAspect(this[Zd].aspect),
                        this.requestUpdate('maxFieldOfView', this.maxFieldOfView),
                        this.requestUpdate('fieldOfView', this.fieldOfView),
                        this.jumpCameraToGoal()
                    }
                    [ep]() {
                      super[ep]()
                      const { framedFieldOfView: t } = this[Zd]
                      ;(this[mm] = t),
                        this[ym] ? (this[xm] = !0) : (this[ym] = !0),
                        this.requestUpdate('maxFieldOfView', this.maxFieldOfView),
                        this.requestUpdate('fieldOfView', this.fieldOfView),
                        this.requestUpdate('minCameraOrbit', this.minCameraOrbit),
                        this.requestUpdate('maxCameraOrbit', this.maxCameraOrbit),
                        this.requestUpdate('cameraOrbit', this.cameraOrbit),
                        this.requestUpdate('cameraTarget', this.cameraTarget),
                        this.jumpCameraToGoal()
                    }
                  }
                  return (
                    (A = lm),
                    (g = om),
                    (m = cm),
                    (f = hm),
                    Pg([U({ type: Boolean, attribute: 'camera-controls' })], v.prototype, 'cameraControls', void 0),
                    Pg(
                      [
                        Eg({ intrinsics: jg, observeEffects: !0, updateHandler: wm }),
                        U({ type: String, attribute: 'camera-orbit', hasChanged: () => !0 }),
                      ],
                      v.prototype,
                      'cameraOrbit',
                      void 0,
                    ),
                    Pg(
                      [
                        Eg({ intrinsics: Xg, observeEffects: !0, updateHandler: Im }),
                        U({ type: String, attribute: 'camera-target', hasChanged: () => !0 }),
                      ],
                      v.prototype,
                      'cameraTarget',
                      void 0,
                    ),
                    Pg(
                      [
                        Eg({ intrinsics: Hg, observeEffects: !0, updateHandler: _m }),
                        U({ type: String, attribute: 'field-of-view', hasChanged: () => !0 }),
                      ],
                      v.prototype,
                      'fieldOfView',
                      void 0,
                    ),
                    Pg(
                      [
                        Eg({ intrinsics: Yg, updateHandler: Cm }),
                        U({ type: String, attribute: 'min-camera-orbit', hasChanged: () => !0 }),
                      ],
                      v.prototype,
                      'minCameraOrbit',
                      void 0,
                    ),
                    Pg(
                      [
                        Eg({ intrinsics: Jg, updateHandler: Mm }),
                        U({ type: String, attribute: 'max-camera-orbit', hasChanged: () => !0 }),
                      ],
                      v.prototype,
                      'maxCameraOrbit',
                      void 0,
                    ),
                    Pg(
                      [
                        Eg({ intrinsics: Wg, updateHandler: Em }),
                        U({ type: String, attribute: 'min-field-of-view', hasChanged: () => !0 }),
                      ],
                      v.prototype,
                      'minFieldOfView',
                      void 0,
                    ),
                    Pg(
                      [
                        Eg({ intrinsics: qg, updateHandler: bm }),
                        U({ type: String, attribute: 'max-field-of-view', hasChanged: () => !0 }),
                      ],
                      v.prototype,
                      'maxFieldOfView',
                      void 0,
                    ),
                    Pg(
                      [U({ type: Number, attribute: 'interaction-prompt-threshold' })],
                      v.prototype,
                      'interactionPromptThreshold',
                      void 0,
                    ),
                    Pg(
                      [U({ type: String, attribute: 'interaction-prompt-style' })],
                      v.prototype,
                      'interactionPromptStyle',
                      void 0,
                    ),
                    Pg(
                      [U({ type: String, attribute: 'interaction-prompt' })],
                      v.prototype,
                      'interactionPrompt',
                      void 0,
                    ),
                    Pg(
                      [U({ type: String, attribute: 'interaction-policy' })],
                      v.prototype,
                      'interactionPolicy',
                      void 0,
                    ),
                    Pg([U({ type: Number, attribute: 'orbit-sensitivity' })], v.prototype, 'orbitSensitivity', void 0),
                    Pg([U({ type: String, attribute: 'touch-action' })], v.prototype, 'touchAction', void 0),
                    Pg([U({ type: Boolean, attribute: 'disable-zoom' })], v.prototype, 'disableZoom', void 0),
                    Pg(
                      [U({ type: Number, attribute: 'interpolation-decay' })],
                      v.prototype,
                      'interpolationDecay',
                      void 0,
                    ),
                    Pg([U({ type: String, attribute: 'bounds' })], v.prototype, 'bounds', void 0),
                    v
                  )
                })(
                  ((t) => {
                    var e, i, n, s, r, a, o, l, c, h
                    class u extends t {
                      constructor() {
                        super(...arguments),
                          (this.ar = !1),
                          (this.arScale = 'auto'),
                          (this.arPlacement = 'floor'),
                          (this.arModes = 'webxr scene-viewer'),
                          (this.iosSrc = null),
                          (this.xrEnvironment = !1),
                          (this[e] = !1),
                          (this[i] = this.shadowRoot.querySelector('.ar-button')),
                          (this[n] = document.createElement('a')),
                          (this[s] = new Set()),
                          (this[r] = bA),
                          (this[a] = !1),
                          (this[o] = (t) => {
                            t.preventDefault(), this.activateAR()
                          }),
                          (this[l] = ({ status: t }) => {
                            ;(t !== Du && this[np].arRenderer.presentedScene !== this[Zd]) ||
                              (this.setAttribute('ar-status', t),
                              this.dispatchEvent(new CustomEvent('ar-status', { detail: { status: t } })),
                              t === Du
                                ? this.removeAttribute('ar-tracking')
                                : t === Qu && this.setAttribute('ar-tracking', Ru))
                          }),
                          (this[c] = ({ status: t }) => {
                            this.setAttribute('ar-tracking', t),
                              this.dispatchEvent(new CustomEvent('ar-tracking', { detail: { status: t } }))
                          }),
                          (this[h] = (t) => {
                            '_apple_ar_quicklook_button_tapped' == t.data &&
                              this.dispatchEvent(new CustomEvent('quick-look-button-tapped'))
                          })
                      }
                      get canActivateAR() {
                        return this[QA] !== bA
                      }
                      connectedCallback() {
                        super.connectedCallback(),
                          this[np].arRenderer.addEventListener('status', this[UA]),
                          this.setAttribute('ar-status', Du),
                          this[np].arRenderer.addEventListener('tracking', this[kA]),
                          this[PA].addEventListener('message', this[OA])
                      }
                      disconnectedCallback() {
                        super.disconnectedCallback(),
                          this[np].arRenderer.removeEventListener('status', this[UA]),
                          this[np].arRenderer.removeEventListener('tracking', this[kA]),
                          this[PA].removeEventListener('message', this[OA])
                      }
                      async update(t) {
                        super.update(t),
                          t.has('arScale') && (this[Zd].canScale = 'fixed' !== this.arScale),
                          t.has('arPlacement') && (this[Zd].setShadowIntensity(this[Zd].shadowIntensity), this[$d]()),
                          (t.has('ar') || t.has('arModes') || t.has('iosSrc')) &&
                            (t.has('arModes') && (this[RA] = _A(this.arModes)), this[GA]())
                      }
                      async activateAR() {
                        switch (this[QA]) {
                          case CA:
                            this[LA]()
                            break
                          case EA:
                            await this[BA]()
                            break
                          case MA:
                            this[TA]()
                        }
                      }
                      async [((e = DA),
                      (i = SA),
                      (n = PA),
                      (s = RA),
                      (r = QA),
                      (a = NA),
                      (o = FA),
                      (l = UA),
                      (c = kA),
                      (h = OA),
                      GA)]() {
                        if (((this[QA] = bA), this.ar)) {
                          if (null != this.src)
                            for (const t of this[RA]) {
                              if ('webxr' === t && Y && !xA && (await this[np].arRenderer.supportsPresentation())) {
                                this[QA] = EA
                                break
                              }
                              if ('scene-viewer' === t && tt && !wA) {
                                this[QA] = MA
                                break
                              }
                              if ('quick-look' === t && K) {
                                this[QA] = CA
                                break
                              }
                            }
                          !this.canActivateAR && null != this.iosSrc && K && (this[QA] = CA)
                        }
                        if (this.canActivateAR)
                          this[SA].classList.add('enabled'), this[SA].addEventListener('click', this[FA])
                        else if (this[SA].classList.contains('enabled')) {
                          this[SA].removeEventListener('click', this[FA]), this[SA].classList.remove('enabled')
                          const t = 'failed'
                          this.setAttribute('ar-status', t),
                            this.dispatchEvent(new CustomEvent('ar-status', { detail: { status: t } }))
                        }
                      }
                      async [BA]() {
                        await this[zA]()
                        try {
                          this[SA].removeEventListener('click', this[FA])
                          const { arRenderer: t } = this[np]
                          ;(t.placeOnWall = 'wall' === this.arPlacement), await t.present(this[Zd], this.xrEnvironment)
                        } catch (t) {
                          await this[np].arRenderer.stopPresenting(), (xA = !0), await this[GA](), this.activateAR()
                        } finally {
                          this[GA]()
                        }
                      }
                      async [zA]() {
                        this.loaded ||
                          ((this[NA] = !0),
                          this[jd](),
                          await ((t, e, i = null) =>
                            new Promise((n) => {
                              t.addEventListener(e, function s(r) {
                                ;(i && !i(r)) || (n(r), t.removeEventListener(e, s))
                              })
                            }))(
                            /* @license
                             * Copyright 2020 Google LLC. All Rights Reserved.
                             * Licensed under the Apache License, Version 2.0 (the 'License');
                             * you may not use this file except in compliance with the License.
                             * You may obtain a copy of the License at
                             *
                             *     http://www.apache.org/licenses/LICENSE-2.0
                             *
                             * Unless required by applicable law or agreed to in writing, software
                             * distributed under the License is distributed on an 'AS IS' BASIS,
                             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                             * See the License for the specific language governing permissions and
                             * limitations under the License.
                             */ this,
                            'load',
                          ),
                          (this[NA] = !1))
                      }
                      [op]() {
                        return super[op]() || this[NA]
                      }
                      [TA]() {
                        const t = self.location.toString(),
                          e = new URL(t),
                          i = new URL(this.src, t),
                          n = new URLSearchParams(i.search)
                        if (
                          ((e.hash = '#model-viewer-no-ar-fallback'),
                          n.set('mode', 'ar_preferred'),
                          n.has('disable_occlusion') || n.set('disable_occlusion', 'true'),
                          'fixed' === this.arScale && n.set('resizable', 'false'),
                          'wall' === this.arPlacement && n.set('enable_vertical_placement', 'true'),
                          n.has('sound'))
                        ) {
                          const e = new URL(n.get('sound'), t)
                          n.set('sound', e.toString())
                        }
                        if (n.has('link')) {
                          const e = new URL(n.get('link'), t)
                          n.set('link', e.toString())
                        }
                        const s = `intent://arvr.google.com/scene-viewer/1.0?${
                          n.toString() + '&file=' + encodeURIComponent(i.toString())
                        }#Intent;scheme=https;package=com.google.ar.core;action=android.intent.action.VIEW;S.browser_fallback_url=${encodeURIComponent(
                          e.toString(),
                        )};end;`
                        self.addEventListener(
                          'hashchange',
                          () => {
                            '#model-viewer-no-ar-fallback' === self.location.hash &&
                              ((wA = !0), self.history.back(), this[GA]())
                          },
                          { once: !0 },
                        ),
                          this[PA].setAttribute('href', s),
                          this[PA].click()
                      }
                      async [LA]() {
                        const t = !this.iosSrc
                        this[SA].classList.remove('enabled')
                        const e = t ? await this.prepareUSDZ() : this.iosSrc,
                          i = new URL(e, self.location.toString())
                        'fixed' === this.arScale && (i.hash && (i.hash += '&'), (i.hash += 'allowsContentScaling=0'))
                        const n = this[PA]
                        n.setAttribute('rel', 'ar')
                        const s = document.createElement('img')
                        n.appendChild(s),
                          n.setAttribute('href', i.toString()),
                          t && n.setAttribute('download', 'model.usdz'),
                          n.click(),
                          n.removeChild(s),
                          t && URL.revokeObjectURL(e),
                          this[SA].classList.add('enabled')
                      }
                      async prepareUSDZ() {
                        const t = this[sp].beginActivity()
                        await this[zA]()
                        const e = this[Zd],
                          i = e.shadow
                        let n = !1
                        null != i && ((n = i.visible), (i.visible = !1)), t(0.2)
                        const s = new dA(),
                          r = await s.parse(e.modelContainer),
                          a = new Blob([r], { type: 'model/vnd.usdz+zip' }),
                          o = URL.createObjectURL(a)
                        return t(1), null != i && (i.visible = n), o
                      }
                    }
                    return (
                      yA([U({ type: Boolean, attribute: 'ar' })], u.prototype, 'ar', void 0),
                      yA([U({ type: String, attribute: 'ar-scale' })], u.prototype, 'arScale', void 0),
                      yA([U({ type: String, attribute: 'ar-placement' })], u.prototype, 'arPlacement', void 0),
                      yA([U({ type: String, attribute: 'ar-modes' })], u.prototype, 'arModes', void 0),
                      yA([U({ type: String, attribute: 'ios-src' })], u.prototype, 'iosSrc', void 0),
                      yA([U({ type: Boolean, attribute: 'xr-environment' })], u.prototype, 'xrEnvironment', void 0),
                      u
                    )
                  })(
                    ((t) => {
                      var e, i, n, s, r, a, o, l, c, h, u, d, p
                      class A extends t {
                        constructor(...t) {
                          super(...t),
                            (this.poster = null),
                            (this.reveal = Qm),
                            (this.loading = 'auto'),
                            (this[e] = !1),
                            (this[i] = !1),
                            (this[n] = 0),
                            (this[s] = null),
                            (this[r] = this.shadowRoot.querySelector('.slot.poster')),
                            (this[a] = this.shadowRoot.querySelector('#default-poster')),
                            (this[o] = this.shadowRoot.querySelector('#default-progress-bar > .bar')),
                            (this[l] = this.shadowRoot.querySelector('#default-progress-bar > .mask')),
                            (this[c] = this[km].getAttribute('aria-label')),
                            (this[h] = ((t, e) => {
                              let i = null
                              const n = (...e) => {
                                null == i && (t(...e), (i = self.setTimeout(() => (i = null), 100)))
                              }
                              return (
                                (n.flush = () => {
                                  null != i && (self.clearTimeout(i), (i = null))
                                }),
                                n
                              )
                            })((t) => {
                              const e = this[Nm].parentNode
                              requestAnimationFrame(() => {
                                ;(this[Fm].style.opacity = '' + 0.2 * (1 - t)),
                                  (this[Nm].style.transform = `scaleX(${t})`),
                                  0 === t && (e.removeChild(this[Nm]), e.appendChild(this[Nm])),
                                  1 === t ? this[Nm].classList.add('hide') : this[Nm].classList.remove('hide')
                              })
                            })),
                            (this[u] = () => {
                              this.reveal !== Rm && this.dismissPoster()
                            }),
                            (this[d] = (t) => {
                              if (this.reveal !== Rm)
                                switch (t.keyCode) {
                                  case 32:
                                  case 13:
                                    this.dismissPoster()
                                }
                            }),
                            (this[p] = (t) => {
                              const e = t.detail.totalProgress
                              ;(this[Hm] = Math.max(e, this[Hm])),
                                1 === e &&
                                  (this[Vm].flush(),
                                  !this[lp]() || (null == this[Om] && this.reveal !== Qm) || this[Gm]()),
                                this[Vm](e),
                                this.dispatchEvent(new CustomEvent('progress', { detail: { totalProgress: e } }))
                            })
                          const A = self.ModelViewerElement || {},
                            g = A.dracoDecoderLocation || 'https://www.gstatic.com/draco/versioned/decoders/1.3.6/'
                          bh.setDRACODecoderLocation(g)
                          const m =
                            A.ktx2TranscoderLocation ||
                            'https://www.gstatic.com/basis-universal/versioned/2021-04-15-ba1c3e4/'
                          bh.setKTX2TranscoderLocation(m)
                        }
                        static set dracoDecoderLocation(t) {
                          bh.setDRACODecoderLocation(t)
                        }
                        static get dracoDecoderLocation() {
                          return bh.getDRACODecoderLocation()
                        }
                        static set ktx2TranscoderLocation(t) {
                          bh.setKTX2TranscoderLocation(t)
                        }
                        static get ktx2TranscoderLocation() {
                          return bh.getKTX2TranscoderLocation()
                        }
                        static mapURLs(t) {
                          gd.singleton.loader[Ch].manager.setURLModifier(t)
                        }
                        dismissPoster() {
                          this[lp]() ? this[Gm]() : ((this[Om] = 'interaction'), this[jd]())
                        }
                        showPoster() {
                          const t = this[Um],
                            e = this[km]
                          e.removeAttribute('tabindex'), e.removeAttribute('aria-hidden'), t.classList.add('show')
                          const i = this.modelIsVisible
                          ;(this[zm] = !1), this[Hd](i), (this[Wm] = !1)
                        }
                        getDimensions() {
                          return hp(this[Zd].size)
                        }
                        connectedCallback() {
                          super.connectedCallback(),
                            this[Um].addEventListener('click', this[jm]),
                            this[Um].addEventListener('keydown', this[Ym]),
                            this[sp].addEventListener('progress', this[Jm]),
                            Pm.registerInstance(this)
                        }
                        disconnectedCallback() {
                          super.disconnectedCallback(),
                            this[Um].removeEventListener('click', this[jm]),
                            this[Um].removeEventListener('keydown', this[Ym]),
                            this[sp].removeEventListener('progress', this[Jm]),
                            Pm.unregisterInstance(this)
                        }
                        async updated(t) {
                          super.updated(t),
                            t.has('poster') &&
                              null != this.poster &&
                              (this[km].style.backgroundImage = `url(${this.poster})`),
                            t.has('alt') && this[km].setAttribute('aria-label', `${this[Wd]}. ${this[qm]}`),
                            (t.has('reveal') || t.has('loading')) && this[jd]()
                        }
                        [((e = zm),
                        (i = Wm),
                        (n = Hm),
                        (s = Om),
                        (r = Um),
                        (a = km),
                        (o = Nm),
                        (l = Fm),
                        (c = qm),
                        (h = Vm),
                        (u = jm),
                        (d = Ym),
                        (p = Jm),
                        op)]() {
                          return (
                            !!this.src &&
                            (null != this[Om] || 'eager' === this.loading || (this.reveal === Qm && this[Vd]))
                          )
                        }
                        [lp]() {
                          const { src: t } = this
                          return !!t && super[lp]() && 1 === this[Hm]
                        }
                        [Gm]() {
                          this[Om] = null
                          const t = this[Um],
                            e = this[km]
                          if (t.classList.contains('show')) {
                            t.classList.remove('show')
                            const i = this.modelIsVisible
                            ;(this[zm] = !0),
                              this[Hd](i),
                              t.addEventListener(
                                'transitionend',
                                () => {
                                  requestAnimationFrame(() => {
                                    this[Wm] = !0
                                    const t = this.getRootNode()
                                    t && t.activeElement === this && this[Xd].focus(),
                                      e.setAttribute('aria-hidden', 'true'),
                                      (e.tabIndex = -1),
                                      this.dispatchEvent(new CustomEvent('poster-dismissed'))
                                  })
                                },
                                { once: !0 },
                              )
                          }
                        }
                        [ap]() {
                          return super[ap]() && this[zm]
                        }
                        [cp]() {
                          return super[cp]() && this[Wm]
                        }
                        async [jd]() {
                          ;(this[Hm] = 0),
                            (null != this[Zd].currentGLTF && null != this.src && this[op]()) || this.showPoster(),
                            await super[jd]()
                        }
                      }
                      return (
                        Dm([U({ type: String })], A.prototype, 'poster', void 0),
                        Dm([U({ type: String })], A.prototype, 'reveal', void 0),
                        Dm([U({ type: String })], A.prototype, 'loading', void 0),
                        A
                      )
                    })(
                      ((t) => {
                        var e
                        class i extends t {
                          constructor() {
                            super(...arguments),
                              (this.autoplay = !1),
                              (this.animationName = void 0),
                              (this.animationCrossfadeDuration = 300),
                              (this[e] = !0)
                          }
                          get availableAnimations() {
                            return this.loaded ? this[Zd].animationNames : []
                          }
                          get duration() {
                            return this[Zd].duration
                          }
                          get paused() {
                            return this[Ap]
                          }
                          get currentTime() {
                            return this[Zd].animationTime
                          }
                          set currentTime(t) {
                            ;(this[Zd].animationTime = t),
                              (this[np].threeRenderer.shadowMap.needsUpdate = !0),
                              this[$d]()
                          }
                          pause() {
                            this[Ap] ||
                              ((this[Ap] = !0),
                              (this[np].threeRenderer.shadowMap.autoUpdate = !1),
                              this.dispatchEvent(new CustomEvent('pause')))
                          }
                          play() {
                            this[Ap] &&
                              this.availableAnimations.length > 0 &&
                              ((this[Ap] = !1),
                              (this[np].threeRenderer.shadowMap.autoUpdate = !0),
                              this[Zd].hasActiveAnimation || this[pp](),
                              this.dispatchEvent(new CustomEvent('play')))
                          }
                          [((e = Ap), ep)]() {
                            super[ep](), (this[Ap] = !0), this.autoplay && (this[pp](), this.play())
                          }
                          [tp](t, e) {
                            super[tp](t, e),
                              this[Ap] ||
                                (!this[cp]() && !this[np].isPresenting) ||
                                (this[Zd].updateAnimation(e / 1e3), this[$d]())
                          }
                          updated(t) {
                            super.updated(t),
                              t.has('autoplay') && this.autoplay && this.play(),
                              t.has('animationName') && this[pp]()
                          }
                          async [jd]() {
                            return this[Zd].stopAnimation(), super[jd]()
                          }
                          [pp]() {
                            this[Zd].playAnimation(this.animationName, this.animationCrossfadeDuration / 1e3),
                              this[Ap] && (this[Zd].updateAnimation(0), this[$d]())
                          }
                        }
                        return (
                          dp([U({ type: Boolean })], i.prototype, 'autoplay', void 0),
                          dp([U({ type: String, attribute: 'animation-name' })], i.prototype, 'animationName', void 0),
                          dp(
                            [U({ type: Number, attribute: 'animation-crossfade-duration' })],
                            i.prototype,
                            'animationCrossfadeDuration',
                            void 0,
                          ),
                          i
                        )
                      })(
                        ((t) => {
                          var e
                          const i = Symbol('endPolyfillCoordination')
                          return (
                            (e = i),
                            class extends t {
                              constructor() {
                                super(...arguments), (this[e] = null)
                              }
                              connectedCallback() {
                                super.connectedCallback && super.connectedCallback(),
                                  null == this[i] &&
                                    (this[i] = ((t) => {
                                      if (null == t.shadowRoot || t.hasAttribute('data-js-focus-visible'))
                                        return () => {}
                                      if (!self.applyFocusVisiblePolyfill) {
                                        const e = () => {
                                          self.applyFocusVisiblePolyfill(t.shadowRoot)
                                        }
                                        return (
                                          self.addEventListener('focus-visible-polyfill-ready', e, { once: !0 }),
                                          () => {
                                            self.removeEventListener('focus-visible-polyfill-ready', e)
                                          }
                                        )
                                      }
                                      return self.applyFocusVisiblePolyfill(t.shadowRoot), () => {}
                                    })(this))
                              }
                              disconnectedCallback() {
                                super.disconnectedCallback && super.disconnectedCallback(),
                                  null != this[i] && (this[i](), (this[i] = null))
                              }
                            }
                          )
                        })(up),
                      ),
                    ),
                  ),
                ),
              ),
            ),
          ),
        )
      customElements.define('model-viewer', mv)
    },
  },
])
//# sourceMappingURL=WIPED
